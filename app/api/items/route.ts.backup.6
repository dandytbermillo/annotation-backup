import { NextRequest, NextResponse } from 'next/server'
import { serverPool } from '@/lib/db/pool'
import { WorkspaceStore } from '@/lib/workspace/workspace-store'

// GET /api/items - Get tree or search items
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const search = searchParams.get('search')
    const type = searchParams.get('type')
    const parentId = searchParams.get('parentId')
    const limit = parseInt(searchParams.get('limit') || '100')
    
    let query: string
    let values: any[] = []
    
    if (search) {
      // Search items
      query = `
        SELECT 
          id, type, parent_id, path, name, slug, position,
          metadata, icon, color, last_accessed_at,
          created_at, updated_at
        FROM items 
        WHERE deleted_at IS NULL
          AND (name ILIKE $1 OR path ILIKE $1)
          ${type ? 'AND type = $2' : ''}
        ORDER BY 
          CASE WHEN name ILIKE $1 THEN 0 ELSE 1 END,
          length(path)
        LIMIT $${type ? 3 : 2}
      `
      values = [`%${search}%`]
      if (type) values.push(type)
      values.push(limit)
    } else if (type && !parentId) {
      // Filter by type only
      query = `
        SELECT 
          id, type, parent_id, path, name, slug, position,
          metadata, icon, color, last_accessed_at,
          created_at, updated_at
        FROM items 
        WHERE deleted_at IS NULL
          AND type = $1
        ORDER BY path
        LIMIT $2
      `
      values = [type, limit]
    } else if (parentId !== undefined) {
      // Get children of specific parent
      query = `
        SELECT 
          id, type, parent_id, path, name, slug, position,
          metadata, icon, color, last_accessed_at,
          created_at, updated_at
        FROM items 
        WHERE parent_id ${parentId === 'null' ? 'IS NULL' : '= $1'} 
          AND deleted_at IS NULL
        ORDER BY type DESC, position, name
      `
      values = parentId === 'null' ? [] : [parentId]
    } else {
      // Get full tree structure (limited depth for performance)
      query = `
        WITH RECURSIVE tree AS (
          SELECT 
            id, type, parent_id, path, name, slug, position,
            metadata, icon, color, last_accessed_at,
            created_at, updated_at,
            0 as depth
          FROM items 
          WHERE parent_id IS NULL AND deleted_at IS NULL
          
          UNION ALL
          
          SELECT 
            i.id, i.type, i.parent_id, i.path, i.name, i.slug, i.position,
            i.metadata, i.icon, i.color, i.last_accessed_at,
            i.created_at, i.updated_at,
            t.depth + 1
          FROM items i
          JOIN tree t ON i.parent_id = t.id
          WHERE i.deleted_at IS NULL AND t.depth < 3
        )
        SELECT * FROM tree ORDER BY path
      `
      values = []
    }
    
    const result = await serverPool.query(query, values)
    
    const items = result.rows.map(row => ({
      id: row.id,
      type: row.type,
      parentId: row.parent_id,
      path: row.path,
      name: row.name,
      slug: row.slug,
      position: row.position,
      metadata: row.metadata,
      icon: row.icon,
      color: row.color,
      lastAccessedAt: row.last_accessed_at,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      depth: row.depth
    }))
    
    return NextResponse.json({ items })
  } catch (error) {
    console.error('Error fetching items:', error)
    return NextResponse.json(
      { error: 'Failed to fetch items' },
      { status: 500 }
    )
  }
}

// POST /api/items - Create new item (folder or note)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { type, parentId, name, content, metadata = {}, icon, color, position = 0 } = body
    
    // Validate required fields
    if (!type || !name) {
      return NextResponse.json(
        { error: 'Type and name are required' },
        { status: 400 }
      )
    }
    
    // Get parent path if parentId provided
    let parentPath = ''
    if (parentId) {
      const parentResult = await serverPool.query(
        'SELECT path FROM items WHERE id = $1 AND deleted_at IS NULL',
        [parentId]
      )
      if (parentResult.rows.length === 0) {
        return NextResponse.json(
          { error: 'Parent not found' },
          { status: 404 }
        )
      }
      parentPath = parentResult.rows[0].path
    }
    
    // Construct path
    const path = parentPath ? `${parentPath}/${name}` : `/${name}`
    
    // Always get workspace_id since database requires it (NOT NULL constraint)
    let workspaceId = null;
    try {
      workspaceId = await WorkspaceStore.getDefaultWorkspaceId(serverPool);
    } catch (e) {
      console.error('Failed to get workspace ID:', e);
      return NextResponse.json(
        { error: 'Failed to get workspace' },
        { status: 500 }
      );
    }
    
    // Always include workspace_id in INSERT since it's required
    const query = `
      INSERT INTO items (
        type, parent_id, path, name, content, 
        metadata, icon, color, position, workspace_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
      ) RETURNING *
    `
    
    const values = [
      type,
      parentId || null,
      path,
      name,
      type === 'note' ? (content || null) : null,
      metadata,
      icon || null,
      color || null,
      position,
      workspaceId
    ]
    
    const result = await serverPool.query(query, values)
    
    const row = result.rows[0]
    const item = {
      id: row.id,
      type: row.type,
      parentId: row.parent_id,
      path: row.path,
      name: row.name,
      slug: row.slug,
      position: row.position,
      content: row.content,
      metadata: row.metadata,
      icon: row.icon,
      color: row.color,
      lastAccessedAt: row.last_accessed_at,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    }
    
    // Dual-write: Also create in notes table if it's a note
    if (type === 'note') {
      await serverPool.query(`
        INSERT INTO notes (id, title, metadata, workspace_id, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (id) DO UPDATE SET
          title = EXCLUDED.title,
          metadata = EXCLUDED.metadata,
          updated_at = EXCLUDED.updated_at
      `, [row.id, name, metadata, workspaceId, row.created_at, row.updated_at])
    }
    
    return NextResponse.json({ item }, { status: 201 })
  } catch (error) {
    console.error('Error creating item:', error)
    return NextResponse.json(
      { error: 'Failed to create item' },
      { status: 500 }
    )
  }
}

// GET /api/items/recent - Get recent notes
export async function GET_RECENT(request: NextRequest) {
  if (!request.url.includes('/recent')) {
    return GET(request)
  }
  
  try {
    const limit = parseInt(request.nextUrl.searchParams.get('limit') || '10')
    
    const query = `
      SELECT 
        id, type, parent_id, path, name, slug, position,
        metadata, icon, color, last_accessed_at,
        created_at, updated_at
      FROM items 
      WHERE type = 'note' 
        AND deleted_at IS NULL 
        AND last_accessed_at IS NOT NULL
      ORDER BY last_accessed_at DESC
      LIMIT $1
    `
    
    const result = await serverPool.query(query, [limit])
    
    const items = result.rows.map(row => ({
      id: row.id,
      type: row.type,
      parentId: row.parent_id,
      path: row.path,
      name: row.name,
      slug: row.slug,
      position: row.position,
      metadata: row.metadata,
      icon: row.icon,
      color: row.color,
      lastAccessedAt: row.last_accessed_at,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    }))
    
    return NextResponse.json({ items })
  } catch (error) {
    console.error('Error fetching recent items:', error)
    return NextResponse.json(
      { error: 'Failed to fetch recent items' },
      { status: 500 }
    )
  }
}