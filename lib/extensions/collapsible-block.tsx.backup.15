import { Node, Mark, mergeAttributes } from '@tiptap/core'
import { NodeViewWrapper, NodeViewContent, ReactNodeViewRenderer, useEditor, EditorContent } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Highlight from '@tiptap/extension-highlight'
import Underline from '@tiptap/extension-underline'
import { DOMSerializer, Node as PMNode } from 'prosemirror-model'
import { useState, useRef, useEffect, useMemo, useCallback } from 'react'
import { createPortal } from 'react-dom'
import { debugLog, createContentPreview } from '@/lib/debug-logger'

const DEFAULT_BLOCK_TITLE = 'Block title here...'

type TemplateMarkSpec = {
  type: string
  attrs?: Record<string, any>
}

type TemplateNodeSpec = {
  type: string
  attrs?: Record<string, any>
  content?: TemplateNodeSpec[]
  text?: string
  marks?: TemplateMarkSpec[]
}

type CollapsibleTemplate = {
  id: string
  label: string
  description: string
  title?: string
  buildContent: () => TemplateNodeSpec[]
  previewLines: string[]
}

const DEFAULT_TEMPLATE_ID = 'outline'

type TemplateSnapshot = {
  nodeJSON: JSONNode
}

const buildTemplateDoc = (template: CollapsibleTemplate): JSONNode => ({
  type: 'doc',
  content: template.buildContent(),
})

const COLLAPSIBLE_TEMPLATES: CollapsibleTemplate[] = [
  {
    id: 'outline',
    label: 'Outline',
    description: 'Generic outline with summary and nested bullet points.',
    previewLines: [
      'Summary paragraph placeholder',
      '- Main point 1',
      '- Main point 2 (with sub-points)',
    ],
    buildContent: () => [
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Description paragraph here...' },
        ],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Main point 1' }],
              },
            ],
          },
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Main point 2' }],
              },
              {
                type: 'bulletList',
                content: [
                  {
                    type: 'listItem',
                    content: [
                      {
                        type: 'paragraph',
                        content: [{ type: 'text', text: 'Sub-point 2.1' }],
                      },
                    ],
                  },
                  {
                    type: 'listItem',
                    content: [
                      {
                        type: 'paragraph',
                        content: [{ type: 'text', text: 'Sub-point 2.2' }],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Main point 3' }],
              },
              {
                type: 'bulletList',
                content: [
                  {
                    type: 'listItem',
                    content: [
                      {
                        type: 'paragraph',
                        content: [{ type: 'text', text: 'Sub-point 3.1' }],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: 'checklist',
    label: 'Checklist',
    description: 'Tasks with owner and status reminders.',
    title: 'Checklist',
    previewLines: [
      '[ ] Task - Owner (Status)',
      '[ ] Task - Owner (Status)',
      'Add notes under each item',
    ],
    buildContent: () => [
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Track tasks, owners, and current status.' },
        ],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: '[ ] Task 1 - Owner (Status)' }],
              },
              {
                type: 'bulletList',
                content: [
                  {
                    type: 'listItem',
                    content: [
                      {
                        type: 'paragraph',
                        content: [{ type: 'text', text: 'Notes or next steps' }],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: '[ ] Task 2 - Owner (Status)' }],
              },
              {
                type: 'bulletList',
                content: [
                  {
                    type: 'listItem',
                    content: [
                      {
                        type: 'paragraph',
                        content: [{ type: 'text', text: 'Notes or blockers' }],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: 'decision-log',
    label: 'Decision Log',
    description: 'Record context, options, outcome, and follow-ups.',
    title: 'Decision Log',
    previewLines: [
      'Context, options, decision, follow-up',
      'Bullet list of options with notes',
      'Next review reminder',
    ],
    buildContent: () => [
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Context: ', marks: [{ type: 'bold' }] },
          { type: 'text', text: 'What decision are we making and why now?' },
        ],
      },
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Options', marks: [{ type: 'bold' }] },
        ],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [
                  { type: 'text', text: 'Option A - key trade-offs' },
                ],
              },
            ],
          },
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [
                  { type: 'text', text: 'Option B - key trade-offs' },
                ],
              },
            ],
          },
        ],
      },
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Decision: ', marks: [{ type: 'bold' }] },
          { type: 'text', text: 'Chosen option and rationale.' },
        ],
      },
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Follow-up: ', marks: [{ type: 'bold' }] },
          { type: 'text', text: 'Next review date or success criteria.' },
        ],
      },
    ],
  },
  {
    id: 'retro',
    label: 'Retro',
    description: 'Start, stop, continue prompts for retrospectives.',
    title: 'Retro',
    previewLines: [
      'Start doing',
      'Stop doing',
      'Continue doing',
    ],
    buildContent: () => [
      {
        type: 'heading',
        attrs: { level: 3 },
        content: [{ type: 'text', text: 'Start doing' }],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Idea to try next' }],
              },
            ],
          },
        ],
      },
      {
        type: 'heading',
        attrs: { level: 3 },
        content: [{ type: 'text', text: 'Stop doing' }],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Pain point or anti-pattern' }],
              },
            ],
          },
        ],
      },
      {
        type: 'heading',
        attrs: { level: 3 },
        content: [{ type: 'text', text: 'Continue doing' }],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Practice that worked well' }],
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: 'meeting-notes',
    label: 'Meeting Notes',
    description: 'Agenda outline plus attendees and action items.',
    title: 'Meeting Notes',
    previewLines: [
      'Agenda with discussion bullets',
      'Attendees section',
      'Action items list',
    ],
    buildContent: () => [
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Date: ' },
          { type: 'text', text: 'Add meeting date here' },
        ],
      },
      {
        type: 'paragraph',
        content: [
          { type: 'text', text: 'Attendees: ' },
          { type: 'text', text: 'List participants' },
        ],
      },
      {
        type: 'heading',
        attrs: { level: 3 },
        content: [{ type: 'text', text: 'Agenda' }],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Topic 1 - goal or owner' }],
              },
            ],
          },
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: 'Topic 2 - goal or owner' }],
              },
            ],
          },
        ],
      },
      {
        type: 'heading',
        attrs: { level: 3 },
        content: [{ type: 'text', text: 'Action items' }],
      },
      {
        type: 'bulletList',
        content: [
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: '[ ] Action - owner and due date' }],
              },
            ],
          },
          {
            type: 'listItem',
            content: [
              {
                type: 'paragraph',
                content: [{ type: 'text', text: '[ ] Action - owner and due date' }],
              },
            ],
          },
        ],
      },
    ],
  },
]

const getTemplateById = (id?: string | null) =>
  COLLAPSIBLE_TEMPLATES.find(template => template.id === id) ?? null

const AnnotationMark = Mark.create({
  name: 'annotation',
  inclusive: true,

  addOptions() {
    return { HTMLAttributes: {} }
  },

  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: element => element.getAttribute('data-annotation-id'),
        renderHTML: attrs => (attrs.id ? { 'data-annotation-id': attrs.id } : {}),
      },
      type: {
        default: null,
        parseHTML: element => element.getAttribute('data-type'),
        renderHTML: attrs => (attrs.type ? { 'data-type': attrs.type } : {}),
      },
      branchId: {
        default: null,
        parseHTML: element => element.getAttribute('data-branch'),
        renderHTML: attrs => (attrs.branchId ? { 'data-branch': attrs.branchId } : {}),
      },
    }
  },

  parseHTML() {
    return [
      { tag: 'span[data-annotation-id]' },
      { tag: 'span.annotation[data-branch]' },
      { tag: 'span[data-branch]' },
    ]
  },

  renderHTML({ HTMLAttributes, mark }) {
    const type = mark.attrs.type || 'note'
    const attrs: Record<string, any> = {
      class: `annotation annotation-${type}`,
      'data-type': type,
    }

    if (mark.attrs.branchId) {
      attrs['data-branch'] = mark.attrs.branchId
      attrs['data-branch-id'] = mark.attrs.branchId
    }

    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, attrs), 0]
  },
})

type JSONNode = ReturnType<PMNode['toJSON']>

const expandCollapsibleNodes = (jsonNode: JSONNode): JSONNode => {
  if (!jsonNode) return jsonNode

  const next: JSONNode = Array.isArray(jsonNode)
    ? jsonNode.map(child => expandCollapsibleNodes(child))
    : { ...jsonNode }

  if (Array.isArray(next)) {
    return next
  }

  if (next.type === 'collapsibleBlock') {
    next.attrs = { ...next.attrs, collapsed: false }
  }

  if (next.content) {
    next.content = next.content.map(child => expandCollapsibleNodes(child))
  }

  return next
}

const buildInspectorDoc = (pmNode: PMNode) => ({
  type: 'doc',
  content: [expandCollapsibleNodes(pmNode.toJSON())],
})

type BlockStats = {
  directChildren: number
  totalBlocks: number
  nestedCollapsibleCount: number
}

const computeBlockStats = (pmNode?: PMNode | null): BlockStats => {
  if (!pmNode) {
    return { directChildren: 0, totalBlocks: 0, nestedCollapsibleCount: 0 }
  }

  let totalBlocks = 0
  let nestedCollapsibleCount = 0

  pmNode.descendants(child => {
    if (child.isBlock) {
      totalBlocks += 1
    }
    if (child.type.name === 'collapsibleBlock') {
      nestedCollapsibleCount += 1
    }
  })

  return {
    directChildren: pmNode.childCount,
    totalBlocks,
    nestedCollapsibleCount,
  }
}

const formatBlockMeta = (stats: BlockStats): string => {
  if (!stats.directChildren) {
    return 'No items yet'
  }

  const parts = [`${stats.directChildren} item${stats.directChildren === 1 ? '' : 's'}`]

  if (stats.nestedCollapsibleCount > 0) {
    parts.push(`${stats.nestedCollapsibleCount} nested block${stats.nestedCollapsibleCount === 1 ? '' : 's'}`)
  }

  return parts.join(' • ')
}

const getDisplayTitle = (title?: string | null) => {
  const trimmed = (title || '').trim()
  return trimmed || DEFAULT_BLOCK_TITLE
}

// Define the schema for the collapsible block
export const CollapsibleBlock = Node.create({
  name: 'collapsibleBlock',
  group: 'block',
  content: 'block+',
  defining: true,
  
  addOptions() {
    return {
      HTMLAttributes: {},
      inspectorPreview: false,
    }
  },

  addAttributes() {
    return {
      collapsed: {
        default: false,
        parseHTML: element => element.getAttribute('data-collapsed') === 'true',
        renderHTML: attributes => {
          return { 'data-collapsed': attributes.collapsed }
        },
      },
      title: {
        default: DEFAULT_BLOCK_TITLE,
        parseHTML: element => element.getAttribute('data-title') || DEFAULT_BLOCK_TITLE,
        renderHTML: attributes => {
          const value = getDisplayTitle(attributes.title)
          return { 'data-title': value }
        },
      },
      templateId: {
        default: null,
        parseHTML: element => element.getAttribute('data-template'),
        renderHTML: attributes => (attributes.templateId ? { 'data-template': attributes.templateId } : {}),
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-collapsible-block]',
      },
    ]
  },

  renderHTML({ node, HTMLAttributes }) {
    const attributes = mergeAttributes(HTMLAttributes, {
      'data-collapsible-block': '',
      ...(node.attrs.templateId ? { 'data-template': node.attrs.templateId } : {}),
    })

    const { collapsed, title } = node.attrs
    const displayTitle = getDisplayTitle(title)
    const stats = computeBlockStats(node)
    const metaBase = formatBlockMeta(stats)
    const metaLabel = metaBase

    const headerChildren: any[] = [
      [
        'span',
        {
          'data-collapsible-arrow': '',
          style: `display:inline-block;margin-right:8px;transition:transform 0.2s ease;transform:${collapsed ? 'rotate(-90deg)' : 'rotate(0deg)'}`,
        },
        '▼',
      ],
      [
        'span',
        {
          'data-collapsible-title': '',
          style: 'font-weight:600;font-size:16px;flex:1 1 auto;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;',
        },
        displayTitle,
      ],
    ]

    if (metaLabel) {
      headerChildren.push([
        'span',
        {
          'data-collapsible-meta': '',
          style: 'margin-left:12px;font-size:12px;color:#708090;letter-spacing:0.01em;white-space:nowrap;flex-shrink:0;',
        },
        metaLabel,
      ])
    }

    const actionStrip = [
      'span',
      {
        'data-collapsible-actions': '',
        style: 'display:none;align-items:center;gap:6px;margin-left:12px;',
      },
      [
        'button',
        {
          type: 'button',
          'data-action': 'move-up',
          'aria-label': 'Move block up',
          style: 'border:none;background:none;padding:0;cursor:pointer;color:#708090;font-size:14px;',
        },
        '▲',
      ],
      [
        'button',
        {
          type: 'button',
          'data-action': 'move-down',
          'aria-label': 'Move block down',
          style: 'border:none;background:none;padding:0;cursor:pointer;color:#708090;font-size:14px;',
        },
        '▼',
      ],
      [
        'button',
        {
          type: 'button',
          'data-action': 'duplicate',
          'aria-label': 'Duplicate block',
          style: 'border:none;background:none;padding:0;cursor:pointer;color:#708090;font-size:14px;',
        },
        '⧉',
      ],
      [
        'button',
        {
          type: 'button',
          'data-action': 'delete',
          'aria-label': 'Delete block',
          style: 'border:none;background:none;padding:0;cursor:pointer;color:#cc4a4a;font-size:14px;',
        },
        '🗑',
      ],
    ]

    return [
      'div',
      attributes,
      [
        'div',
        {
          'data-collapsible-header': '',
          style: 'display:flex;align-items:center;gap:8px;padding:2px 0;position:relative;min-width:0;',
        },
        ...headerChildren,
        actionStrip,
      ],
      [
        'div',
        {
          'data-collapsible-content': '',
          style: 'padding-left:20px;margin-top:8px;',
        },
        0,
      ],
    ]
  },

  addNodeView() {
    return ReactNodeViewRenderer(CollapsibleBlockComponent)
  },

  addCommands() {
    return {
      insertCollapsibleBlock: () => ({ commands }) => {
        const template = getTemplateById(DEFAULT_TEMPLATE_ID)
        const content = template?.buildContent() ?? [
          {
            type: 'paragraph',
            content: [{ type: 'text', text: '' }],
          },
        ]

        return commands.insertContent({
          type: 'collapsibleBlock',
          attrs: {
            collapsed: false,
            title: 'Section Title',
            templateId: null,
          },
          content,
        })
      },
    }
  },
})

// React component for the collapsible block
function CollapsibleBlockFull({ node, updateAttributes, editor, getPos }: any) {
  const [isCollapsed, setIsCollapsed] = useState(node.attrs.collapsed)
  const [title, setTitle] = useState(getDisplayTitle(node.attrs.title))
  const [isEditingTitle, setIsEditingTitle] = useState(false)
  const [isHovered, setIsHovered] = useState(false)
  const [showTooltip, setShowTooltip] = useState(false)
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 })
  const [showPreviewIcon, setShowPreviewIcon] = useState(false)
  const iconRef = useRef<HTMLDivElement | null>(null)
  const contentRef = useRef<HTMLDivElement | null>(null)
  const wrapperRef = useRef<HTMLDivElement | null>(null)
  const [cachedHtmlContent, setCachedHtmlContent] = useState<string>('')
  const [isTooltipHovered, setIsTooltipHovered] = useState(false)
  const [showActions, setShowActions] = useState(false)
  const tooltipTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const tooltipElementRef = useRef<HTMLDivElement | null>(null)
  const inspectorRef = useRef<HTMLDivElement | null>(null)
  const [showInspector, setShowInspector] = useState(false)
  const [inspectorPosition, setInspectorPosition] = useState({ top: 120, left: 120 })
  const [isDraggingInspector, setIsDraggingInspector] = useState(false)
  const dragOffsetRef = useRef<{ x: number; y: number } | null>(null)
  const [isTemplateMenuOpen, setIsTemplateMenuOpen] = useState(false)
  const [templateMenuPosition, setTemplateMenuPosition] = useState({ top: 0, left: 0 })
  const templateButtonRef = useRef<HTMLButtonElement | null>(null)
  const templateMenuRef = useRef<HTMLDivElement | null>(null)
  const templateEditorSuppressRef = useRef(false)
  const [isTemplateMenuDragging, setIsTemplateMenuDragging] = useState(false)
  const templateMenuDragOffsetRef = useRef<{ x: number; y: number } | null>(null)
  const [templateUndoSnapshot, setTemplateUndoSnapshot] = useState<TemplateSnapshot | null>(null)
  const defaultTemplate = getTemplateById(DEFAULT_TEMPLATE_ID)!
  const storedTemplate = getTemplateById(node.attrs.templateId)
  const appliedTemplate = storedTemplate ?? defaultTemplate
  const hasExplicitTemplate = Boolean(node.attrs.templateId)
  const templateButtonLabel = hasExplicitTemplate ? 'Change template' : 'Insert template'
  const [hoveredTemplateId, setHoveredTemplateId] = useState<string | null>(null)
  const [draftTemplateId, setDraftTemplateId] = useState<string>(appliedTemplate.id)
  const draftTemplate = getTemplateById(draftTemplateId) ?? defaultTemplate
  const [isDraftDirty, setIsDraftDirty] = useState(false)
  const stats = computeBlockStats(node)
  const metaBase = formatBlockMeta(stats)
  const headerMetaLabel = metaBase

  const templatePreviewEditor = useEditor(
    {
      extensions: createTemplatePreviewExtensions(),
      editable: true,
      content: buildTemplateDoc(appliedTemplate),
      editorProps: {
        attributes: {
          class: 'template-preview-editor',
          style:
            'min-height:180px;border:1px solid #e2e8f0;border-radius:8px;padding:12px;font-size:13px;line-height:1.55;overflow:auto;background-color:#ffffff;',
        },
      },
    },
    []
  )

  const setTemplateEditorContent = useCallback(
    (doc: JSONNode, dirty = false) => {
      if (!templatePreviewEditor) {
        setIsDraftDirty(dirty)
        return
      }

      try {
        templateEditorSuppressRef.current = true
        templatePreviewEditor.commands.setContent(doc, false)
        templatePreviewEditor.setEditable(true)
        setIsDraftDirty(dirty)
      } catch (error) {
        console.error('Failed to load template preview', error)
      } finally {
        const release = () => {
          templateEditorSuppressRef.current = false
        }

        if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
          window.requestAnimationFrame(release)
        } else {
          setTimeout(release, 0)
        }
      }
    },
    [templatePreviewEditor]
  )

  useEffect(() => {
    if (!templatePreviewEditor) {
      return
    }

    const handleUpdate = () => {
      if (templateEditorSuppressRef.current) {
        return
      }
      setIsDraftDirty(true)
    }

    templatePreviewEditor.on('update', handleUpdate)

    return () => {
      templatePreviewEditor.off('update', handleUpdate)
    }
  }, [templatePreviewEditor])

  useEffect(() => {
    if (!isTemplateMenuDragging) {
      return
    }

    const handleMouseMove = (event: MouseEvent) => {
      if (!templateMenuDragOffsetRef.current || !templateMenuRef.current) {
        return
      }
      event.preventDefault()

      const { x, y } = templateMenuDragOffsetRef.current
      const menuRect = templateMenuRef.current.getBoundingClientRect()
      const menuWidth = menuRect.width
      const menuHeight = menuRect.height

      const nextLeftRaw = event.clientX - x
      const nextTopRaw = event.clientY - y

      const maxLeft = Math.max(16, window.innerWidth - menuWidth - 16)
      const maxTop = Math.max(16, window.innerHeight - menuHeight - 16)

      const nextLeft = Math.min(Math.max(16, nextLeftRaw), maxLeft)
      const nextTop = Math.min(Math.max(16, nextTopRaw), maxTop)

      setTemplateMenuPosition({ top: nextTop, left: nextLeft })
    }

    const handleMouseUp = () => {
      setIsTemplateMenuDragging(false)
      templateMenuDragOffsetRef.current = null
    }

    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)

    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isTemplateMenuDragging])

  useEffect(() => {
    if (!templatePreviewEditor || !isTemplateMenuOpen) {
      return
    }

    setTemplateEditorContent(buildTemplateDoc(draftTemplate), false)
  }, [templatePreviewEditor, draftTemplateId, draftTemplate, isTemplateMenuOpen, setTemplateEditorContent])

  useEffect(() => {
    if (isTemplateMenuOpen) {
      return
    }

    setDraftTemplateId(prev => (prev === appliedTemplate.id ? prev : appliedTemplate.id))
    setIsDraftDirty(false)
  }, [isTemplateMenuOpen, appliedTemplate.id])

  const resolvePos = () => (typeof getPos === 'function' ? getPos() : null)

  useEffect(() => {
    if (!node.attrs.title || !node.attrs.title.trim()) {
      updateAttributes({ title: DEFAULT_BLOCK_TITLE })
    }
  }, [node.attrs.title, updateAttributes])

  useEffect(() => {
    debugLog('CollapsibleBlock', 'TITLE_ATTR_EFFECT', {
      metadata: {
        attrTitle: node.attrs.title,
      },
    })
    setTitle(getDisplayTitle(node.attrs.title))
  }, [node.attrs.title])

  useEffect(() => {
    if (!showInspector || typeof window === 'undefined') return

    const onKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setShowInspector(false)
      }
    }

    const onMouseMove = (event: MouseEvent) => {
      if (!isDraggingInspector || !dragOffsetRef.current) return
      event.preventDefault()
      const { x, y } = dragOffsetRef.current
      const nextLeft = event.clientX - x
      const nextTop = event.clientY - y
      const maxLeft = window.innerWidth - 380
      const maxTop = window.innerHeight - 200
      setInspectorPosition({
        left: Math.min(Math.max(16, nextLeft), maxLeft),
        top: Math.min(Math.max(16, nextTop), maxTop),
      })
    }

    const onMouseUp = () => {
      if (!isDraggingInspector) return
      setIsDraggingInspector(false)
      dragOffsetRef.current = null
    }

    window.addEventListener('keydown', onKeyDown)
    window.addEventListener('mousemove', onMouseMove)
    window.addEventListener('mouseup', onMouseUp)

    return () => {
      window.removeEventListener('keydown', onKeyDown)
      window.removeEventListener('mousemove', onMouseMove)
      window.removeEventListener('mouseup', onMouseUp)
    }
  }, [showInspector, isDraggingInspector])

  useEffect(() => {
    if (!isTemplateMenuOpen) {
      return
    }

    const handleMouseDown = (event: MouseEvent) => {
      const target = event.target as Node
      if (
        templateMenuRef.current &&
        !templateMenuRef.current.contains(target) &&
        !templateButtonRef.current?.contains(target)
      ) {
        setIsTemplateMenuOpen(false)
        setHoveredTemplateId(null)
      }
    }

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setIsTemplateMenuOpen(false)
        setHoveredTemplateId(null)
      }
    }

    document.addEventListener('mousedown', handleMouseDown)
    document.addEventListener('keydown', handleKeyDown)

    return () => {
      document.removeEventListener('mousedown', handleMouseDown)
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [isTemplateMenuOpen])

  const handleDuplicate = () => {
    const pos = resolvePos()
    if (pos == null) return
    const clone = node.copy(node.content)
    const tr = editor.view.state.tr.insert(pos + node.nodeSize, clone)
    editor.view.dispatch(tr)
    editor.view.focus()
  }

  const handleDelete = () => {
    const pos = resolvePos()
    if (pos == null) return
    const confirmed = window.confirm('Delete this block and all nested content?')
    if (!confirmed) {
      return
    }
    const tr = editor.view.state.tr.delete(pos, pos + node.nodeSize)
    editor.view.dispatch(tr)
    editor.view.focus()
    setShowInspector(false)
  }

  const handleMove = (direction: 'up' | 'down') => {
    const pos = resolvePos()
    if (pos == null) return

    const { state } = editor.view
    const $pos = state.doc.resolve(pos)
    const parent = $pos.parent
    const index = $pos.index()
    if (!parent) return

    const targetIndex = direction === 'up' ? index - 1 : index + 1
    if (targetIndex < 0 || targetIndex >= parent.childCount) {
      return
    }

    const sibling = parent.child(targetIndex)
    const tr = state.tr
    const from = pos
    const to = pos + node.nodeSize
    tr.delete(from, to)

    const mappedSiblingPos = direction === 'up'
      ? tr.mapping.map(pos - sibling.nodeSize)
      : tr.mapping.map(pos)

    const insertPos = direction === 'up'
      ? mappedSiblingPos
      : mappedSiblingPos + sibling.nodeSize

    tr.insert(insertPos, node.copy(node.content))
    editor.view.dispatch(tr)
    editor.view.focus()
  }

  const closeTemplateMenu = () => {
    setIsTemplateMenuOpen(false)
    setHoveredTemplateId(null)
    setIsTemplateMenuDragging(false)
    templateMenuDragOffsetRef.current = null
  }

  const handleTemplateButtonClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    event.preventDefault()
    event.stopPropagation()

    if (!isTemplateMenuOpen) {
      if (templateButtonRef.current && typeof window !== 'undefined') {
        const rect = templateButtonRef.current.getBoundingClientRect()
        const menuWidth = 320
        const maxLeft = Math.max(16, window.innerWidth - menuWidth - 16)
        const left = Math.min(Math.max(16, rect.left), maxLeft)
        const top = rect.bottom + 8
        setTemplateMenuPosition({ top, left })
      } else {
        setTemplateMenuPosition({ top: 120, left: 120 })
      }
      setHoveredTemplateId(null)
      setDraftTemplateId(appliedTemplate.id)
      setTemplateEditorContent(buildTemplateDoc(appliedTemplate), false)
      setIsTemplateMenuOpen(true)
      return
    }

    closeTemplateMenu()
  }

  const handleTemplateSelection = (template: CollapsibleTemplate) => {
    setDraftTemplateId(template.id)
    setHoveredTemplateId(null)
    setTemplateEditorContent(buildTemplateDoc(template), false)
    setIsDraftDirty(false)
  }

  const handleTemplateMenuDragStart = (event: React.MouseEvent<HTMLDivElement>) => {
    if (event.button !== 0) {
      return
    }
    if (!templateMenuRef.current) {
      return
    }

    event.preventDefault()
    event.stopPropagation()
    const rect = templateMenuRef.current.getBoundingClientRect()
    templateMenuDragOffsetRef.current = {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top,
    }
    setIsTemplateMenuDragging(true)
  }

  const handleResetTemplatePreview = () => {
    setTemplateEditorContent(buildTemplateDoc(draftTemplate), false)
  }

  const applyTemplateToBlock = (template: CollapsibleTemplate, docJSON?: JSONNode | null) => {
    const pos = resolvePos()
    if (pos == null) {
      return
    }

    const view = editor?.view
    if (!view) {
      return
    }

    try {
      const { state, dispatch } = view
      const { schema } = state
      const blockType = schema.nodes.collapsibleBlock
      if (!blockType) {
        return
      }

      debugLog('CollapsibleBlock', 'APPLY_TEMPLATE_START', {
        metadata: {
          templateId: template.id,
          stateTitle: title,
          nodeTitle: node.attrs.title,
          hasDocJSON: Boolean(docJSON),
        },
      })

      setTemplateUndoSnapshot(current => {
        if (current) {
          return current
        }
        return { nodeJSON: node.toJSON() }
      })

      const templateDoc = docJSON ?? buildTemplateDoc(template)
      const rawContent = Array.isArray((templateDoc as any)?.content)
        ? (templateDoc as any).content
        : []
      const contentNodes = rawContent.map((spec: any) => schema.nodeFromJSON(spec))
      const existingTitle = node.attrs.title
      const nextAttrs: Record<string, any> = {
        ...node.attrs,
        collapsed: false,
        templateId: template.id,
        title: existingTitle,
      }

      const newBlock = blockType.create(nextAttrs, contentNodes)
      if (!newBlock) {
        return
      }

       debugLog('CollapsibleBlock', 'APPLY_TEMPLATE_NODE', {
        metadata: {
          existingTitle,
          nextAttrs,
        },
      })

      const tr = state.tr.replaceWith(pos, pos + node.nodeSize, newBlock)
      dispatch(tr)

      debugLog('CollapsibleBlock', 'APPLY_TEMPLATE_DISPATCHED', {
        metadata: {
          titleAfterDispatch: existingTitle,
        },
      })
      view.focus()
      updateAttributes({ title: existingTitle })
      setIsCollapsed(false)
      setIsEditingTitle(false)
      setTitle(getDisplayTitle(existingTitle))
      setCachedHtmlContent('')
      setIsDraftDirty(false)
      closeTemplateMenu()
    } catch (error) {
      console.error('Failed to apply template', error)
    }
  }

  const handleApplyDraftTemplate = () => {
    const templateToApply = draftTemplate
    const editorDoc = templatePreviewEditor?.getJSON?.() ?? null
    applyTemplateToBlock(templateToApply, editorDoc)
  }

  const handleCancelTemplateSelection = () => {
    closeTemplateMenu()
    setTemplateEditorContent(buildTemplateDoc(appliedTemplate), false)
  }

  const handleUndoTemplate = () => {
    if (!templateUndoSnapshot) {
      return
    }

    const pos = resolvePos()
    if (pos == null) {
      return
    }

    const view = editor?.view
    if (!view) {
      return
    }

    const snapshot = templateUndoSnapshot

    try {
      const { state, dispatch } = view
      const restoredBlock = state.schema.nodeFromJSON(snapshot.nodeJSON as any)
      if (!restoredBlock) {
        return
      }

      const tr = state.tr.replaceWith(pos, pos + node.nodeSize, restoredBlock)
      dispatch(tr)
      view.focus()

      const snapshotAttrs = (snapshot.nodeJSON as any)?.attrs ?? {}
      const restoredCollapsed = Boolean(snapshotAttrs.collapsed)
      const restoredTitle = getDisplayTitle(snapshotAttrs.title)
      setIsCollapsed(restoredCollapsed)
      setTitle(restoredTitle)
      setIsEditingTitle(false)
      setCachedHtmlContent('')
      setTemplateUndoSnapshot(null)
      closeTemplateMenu()
    } catch (error) {
      console.error('Failed to restore template snapshot', error)
    }
  }

  const handleInspectorMouseDown = (event: React.MouseEvent<HTMLDivElement>) => {
    if (event.button !== 0) return
    event.preventDefault()
    event.stopPropagation()
    setIsDraggingInspector(true)
    dragOffsetRef.current = {
      x: event.clientX - inspectorPosition.left,
      y: event.clientY - inspectorPosition.top,
    }
  }

  const handleOpenInspector = (event: React.MouseEvent) => {
    event.stopPropagation()
    if (wrapperRef.current && typeof window !== 'undefined') {
      const rect = wrapperRef.current.getBoundingClientRect()
      const left = Math.min(Math.max(16, rect.right + 16), window.innerWidth - 380)
      const top = Math.min(Math.max(16, rect.top), window.innerHeight - 200)
      setInspectorPosition({ top, left })
    }
    setShowInspector(true)
  }

  const handleCloseInspector = () => {
    setShowInspector(false)
    setIsDraggingInspector(false)
    dragOffsetRef.current = null
  }

  const toggleCollapse = () => {
    const newCollapsed = !isCollapsed
    
    // Cache content before collapsing
    if (!newCollapsed && contentRef.current) {
      const html = contentRef.current.innerHTML || ''
      setCachedHtmlContent(html)
    }
    
    setIsCollapsed(newCollapsed)
    updateAttributes({ collapsed: newCollapsed })
  }
  
  // Update cached content when expanded
  useEffect(() => {
    if (!isCollapsed && contentRef.current) {
      const html = contentRef.current.innerHTML || ''
      setCachedHtmlContent(html)
    }
  }, [isCollapsed])

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value)
  }

  const handleTitleBlur = () => {
    const trimmed = title.trim()
    const nextTitle = trimmed || DEFAULT_BLOCK_TITLE
    setTitle(nextTitle)
    setIsEditingTitle(false)
    updateAttributes({ title: nextTitle })
  }

  const handleTitleFocus = () => {
    setTimeout(() => {
      const input = document.activeElement as HTMLInputElement | null
      if (input && (input.value === DEFAULT_BLOCK_TITLE || !input.value.trim())) {
        input.select()
      }
    }, 0)
  }

  const handleTitleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleTitleBlur()
    }
  }

  // Extract HTML content for tooltip display
  const getHtmlContent = () => {
    // First check if we have cached HTML
    if (cachedHtmlContent) {
      return cachedHtmlContent
    }
    
    // If not cached but content is expanded, get it from DOM
    if (!isCollapsed && contentRef.current) {
      const html = contentRef.current.innerHTML || ''
      setCachedHtmlContent(html) // Cache it for later
      return html
    }
    
    try {
      if (typeof window === 'undefined') {
        return ''
      }

      const schema = editor?.view?.state.schema || editor?.schema
      if (!schema) {
        return ''
      }

      const serializer = DOMSerializer.fromSchema(schema)
      const container = document.createElement('div')
      const docType = schema.topNodeType
      const docNode = docType?.create(null, node)
      if (!docNode) {
        return ''
      }

      const fragment = serializer.serializeFragment(docNode.content, { document })
      container.appendChild(fragment)
      const html = container.innerHTML
      if (html) {
        setCachedHtmlContent(html) // Cache for future use
        return html
      }
    } catch (error) {
      console.error('Error rendering node to HTML:', error)
    }
    
    return '<p style="color: #999; font-style: italic;">No content preview available</p>'
  }

  const scheduleTooltipHide = (relatedTarget?: EventTarget | null) => {
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current)
      tooltipTimeoutRef.current = null
    }

    const movingTowardTooltip = relatedTarget instanceof HTMLElement && relatedTarget.closest?.('.annotation-tooltip')

    tooltipTimeoutRef.current = setTimeout(() => {
      const tooltipHovered = tooltipElementRef.current?.matches(':hover') || false
      if (!tooltipHovered && !movingTowardTooltip) {
        setShowTooltip(false)
      }
    }, 500) // Allow extra time to move between icon and tooltip
  }

  const handleHeaderClick = (e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.target as HTMLElement
    if (target.closest('[data-collapsible-arrow]')) {
      return
    }
    if (target.closest('[data-collapsible-actions]')) {
      return
    }
    if (target.closest('[data-preview-icon]')) {
      return
    }

    e.preventDefault()
    e.stopPropagation()
    setIsEditingTitle(true)
  }

  // Handle container hover
  const handleMouseEnter = () => {
    setIsHovered(true)
    setShowActions(true)
    if (isCollapsed) {
      setShowPreviewIcon(true)
    }
  }

  // Handle container mouse leave
  const handleMouseLeave = (e: React.MouseEvent) => {
    setIsHovered(false)
    setShowPreviewIcon(false)
    scheduleTooltipHide(e.relatedTarget)
    setShowActions(false)
  }

  // Handle icon hover
  const handleIconMouseEnter = (e: React.MouseEvent) => {
    e.stopPropagation()
    const rect = iconRef.current?.getBoundingClientRect()
    console.log('Icon hover - rect:', rect) // Debug log
    if (rect) {
      if (tooltipTimeoutRef.current) {
        clearTimeout(tooltipTimeoutRef.current)
        tooltipTimeoutRef.current = null
      }
      setTooltipPosition({
        x: rect.left + rect.width / 2,
        y: rect.bottom + 8
      })
      setShowTooltip(true)
      console.log('Tooltip should show at:', { x: rect.left + rect.width / 2, y: rect.bottom + 8 }) // Debug log
    }
  }

  // Handle icon mouse leave - add delay to allow moving to tooltip
  const handleIconMouseLeave = (e: React.MouseEvent) => {
    e.stopPropagation()
    
    // Set a timeout to hide tooltip, giving user time to move to it
    scheduleTooltipHide(e.relatedTarget)
  }

  // Handle tooltip mouse enter
  const handleTooltipMouseEnter = () => {
    setIsTooltipHovered(true)
    // Clear any pending hide timeout
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current)
      tooltipTimeoutRef.current = null
    }
  }
  
  // Handle tooltip mouse leave
  const handleTooltipMouseLeave = (e: React.MouseEvent) => {
    console.log('Tooltip mouse leave - scheduling hide') // Debug log
    setIsTooltipHovered(false)
    scheduleTooltipHide(e.relatedTarget)
  }
  
  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (tooltipTimeoutRef.current) {
        clearTimeout(tooltipTimeoutRef.current)
      }
    }
  }, [])

  return (
    <>
    <NodeViewWrapper 
      ref={wrapperRef}
      className="collapsible-block"
      style={{
        borderLeft: isCollapsed ? 'none' : `3px solid ${isHovered ? '#9b59b6' : '#e1e8ed'}`,
        borderRadius: '0',
        padding: isCollapsed ? '0' : '0 0 0 12px',
        margin: isCollapsed ? '2px 0' : '6px 0',
        background: isCollapsed 
          ? (isHovered ? 'rgba(248, 249, 250, 0.3)' : 'transparent')
          : 'transparent',
        transition: 'all 0.2s ease',
        position: 'relative',
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <div 
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          marginBottom: isCollapsed ? '0' : '4px',
          cursor: 'pointer',
          userSelect: 'none',
          padding: '4px 0',
          minWidth: 0,
        }}
        contentEditable={false}
        onMouseEnter={() => setShowActions(true)}
        onMouseLeave={() => setShowActions(false)}
        onClick={handleHeaderClick}
      >
        <span 
          onClick={toggleCollapse}
          data-collapsible-arrow
          style={{
            fontSize: '16px',
            marginRight: '8px',
            transition: 'transform 0.2s ease',
            transform: isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)',
            display: 'inline-block',
          }}
        >
          ▼
        </span>
        {isEditingTitle ? (
          <input
            type="text"
            value={title}
            onChange={handleTitleChange}
            onBlur={handleTitleBlur}
            onKeyDown={handleTitleKeyDown}
            autoFocus
            placeholder={DEFAULT_BLOCK_TITLE}
            onFocus={handleTitleFocus}
            style={{
              fontSize: '16px',
              fontWeight: '600',
              border: '1px solid #667eea',
              borderRadius: '4px',
              padding: '2px 6px',
              outline: 'none',
              background: 'white',
              width: '100%',
            }}
          />
        ) : (
          <span 
            onClick={(e) => {
              e.stopPropagation()
              setIsEditingTitle(true)
            }}
            style={{
              fontSize: '16px',
              fontWeight: '600',
              cursor: 'text',
              flex: '1 1 auto',
              minWidth: 0,
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
            }}
          >
            {title}
          </span>
        )}

        {headerMetaLabel && !showActions && (
          <span
            style={{
              flexShrink: 0,
              marginLeft: '12px',
              fontSize: '12px',
              color: '#708090',
              letterSpacing: '0.01em',
              whiteSpace: 'nowrap',
            }}
          >
            {headerMetaLabel}
          </span>
        )}
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '8px',
            marginLeft: 'auto',
            flexShrink: 0,
          }}
        >
          {hasExplicitTemplate && appliedTemplate && (
            <span
              style={{
                fontSize: '12px',
                color: '#64748b',
                whiteSpace: 'nowrap',
              }}
            >
              {appliedTemplate.label}
            </span>
          )}
          {templateUndoSnapshot && (
            <button
              type="button"
              onClick={(event) => {
                event.preventDefault()
                event.stopPropagation()
                handleUndoTemplate()
              }}
              style={{
                border: '1px solid #f1c4c4',
                background: 'rgba(252, 231, 243, 0.65)',
                color: '#b91c1c',
                padding: '2px 10px',
                borderRadius: '9999px',
                cursor: 'pointer',
                fontSize: '12px',
                fontWeight: 600,
                lineHeight: 1.4,
                whiteSpace: 'nowrap',
              }}
            >
              Undo template
            </button>
          )}
          <button
            type="button"
            ref={templateButtonRef}
            onClick={handleTemplateButtonClick}
            aria-label={templateButtonLabel}
            title={templateButtonLabel}
            style={{
              border: '1px solid #d5dfe9',
              background: isTemplateMenuOpen ? 'rgba(99, 102, 241, 0.16)' : 'rgba(241, 245, 249, 0.9)',
              color: '#475569',
              padding: 0,
              width: '28px',
              height: '28px',
              borderRadius: '9999px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              transition: 'background 0.15s ease',
            }}
          >
            <span
              aria-hidden="true"
              style={{
                display: 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: '16px',
                height: '16px',
              }}
            >
              <svg
                width="14"
                height="14"
                viewBox="0 0 14 14"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <rect x="1.5" y="2" width="11" height="2" rx="1" fill="currentColor" />
                <rect x="1.5" y="6" width="11" height="2" rx="1" fill="currentColor" />
                <rect x="1.5" y="10" width="7" height="2" rx="1" fill="currentColor" />
              </svg>
            </span>
          </button>
          <div
            style={{
              display: showActions ? 'inline-flex' : 'none',
              alignItems: 'center',
              gap: '6px',
            }}
            data-collapsible-actions
          >
            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation()
                handleMove('up')
              }}
              style={{
                border: 'none',
                background: 'none',
                padding: 0,
                cursor: 'pointer',
                color: '#708090',
                fontSize: '14px',
              }}
              aria-label="Move block up"
            >
              ▲
            </button>
            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation()
                handleMove('down')
              }}
              style={{
                border: 'none',
                background: 'none',
                padding: 0,
                cursor: 'pointer',
                color: '#708090',
                fontSize: '14px',
              }}
              aria-label="Move block down"
            >
              ▼
            </button>
            <button
              type="button"
              onClick={(e) => {
                handleOpenInspector(e)
              }}
              style={{
                border: 'none',
                background: 'none',
                padding: 0,
                cursor: 'pointer',
                color: '#708090',
                fontSize: '14px',
              }}
              aria-label="Open block inspector"
            >
              🗔
            </button>
            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation()
                handleDuplicate()
              }}
              style={{
                border: 'none',
                background: 'none',
                padding: 0,
                cursor: 'pointer',
                color: '#708090',
                fontSize: '14px',
              }}
              aria-label="Duplicate block"
            >
              ⧉
            </button>
            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation()
                handleDelete()
              }}
              style={{
                border: 'none',
                background: 'none',
                padding: 0,
                cursor: 'pointer',
                color: '#cc4a4a',
                fontSize: '14px',
              }}
              aria-label="Delete block"
            >
              🗑
            </button>
          </div>
        </div>

        {/* Preview Icon - shows when collapsed and hovered */}
        {isCollapsed && showPreviewIcon && (
          <div
            ref={iconRef}
            onMouseEnter={handleIconMouseEnter}
            onMouseLeave={handleIconMouseLeave}
            style={{
              marginLeft: '8px',
              cursor: 'help',
              display: 'inline-flex',
              alignItems: 'center',
              justifyContent: 'center',
              width: '20px',
              height: '20px',
              borderRadius: '4px',
              background: 'rgba(155, 89, 182, 0.1)',
              transition: 'all 0.2s ease',
            }}
            data-preview-icon
            onMouseOver={(e) => {
              e.currentTarget.style.background = 'rgba(155, 89, 182, 0.2)'
              e.currentTarget.style.transform = 'scale(1.1)'
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = 'rgba(155, 89, 182, 0.1)'
              e.currentTarget.style.transform = 'scale(1)'
            }}
          >
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#9b59b6" strokeWidth="2">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 16v-4"/>
              <path d="M12 8h.01"/>
            </svg>
          </div>
        )}
      </div>

      {isTemplateMenuOpen && typeof document !== 'undefined' && createPortal(
        <div
          ref={templateMenuRef}
          style={{
            position: 'fixed',
            top: templateMenuPosition.top,
            left: templateMenuPosition.left,
            width: '360px',
            maxWidth: 'calc(100vw - 32px)',
            background: '#ffffff',
            border: '1px solid #d6e0f0',
            borderRadius: '10px',
            boxShadow: '0 18px 36px rgba(15, 23, 42, 0.16)',
            zIndex: 9999,
          }}
        >
          <div
            style={{
              padding: '12px 16px',
              borderBottom: '1px solid #e2e8f0',
              fontSize: '11px',
              fontWeight: 700,
              letterSpacing: '0.08em',
              textTransform: 'uppercase',
              color: '#475569',
              cursor: isTemplateMenuDragging ? 'grabbing' : 'grab',
              userSelect: 'none',
            }}
            onMouseDown={handleTemplateMenuDragStart}
          >
            Choose template
          </div>
          <div
            style={{
              display: 'flex',
              gap: '12px',
              padding: '12px 16px 16px 16px',
            }}
          >
            <div
              style={{
                flex: 1,
                display: 'flex',
                flexDirection: 'column',
                gap: '6px',
              }}
            >
              {COLLAPSIBLE_TEMPLATES.map(template => {
                const isEditing = template.id === draftTemplateId
                const isCurrent = template.id === appliedTemplate.id
                const isHovered = hoveredTemplateId === template.id

                return (
                  <button
                    key={template.id}
                    type="button"
                    onClick={(event) => {
                      event.preventDefault()
                      event.stopPropagation()
                      handleTemplateSelection(template)
                    }}
                    onMouseEnter={() => setHoveredTemplateId(template.id)}
                    onMouseLeave={() => setHoveredTemplateId(null)}
                    onFocus={() => setHoveredTemplateId(template.id)}
                    onBlur={() => setHoveredTemplateId(null)}
                    style={{
                      textAlign: 'left',
                      border: 'none',
                      background: isEditing
                        ? 'rgba(99, 102, 241, 0.18)'
                        : isHovered
                          ? 'rgba(99, 102, 241, 0.08)'
                          : 'transparent',
                      padding: '8px 10px',
                      borderRadius: '8px',
                      cursor: 'pointer',
                    }}
                  >
                    <div
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: '8px',
                      }}
                    >
                      <span
                        style={{
                          fontSize: '13px',
                          fontWeight: 600,
                          color: '#1f2937',
                        }}
                      >
                        {template.label}
                      </span>
                      {template.id === DEFAULT_TEMPLATE_ID && !hasExplicitTemplate && !isEditing && !isCurrent && (
                        <span
                          style={{
                            fontSize: '11px',
                            color: '#64748b',
                          }}
                        >
                          Default
                        </span>
                      )}
                      {isEditing && (
                        <span
                          style={{
                            fontSize: '11px',
                            color: '#1d4ed8',
                            fontWeight: 600,
                          }}
                        >
                          Editing
                        </span>
                      )}
                      {!isEditing && isCurrent && (
                        <span
                          style={{
                            fontSize: '11px',
                            color: '#6366f1',
                            fontWeight: 600,
                          }}
                        >
                          Current
                        </span>
                      )}
                    </div>
                    <span
                      style={{
                        display: 'block',
                        marginTop: '2px',
                        fontSize: '12px',
                        color: '#64748b',
                      }}
                    >
                      {template.description}
                    </span>
                  </button>
                )
              })}
            </div>
            <div
              style={{
                width: '240px',
                borderLeft: '1px solid #e2e8f0',
                paddingLeft: '12px',
                display: 'flex',
                flexDirection: 'column',
                gap: '10px',
              }}
            >
              <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                <span
                  style={{
                    fontSize: '12px',
                    fontWeight: 700,
                    color: '#1f2937',
                    textTransform: 'uppercase',
                    letterSpacing: '0.06em',
                  }}
                >
                  Preview & edit
                </span>
                <span
                  style={{
                    fontSize: '11px',
                    color: '#64748b',
                  }}
                >
                  {draftTemplate.description}
                </span>
              </div>
              <div style={{ flex: '1 1 auto', display: 'flex', flexDirection: 'column', gap: '6px' }}>
                {templatePreviewEditor ? (
                  <div
                    onMouseDown={(event) => {
                      event.stopPropagation()
                      templatePreviewEditor.commands.focus()
                    }}
                    onClick={(event) => event.stopPropagation()}
                  >
                    <EditorContent editor={templatePreviewEditor} />
                  </div>
                ) : (
                  <div
                    style={{
                      border: '1px dashed #cbd5f5',
                      borderRadius: '8px',
                      padding: '16px',
                      fontSize: '12px',
                      color: '#64748b',
                    }}
                  >
                    Loading template editor…
                  </div>
                )}
              </div>
              <div
                style={{
                  fontSize: '11px',
                  color: '#64748b',
                }}
              >
                Changes appear in the block only after you press Apply.
              </div>
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'flex-end',
                  gap: '8px',
                  marginTop: '4px',
                }}
              >
                <button
                  type="button"
                  onClick={(event) => {
                    event.preventDefault()
                    event.stopPropagation()
                    handleResetTemplatePreview()
                  }}
                  disabled={!isDraftDirty}
                  style={{
                    border: '1px solid rgba(99, 102, 241, 0.25)',
                    background: 'transparent',
                    color: isDraftDirty ? '#4c51bf' : '#94a3b8',
                    padding: '4px 12px',
                    borderRadius: '8px',
                    cursor: isDraftDirty ? 'pointer' : 'not-allowed',
                    fontSize: '12px',
                    fontWeight: 600,
                    transition: 'all 0.15s ease',
                  }}
                >
                  Reset
                </button>
                <button
                  type="button"
                  onClick={(event) => {
                    event.preventDefault()
                    event.stopPropagation()
                    handleCancelTemplateSelection()
                  }}
                  style={{
                    border: '1px solid #e2e8f0',
                    background: 'rgba(248, 250, 252, 0.8)',
                    color: '#475569',
                    padding: '4px 12px',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: 600,
                  }}
                >
                  Cancel
                </button>
                <button
                  type="button"
                  onClick={(event) => {
                    event.preventDefault()
                    event.stopPropagation()
                    handleApplyDraftTemplate()
                  }}
                  style={{
                    border: 'none',
                    background: 'linear-gradient(135deg, #6366f1, #8b5cf6)',
                    color: '#ffffff',
                    padding: '4px 14px',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: 700,
                    boxShadow: '0 8px 16px rgba(99, 102, 241, 0.25)',
                  }}
                >
                  Apply
                </button>
              </div>
            </div>
          </div>
          {templateUndoSnapshot && (
            <div
              style={{
                borderTop: '1px solid #e2e8f0',
                padding: '12px 16px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: '12px',
                background: 'rgba(248, 250, 252, 0.85)',
              }}
            >
              <span
                style={{
                  fontSize: '12px',
                  color: '#475569',
                  flex: '1 1 auto',
                }}
              >
                Reverts to your original block content.
              </span>
              <button
                type="button"
                onClick={(event) => {
                  event.preventDefault()
                  event.stopPropagation()
                  handleUndoTemplate()
                }}
                style={{
                  border: '1px solid #f1c4c4',
                  background: 'rgba(252, 231, 243, 0.85)',
                  color: '#b91c1c',
                  padding: '4px 12px',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  fontSize: '12px',
                  fontWeight: 600,
                  whiteSpace: 'nowrap',
                }}
              >
                Undo template swap
              </button>
            </div>
          )}
        </div>,
        document.body
      )}

      {!isCollapsed && (
        <div 
          ref={contentRef}
          style={{
            paddingLeft: '20px',
            marginTop: '4px',
          }}
        >
          <NodeViewContent className="content" />
        </div>
      )}
    </NodeViewWrapper>
    
    {/* Tooltip - render with Portal to ensure it appears above everything */}
    {showTooltip && isCollapsed && typeof window !== 'undefined' && createPortal(
      <div
        ref={tooltipElementRef}
        className="annotation-tooltip visible"
        onMouseEnter={handleTooltipMouseEnter}
        onMouseLeave={handleTooltipMouseLeave}
        style={{
          position: 'fixed',
          left: `${tooltipPosition.x}px`,
          top: `${tooltipPosition.y}px`,
          transform: 'translateX(-50%)',
          background: 'white',
          border: '1px solid #e1e8ed',
          borderRadius: '8px',
          padding: '12px',
          maxWidth: '400px',
          maxHeight: '400px',
          overflowY: 'auto',
          overflowX: 'hidden',
          zIndex: 999999,
          boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
          pointerEvents: 'auto', // Changed to auto to allow interaction
          userSelect: 'text', // Allow text selection
        }}
      >
        <div className="tooltip-header" style={{ 
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          marginBottom: '8px',
          fontWeight: 600,
          color: '#333',
          borderBottom: '1px solid #e1e8ed',
          paddingBottom: '8px',
        }}>
          <span style={{ color: '#9b59b6' }}>▦</span>
          {title}
        </div>
        <div 
          className="tooltip-content"
          style={{ 
            color: '#666',
            fontSize: '14px',
            lineHeight: '1.6',
            maxHeight: '250px',
            overflowY: 'auto',
            overflowX: 'hidden',
            paddingRight: '8px',
          }}
          dangerouslySetInnerHTML={{ 
            __html: getHtmlContent()
          }}
        />
      </div>,
      document.body
    )}

    {showInspector && typeof window !== 'undefined' && createPortal(
        <div
          ref={inspectorRef}
          style={{
          position: 'fixed',
          top: inspectorPosition.top,
          left: inspectorPosition.left,
          width: '360px',
          maxWidth: '95vw',
          maxHeight: '70vh',
          background: '#fff',
          boxShadow: '0 18px 40px rgba(15, 23, 42, 0.22)',
          borderRadius: '12px',
          zIndex: 999999,
          display: 'flex',
          flexDirection: 'column',
        }}
      >
        <div
          onMouseDown={handleInspectorMouseDown}
          style={{
            padding: '10px 16px',
            borderBottom: '1px solid #e1e8ed',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            gap: '12px',
            cursor: isDraggingInspector ? 'grabbing' : 'grab',
            background: 'linear-gradient(135deg, rgba(99,102,241,0.08), rgba(129,140,248,0.08))',
            borderTopLeftRadius: '12px',
            borderTopRightRadius: '12px',
          }}
        >
          <span style={{ fontSize: '13px', fontWeight: 600, color: '#475569', letterSpacing: '0.04em', textTransform: 'uppercase' }}>Block Inspector</span>
          <button
            type="button"
            onClick={handleCloseInspector}
            style={{
              border: 'none',
              background: 'transparent',
              padding: 0,
              cursor: 'pointer',
              color: '#475569',
              fontSize: '16px',
            }}
            aria-label="Close block inspector"
          >
            ✕
          </button>
        </div>
        <div
          style={{
            padding: '16px',
            borderBottom: '1px solid #e1e8ed',
            display: 'flex',
            flexDirection: 'column',
            gap: '12px',
          }}
        >
          <div>
            <label style={{ fontSize: '12px', color: '#8492a6', textTransform: 'uppercase', letterSpacing: '0.08em' }}>Block title</label>
            <input
              type="text"
              value={title}
              onChange={handleTitleChange}
              onBlur={handleTitleBlur}
              onKeyDown={handleTitleKeyDown}
              placeholder={DEFAULT_BLOCK_TITLE}
              style={{
                width: '100%',
                marginTop: '6px',
                padding: '8px 10px',
                fontSize: '16px',
                fontWeight: 600,
                border: '1px solid #d5dfe9',
                borderRadius: '6px',
                outline: 'none',
              }}
            />
          </div>
          {headerMetaLabel && (
            <div style={{ fontSize: '12px', color: '#708090' }}>{headerMetaLabel}</div>
          )}
          <div style={{ display: 'flex', gap: '8px' }}>
            <button
              type="button"
              onClick={() => {
                wrapperRef.current?.scrollIntoView({ behavior: 'smooth', block: 'center' })
                handleCloseInspector()
              }}
              style={{
                border: 'none',
                background: 'rgba(99, 102, 241, 0.12)',
                color: '#6366f1',
                padding: '6px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
                fontWeight: 600,
              }}
            >
              Reveal in document
            </button>
            <button
              type="button"
              onClick={handleCloseInspector}
              style={{
                border: 'none',
                background: 'rgba(148, 163, 184, 0.14)',
                color: '#475569',
                padding: '6px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
                fontWeight: 600,
              }}
            >
              Close
            </button>
          </div>
        </div>
        <div
          style={{
            flex: 1,
            padding: '16px',
            overflowY: 'auto',
            color: '#444',
          }}
        >
          <InspectorPreview node={node} />
        </div>
      </div>,
      document.body
    )}
    </>
  )
}

function InspectorPreview({ node }: { node: PMNode }) {
  const extensions = useMemo(() => createInspectorExtensions(), [])
  const inspectorEditor = useEditor(
    {
      extensions,
      editable: false,
      content: buildInspectorDoc(node),
    },
    [extensions, node]
  )

  useEffect(() => {
    if (!inspectorEditor) return
    inspectorEditor.commands.setContent(buildInspectorDoc(node), false)
    inspectorEditor.setEditable(false)
  }, [inspectorEditor, node])

  if (!inspectorEditor) {
    return null
  }

  return (
    <div className="inspector-editor">
      <EditorContent editor={inspectorEditor} />
    </div>
  )
}

function CollapsibleBlockPreview({ node }: any) {
  const [collapsed, setCollapsed] = useState<boolean>(node.attrs.collapsed ?? false)

  useEffect(() => {
    setCollapsed(node.attrs.collapsed ?? false)
  }, [node.attrs.collapsed])

  useEffect(() => {
    debugLog('CollapsibleBlockPreview', 'RENDER', {
      metadata: {
        collapsed: node.attrs.collapsed,
        childCount: node.childCount,
        hasContent: !!node.content?.size,
        jsonPreview: createContentPreview(node.toJSON?.() ?? null),
      },
    })
  })

  const title = getDisplayTitle(node.attrs.title)
  const stats = formatBlockMeta(computeBlockStats(node))

  return (
    <NodeViewWrapper
      className="collapsible-block preview"
      style={{
        borderLeft: 'none',
        padding: 0,
        margin: '0 0 4px 0',
      }}
    >
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          cursor: 'pointer',
          userSelect: 'none',
        }}
        onClick={() => setCollapsed(prev => !prev)}
      >
        <span
          style={{
            fontSize: '16px',
            transition: 'transform 0.2s ease',
            transform: collapsed ? 'rotate(-90deg)' : 'rotate(0deg)',
            display: 'inline-block',
            color: '#475569',
          }}
        >
          ▼
        </span>
        <span style={{ fontSize: '16px', fontWeight: 600, color: '#1f2937' }}>{title}</span>
        {stats && (
          <span style={{ marginLeft: 'auto', fontSize: '12px', color: '#708090' }}>{stats}</span>
        )}
      </div>

      {!collapsed && (
        <div
          style={{
            paddingLeft: '20px',
            marginTop: '8px',
          }}
        >
          <NodeViewContent className="content" />
        </div>
      )}
    </NodeViewWrapper>
  )
}

function CollapsibleBlockComponent(props: any) {
  debugLog('CollapsibleBlockComponent', 'NODE_VIEW_RENDER', {
    metadata: {
      inspectorPreview: props.extension?.options?.inspectorPreview ?? false,
      hasEditor: !!props.editor,
    },
  })
  const isPreview = props.extension?.options?.inspectorPreview ?? false
  if (isPreview) {
    return <CollapsibleBlockPreview {...props} />
  }
  return <CollapsibleBlockFull {...props} />
}

function createTemplatePreviewExtensions() {
  return [
    StarterKit.configure({ history: false, dropcursor: false, gapcursor: false }),
    Underline,
    Highlight,
    AnnotationMark,
  ]
}

function createInspectorExtensions() {
  return [
    StarterKit.configure({ history: false, dropcursor: false, gapcursor: false }),
    Underline,
    Highlight,
    AnnotationMark,
    CollapsibleBlock.configure({ inspectorPreview: true }),
  ]
}
