# Annotation App Refactor Plan (2025-11-09)

## Goals
- Reduce the size/complexity of `components/annotation-app.tsx` (currently the largest orchestrator) so workspace hydration, folder cache, popup CRUD, and toolbar wiring live in focused modules.
- Improve testability by isolating side-effect-heavy concerns (Knowledge Base fetches, folder cache invalidation, layout persistence) behind hooks or utility adapters.
- Ensure the popup overlay continues to rely on clear, typed boundaries (one hook for popup state, one for KB data, one for layout persistence), minimizing regressions when we iterate on overlay features.

## Guardrails & Constraints
- Comply with `codex/codex_needs_to_avoid/isolation-reactivity-anti-patterns.md`: provider contracts must remain backward-compatible while new hooks ship; UI rewiring cannot land in the same PR that adds new context fields.
- No hook may call `useSyncExternalStore` unless it validates the provider shape (defensive defaults, runtime assertion with actionable errors).
- Each phase must include an opt-in flag (env or feature toggle) so we can revert to the inline logic if regressions appear during rollout.
- LayerProvider references (`layerCtx`, `applyExternalTransform`, `canvasDataStore`) are treated as shared singletons; hooks must consume them via dependency injection, never re-create providers inside hooks.

## Pain Points Observed
1. **Mixed responsibilities** – layout persistence, KB fetches, folder cache, popup CRUD, and UI orchestration all live in the same file, making it hard to reason about changes.
2. **Folder cache drift** – logic for keeping `folderCacheRef` fresh after create/move/delete is duplicated and easy to break.
3. **Knowledge Base workspace state** – deriving and propagating `knowledgeBaseWorkspaceId` happens inline with UI concerns.
4. **Popup selection & overlay plumbing** – even after overlay refactors, `annotation-app.tsx` still handles selection/move callbacks inline, reimplementing guardrails already handled elsewhere.
5. **Testing friction** – because everything lives in one component, unit testing any single concern requires stubbing massive context.

## Latest Progress (2025-02-15)
- Added Jest suites for `useOverlayLayoutSaveQueue` and `useOverlayLayoutPersistence`, covering debounce timing, conflict resolution, diagnostics toasts, and ancestor-color fetch fallbacks.
- Extracted workspace list/create/delete orchestration plus menu state into `useOverlayWorkspaces`, so `annotation-app.tsx` now consumes a focused hook while leaving the `ANNOTATION_APP_REFACTOR_PHASE` gate untouched.
- Manual regression plan now includes the workspace lifecycle loop (create/delete, dual-tab conflict, diagnostics repair) to accompany the new hook + tests.

## Module Interface Overview
| Module/Hook | Inputs | Outputs | Notes |
| --- | --- | --- | --- |
| `useKnowledgeBaseWorkspace(options)` | `initialWorkspaceId`, `knowledgeBaseClient`, `authHeaders`, `onWorkspaceHydrated` | `{workspaceId, workspaceMeta, status, error, refresh, withWorkspaceHeaders}` | Persists `workspaceId` via `useState`; wraps KB REST client; `withWorkspaceHeaders` appends `x-workspace-id` to fetches. |
| `useFolderCache({folderClient, logger, ttlMs})` | `folderClient`, TTL (default 5 minutes), `onCacheMiss` | `{getFolderChildren, updateFolderEntry, flushFolderEntry, isStale}` | Owns internal `Map<string, CacheEntry>`; exposes read/write helpers and emits telemetry on stale hits. |
| `usePopupOverlayState({canvasDataStore, kbWorkspace, folderCache})` | `canvasDataStore`, `kbWorkspace` result, folder cache API, feature flags | `{popups, activeSelection, handlers, createPopup, movePopup, removePopup, resetSelection}` | Maintains popup map via `useReducer`; ensures workspace/folder references stay in sync. |
| `useOverlayLayoutPersistence({layoutAdapter, telemetry, clock})` | `layoutAdapter`, telemetry sink, conflict resolver | `{loadLayout, saveLayout, handleConflict, setCameraSync, resumeFromSnapshot}` | Serializes adapter calls, dedupes saves via debounced queue, emits `layout_conflict_resolved` metrics. |
| `AnnotationAppShell` | Providers, feature flags, KB + layout hooks | Renders global shell, passes resolved state to `AnnotationWorkspaceView`. | Responsible for gating Phase 4 flag and fallback rendering. |
| `AnnotationWorkspaceView` | `popups`, `workspace`, layout handlers | Renders canvas/overlay/toolbar composition. | Lightweight coordinator, no side effects. |

## Proposed Phases

### Phase 0 – Readiness & Instrumentation
- Owners: Canvas Infra + QA.
- Deliverables:
  - Add `ANNOTATION_APP_REFACTOR_PHASE` runtime flag (values `off`, `hooks`, `popup`, `layout`, `shell`).
  - Capture current telemetry baselines (popup CRUD latency, layout conflict rate, folder cache TTL misses).
  - Document rollback procedures per phase in the runbook.

### Phase 1 – Data & Workspace Hooks
- Scope: introduce `useKnowledgeBaseWorkspace` and `useFolderCache` without rewiring consumers.
- Implementation details:
  - Land the hooks next to `components/annotation-app.tsx` under `lib/hooks/annotation/`.
  - Hooks accept dependency objects (`knowledgeBaseClient`, `folderClient`, etc.) to avoid implicit imports.
  - Provide inline shims (`useLegacyKnowledgeBaseWorkspace`, `useLegacyFolderCache`) so existing code can keep using the old functions until Phase 1 flag flips.
- Rollout:
  - Ship hooks behind `ANNOTATION_APP_REFACTOR_PHASE >= hooks`.
  - Update `annotation-app.tsx` to optionally consume the hooks via feature flag while keeping legacy logic for fallback.
- Validation:
  - Unit tests for both hooks covering success, error, TTL expiry, and concurrent updates.
  - QA runs folder create/move/delete flows plus workspace switching; confirm telemetry parity.

### Phase 2 – Popup Overlay State Surface
- Scope: extract popup CRUD + overlay interaction into `usePopupOverlayState`.
- Implementation details:
  - Hook accepts the outputs of Phase 1 hooks and `canvasDataStore`.
  - Expose typed handler bundle: `{onSelect, onMove, onCreate, onDelete, onDetachFromFolder}`.
  - Provide compatibility adapter that maps new handlers back to the existing `<PopupOverlay />` props.
- Rollout:
  - Feature flag gate `annotation-app.tsx` to swap in the hook when `ANNOTATION_APP_REFACTOR_PHASE >= popup`.
  - Keep legacy inline logic in the file until metrics prove parity for 1 release.
- Validation:
  - Expand `__tests__/unit/popup-overlay.test.ts` to import the new hook handlers.
  - Add storybook regression spot-check (manual) for drag/move, selection, and KB-driven popups.

### Phase 3 – Layout Persistence Boundary
- Scope: isolate layout persistence into `useOverlayLayoutPersistence`.
- Implementation details:
  - Hook wraps `OverlayLayoutAdapter`, ensures `load` and `save` return typed promises, and adds retry/backoff for HTTP 409 conflicts.
  - Provide `handleConflict` helper that notifies the caller and merges remote vs local snapshots via timestamp priority.
  - Continue emitting telemetry via injected `telemetry` dependency (defaulting to `canvasTelemetry`).
  - (2025-02-15) Workspace list/create/delete orchestration plus menu state now live inside `useOverlayWorkspaces`, keeping `annotation-app.tsx` focused on wiring while the phase gate remains unchanged.
- Rollout:
  - Flag `ANNOTATION_APP_REFACTOR_PHASE >= layout` switches `annotation-app.tsx` to use the hook; fallback path remains available for one version.
  - Update manual checklist with conflict scenarios (parallel browser tabs, offline -> online recovery).
- Validation:
  - ✅ `__tests__/unit/hooks/use-overlay-layout-save-queue.test.ts` + `use-overlay-layout-persistence.test.ts` mock `OverlayLayoutAdapter` to cover conflicts, debounce timing, diagnostics toast wiring, and ancestor-color fetch fallbacks.
  - Add smoke Playwright script that toggles layout persistence and asserts saved positions survive reload.

#### Manual Regression Checklist – Workspace Lifecycle (additive for Phase 3+)
1. **Workspace create/save loop** – snapshot a new workspace while multiple popups are open, refresh the page, and confirm layout + camera persist; verify the diagnostics toast does not appear for a clean save.
2. **Workspace delete fallback** – delete a non-default workspace that currently owns open popups and ensure:
   - the workspace disappears from the list,
   - `annotation-app.tsx` switches to the fallback workspace (or clears popups if none remain),
   - the toast reports the removal.
3. **Dual-tab conflict** – open two tabs on the same workspace, move popups in tab A, then move different popups in tab B and force a save:
   - expect the second save to trigger conflict resolution,
   - verify popups reconcile and diagnostics toasts fire if data diverges.
4. **Diagnostics repair** – load a workspace that intentionally references folders from another Knowledge Base (or simulate via API) and confirm the repair toast appears, the “Repair” action removes mismatched popups, and ancestor color fallbacks apply during refetch.
5. **Menu interactions** – open the workspace menu, click outside to dismiss, toggle the sidebar to hide the menu, and ensure the hook closes it automatically (regression guard for `shouldShowWorkspaceToggle`).

### Phase 4 – UI Composition Split
- Scope: separate shell/providers from workspace view.
- Implementation details:
  - Create `components/annotation-app-shell.tsx` hosting providers, modals, toasts, hotkeys.
  - Create `components/annotation-workspace-view.tsx` that receives already-prepared props (popups, handlers, workspace data).
  - Ensure shell lazily imports the heavy canvas chunk so Next.js can split bundles.
- Rollout:
  - Flag `ANNOTATION_APP_REFACTOR_PHASE >= shell` toggles the new composition.
  - Provide fallback export (`export const AnnotationApp = LegacyAnnotationApp`) while the new shell bakes.
- Validation:
  - Bundle analyzer run to confirm size improvement.
  - Manual regression on keyboard shortcuts, toast display, and LayerProvider hydration.

### Phase 4 Prerequisites (current focus)
1. Document the shell/view split: outline which providers remain in `AnnotationAppShell` vs. which props `AnnotationWorkspaceView` consumes so routing/SSR wiring is predictable.
2. Inventory remaining shared state that still lives inline and decide which pieces need hooks before the split:
   - **Canvas centering + retry timers** (`AnnotationApp`, lines ~180-340): still uses local refs/effects; extract into `useCanvasCentering` so shell/view boundary stays pure.
   - **Multi-layer keyboard shortcuts + hover guards** (`AnnotationApp`, lines ~1360-1520): currently manipulate `layerContext` directly; consider `useOverlayLayerHotkeys`.
   - **Constellation toggle + sidebar coordination** (`AnnotationApp`, lines ~240-320 & ~2500+): move into `useConstellationViewState` to avoid re-threading props through the view.
   - **Workspace toolbar backdrops + toolbar active panel state** (`AnnotationApp`, lines ~500-620): evaluate a `useWorkspaceToolbarState` hook to keep future shell lean.
3. Confirm every hook (`useKnowledgeBaseWorkspace`, `useFolderCache`, `useOverlayWorkspaces`, `useOverlayLayoutPersistence`, `usePopupOverlayState`) has green unit tests + manual regression notes so the shell swap is a wiring change only.
4. Keep telemetry + feature flags in place so `ANNOTATION_APP_REFACTOR_PHASE` can toggle the shell without reintroducing provider drift (lessons from the isolation reactivity anti-pattern document). Add explicit “flag flip checklist” before implementing Phase 4.

#### Shell/View Interface Draft (2025-11-10)
| Concern | `AnnotationAppShell` (new) | `AnnotationWorkspaceView` (new) |
| --- | --- | --- |
| Providers & Context | Owns `LayerProvider`, `CanvasWorkspaceProvider`, `ConstellationProvider`, toasts, hotkeys, feature flags, and telemetry wiring. | Receives already-resolved context values (`layerContext`, toolbar state, popup handlers) as props; no provider creation. |
| Data orchestration | Calls hooks that touch IO (`useKnowledgeBaseWorkspace`, `useFolderCache`, `useOverlayLayoutPersistence`, `useOverlayWorkspaces`, `usePopupOverlayState`, `useWorkspaceNoteTitleSync`, `useWorkspacePanelPositions`). Manages `shouldLoadOverlay` + hydration gating. | Consumes serialized props: `{popups, workspaceMeta, toolbarState, sidebarData, layoutStatus}`, and emits user intents via callback props (`onSelectNote`, `onCreatePopup`, `onWorkspaceSelect`, etc.). |
| Rendering | Handles route-level suspense, overlays, modals, error boundaries, and fallback UI for hydration (e.g., show note-only skeleton until overlay loads). | Renders the actual canvas composition (canvas + overlay + sidebars + toolbars) using pure props; no direct fetches or feature-flag branches. |
| Navigation & telemetry | Tracks active workspace/workspace menu, diagnostics toasts, and aggregates telemetry events. | Emits telemetry/events via callback props supplied by the shell; no direct `debugLog` calls. |

Props planned for `AnnotationWorkspaceView`:
- `canvasState`, `setCanvasMode`, `layerContext`, `shouldLoadOverlay`.
- `popups`, `overlayHandlers` (`create/move/resize/delete`, persistence status, diagnostics state).
- `workspaceMeta` (`currentWorkspace`, `workspaces`, loading/saving flags, menu controls).
- `sidebarData + noteTitleMap`, `organizationSidebarHandlers`, `notePreviewState`.
- `toolbarState` (notes widget toggles, recent notes refresh trigger).

##### AnnotationWorkspaceView Prop Contract (detailed)
| Prop | Type / Shape | Provided by | Notes |
| --- | --- | --- | --- |
| `canvasState` | `CanvasState` | `useCanvasMode` | Read-only snapshot of current canvas config. |
| `setCanvasMode` | `(mode: CanvasMode) => void` | `useCanvasMode` | Shell debounces rapid changes before passing through. |
| `layerContext` | `LayerContextValue` | `LayerProvider` | Shell supplies dependency-injected singleton; view never re-creates providers. |
| `shouldLoadOverlay` | `boolean` | `useOverlayHydrationGate` | Prevents premature overlay mounts during SSR/hydration. |
| `popups` | `PopupMap` | `usePopupOverlayState` | Already includes workspace/folder references and diagnostics metadata. |
| `overlayHandlers` | `{onCreate,onMove,onResize,onDelete,onDiagnosticsAck}` | Aggregated from `usePopupOverlayState`, `usePopupBulkActions`, diagnostics hooks | Handlers must be referentially stable to avoid thrash. |
| `workspaceMeta` | `{currentWorkspace, workspaces, status, menuState}` | `useKnowledgeBaseWorkspace`, `useOverlayWorkspaces` | Contains loading/saving flags plus menu open/close controls. |
| `sidebarData` | `SidebarData` | `useOrganizationSidebarActions` | Includes `noteTitleMap`, `organizationSidebarHandlers`, `notePreviewState`. |
| `toolbarState` | `{activePanel, recentNotesTrigger, constellationToggle}` | `useWorkspaceToolbarState`, `useConstellationViewState` | Stores widget toggles + callbacks for constellation panel. |
| `layoutStatus` | `{camera, persistenceStatus, conflictState}` | `useOverlayLayoutPersistence`, `useOverlayLayoutSaveQueue` | Surface-only data; shell retains refs/queues. |

###### Provider & story requirements
- `AnnotationWorkspaceView` story must render underneath `LayerProvider`, `CanvasWorkspaceProvider`, and `ConstellationProvider` mocks supplied by the shell story to guarantee type parity.
- The view exposes no side-effects; all callbacks are supplied by the shell, so Storybook stories validate prop shapes without touching real stores.
- Prop types live under `components/annotation-workspace-view/types.ts` (to be created) and exported for both runtime props and smoke tests.

###### Shell vs. legacy smoke test
1. Test name: `AnnotationAppShell.prop-parity.test.tsx` under `__tests__/integration/`.
2. Mount legacy `AnnotationApp` and the flag-on shell using the same mocked workspace + folder fixtures.
3. Capture the props passed into `AnnotationWorkspaceView` (flagged run) and the legacy inline view (legacy run) via a shared `serializeWorkspaceViewProps` helper.
4. Assert deep equality (excluding known transient refs) so regressions in prop shapes are caught automatically before flipping the flag.
5. Run this smoke test in CI whenever `ANNOTATION_APP_REFACTOR_PHASE` changes or when shell wiring is modified; annotate failures with actionable diffs.

Shell responsibilities:
1. Resolve and memoize all external data (KB, folder cache, overlay layout).
2. Hold refs for persistence (layout queues, camera state) and pass safe callbacks down.
3. Decide when to mount overlay-specific effects (`shouldLoadOverlay`), keeping view stateless.

#### Inline State Inventory & Hook Targets
- **Canvas centering + retry timers** – implemented by `useCanvasCentering`; shell simply passes `{centerNoteOnCanvas, handleFreshNoteHydrated}` props to the view.
- **Constellation view toggle & sidebar coordination** – already extracted via `useConstellationViewState`; ensure shell remains the only consumer and the view only receives `{activeSidebarTab, showConstellationPanel, toggleConstellationView}`.
- **Workspace toolbar UI** – `useWorkspaceToolbarState` owns widget positioning, active panel, recent notes refresh; shell hands `{toolbarState, toolbarHandlers}` to the view.
- **Popup overlay interactions** – `usePopupOverlayState`, `usePopupBulkActions`, `useOverlayLayerInteractions`, `useOrganizationSidebarActions` already encapsulate overlay-specific mutations; confirm each exposes serializable props so the view can stay declarative.
- **Layout persistence & workspace menu** – `useOverlayLayoutPersistence`, `useOverlayLayoutSaveQueue`, and `useOverlayWorkspaces` now expose plain handlers/state; shell will coordinate sequencing (hydration, conflict repair) before handing off to the view.
- **Hotkeys & layer guards** – follow-up hook `useOverlayLayerHotkeys` (TBD) should encapsulate keyboard shortcuts currently inline around lines ~1300–1500 so the view simply attaches provided handlers.

#### Next Actions Before Phase 4
1. Finalize and document the `AnnotationWorkspaceView` prop contract (types + story) and pair it with a smoke test (Jest or Playwright) that asserts shell vs. legacy paths receive the same props for a given workspace.
2. Finish extracting any remaining inline effects (keyboard shortcuts, hover guards, constellation toggles, diagnostics flags) into dedicated hooks to keep the shell boundary lean.
3. Add a “flag flip checklist” section (telemetry baselines, bundle analyzer snapshot, rollback plan, regression notes) so enabling `ANNOTATION_APP_REFACTOR_PHASE >= shell` is procedural.
4. Once the above land, create the shell/view files, move rendering logic behind the phase flag, and run the full manual regression + bundle analyzer while keeping the legacy path active until telemetry proves parity for at least one release before flipping the flag in staging.

## Flag Flip Checklist (Phase 4)
1. **Telemetry baselines captured** – snapshot `popup_crud_latency_ms`, `folder_cache_ttl_miss_rate`, `layout_conflict_rate`, and `workspace_menu_error_rate` in Looker before enabling the shell flag; document expected variance (±5%).
2. **Bundle analyzer delta** – record `next build` analyzer output for both legacy and shell paths; ensure the shell path reduces the `AnnotationApp` chunk or stays within +10 kB before rollout.
3. **Regression evidence** – attach the latest manual checklist run, Playwright smoke (`--grep "@annotation-app"`), and the new prop-parity smoke test results to the rollout doc.
4. **Rollback procedure** – verify `ANNOTATION_APP_REFACTOR_PHASE` env/feature switch can be flipped back to `layout` or `popup` within one deploy; include CLI/build instructions plus owner contact.
5. **Observability hooks** – enable temporary logging (warn on prop mismatches, layout conflicts) scoped behind the shell flag and plan to remove once telemetry is stable for ≥1 release.

## Testing & Validation Plan
- **Unit tests** (Vitest/Jest): each hook/module with exhaustive cases (success, failure, stale cache, conflict resolution). Owners: Canvas Infra.
- **Integration tests**: extend `__tests__/unit/popup-overlay.test.ts` plus add `lib/hooks/__tests__/folder-cache.test.ts`.
- **Playwright smoke**: run `npx playwright test --grep "@annotation-app"` after each phase flips to “on” in staging.
- **Manual checklist**: existing overlay regression sheet plus new rows for workspace switching, folder TTL expiry, layout conflict recovery.
- **Telemetry watch**: monitor `popup_crud_latency_ms`, `folder_cache_ttl_miss_rate`, `layout_conflict_rate` on Looker dashboards for 48h post rollout.

## Risks & Mitigations
- **State synchronization** – Mitigation: single source of truth in hooks, explicit snapshot helpers, feature flags for rapid rollback.
- **Layout conflicts** – Mitigation: retry/backoff plus manual QA on dual-tab editing before Phase 3 roll-out.
- **Context churn** – Mitigation: dependency injection for LayerProvider artifacts, no re-creation inside hooks, runtime assertions in dev mode.
- **Hot reload drift** – Mitigation: do not remove legacy inline logic until next phase is stable; add console warnings if provider shape mismatches occur.

## Rollout Timeline & Owners
| Phase | Duration (target) | Owner | Dependencies |
| --- | --- | --- | --- |
| Phase 0 | 2 days | Canvas Infra TL | Telemetry dashboards ready |
| Phase 1 | 1 week | Workspace Squad | KB client typings finalized |
| Phase 2 | 1 week | Canvas Infra | Phase 1 flag on |
| Phase 3 | 1 week | Overlay Platform | Adapter contract reviewed |
| Phase 4 | 1 week | UI Architecture | Bundle analyzer baseline captured |

## Success Criteria
- `components/annotation-app.tsx` drops below ~600 lines (currently >1.2k) once Phase 4 ships.
- Each major concern (KB workspace, folder cache, popup interaction, layout persistence) lives in a dedicated hook/module with unit tests checked into CI.
- Overlay regressions remain absent: manual checklist + `npm test -- __tests__/unit/popup-overlay.test.ts` pass after each phase.
- Telemetry deltas remain within ±5% for folder cache TTL misses and popup CRUD latency for two weeks after final rollout.
