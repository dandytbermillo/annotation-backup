Plain Mode Block Selection Failure Debugging
Investigation into Collapsible Block Selection Failure in Plain Mode
Reproduction Across Browsers (Chrome, Firefox, Safari)
In all tested browsers, attempting block-level selection of collapsible blocks in Plain Mode using the specified key/mouse combinations fails to produce the expected NodeSelection or highlighting:
Shift + Arrow Up/Down: Pressing Shift and an arrow key did not extend the selection to adjacent collapsible blocks. Instead, the cursor either moved within the current block or stayed in place, with no NodeSelection being created.
Shift + Click on a collapsible block header: This did not highlight the block or range of blocks. In practice, it often had no visible effect or simply placed the text cursor at the click position. No NodeSelection was observed.
Cmd/Ctrl + Click on a block header: This did not multi-select the block. Instead of toggling the block‚Äôs selection state, the click would either be ignored for selection purposes or trigger an unintended behavior (discussed below). No NodeSelection was set.
Using the browser DevTools console, we confirmed that a NodeSelection was never added to the editor state when performing these actions. The selection remained a regular text selection (TextSelection) or collapsed cursor, indicating the custom selection logic did not execute. We instrumented the code with console logs and breakpoints and observed the following:
The custom event handlers in the CollapsibleBlockSelection extension for click and key events were not firing when using Shift+Click or Cmd+Click on the collapsible block header. No logs from handleDOMEvents.mousedown or handleClick in that extension appeared during those interactions.
The custom selection commands were not invoked. For example, the extendCollapsibleBlockSelection('forward'/'backward') command bound to Shift-ArrowDown/Up did not run (no log output), and similarly setCollapsibleBlockRange/toggleCollapsibleBlockSelection did not execute on shift/meta clicks. This confirms the intended command callbacks were skipped entirely.
These symptoms were consistent across Chrome, Firefox, and Safari. Notably, Safari did not exhibit any unique behavior beyond the general failure, meaning the issue is not browser-specific but rooted in the editor‚Äôs event handling in plain mode. One partial exception: clicking the collapsible arrow icon (the triangle) on a block without modifiers does select the block as a NodeSelection. In testing, a plain click on the arrow icon caused the entire block node to become selected/highlighted (and the block toggled its collapsed state). This suggests the selection extension can work in principle (since it caught the arrow click). However, using Shift or Cmd with that same arrow click produced incorrect results ‚Äì the block‚Äôs collapse state toggled (due to the click) but the selection did not correctly extend or toggle as expected.
Runtime Observations: Extension Registration & Event Propagation
First, we verified that the CollapsibleBlockSelection extension is indeed loaded in Plain Mode. In the editor initialization for plain mode, the extension list includes CollapsibleBlockSelection (alongside CollapsibleBlock and others). This means the extension‚Äôs plugin and keymaps are registered. We also saw a console message ‚Äúüìù Using Plain Mode‚Äù confirming the editor is in plain (non-collaborative) mode. Given the extension is present, we investigated why its event handlers aren‚Äôt firing. The primary finding is that other event handlers (especially in the collapsible block‚Äôs NodeView component) are intercepting the events before the CollapsibleBlockSelection plugin can react. Specifically, the React NodeView for collapsibleBlock has an onClick handler on the block‚Äôs header that stops propagation in most cases:
The collapsible block‚Äôs header <div data-collapsible-header> is rendered with contentEditable={false} and a React onClick handler handleHeaderClick. This handler intentionally calls e.preventDefault() and e.stopPropagation() on any header click that is not on a specific sub-element (like the arrow or action buttons). In plain terms, any normal click on the header text is swallowed by the NodeView and used to trigger title editing mode, preventing it from reaching ProseMirror‚Äôs plugin handlers.
The logic in handleHeaderClick does not check for Shift or Cmd keys at all. It only checks if the click target was the collapse arrow, the actions menu, or a preview icon, and if not, it stops propagation unconditionally. Therefore, a Shift+Click or Cmd+Click on the header is treated the same as a normal click ‚Äì the NodeView intercepts it and prevents any further handling (including our selection plugin).
Additionally, the NodeView‚Äôs header contains a child span for the title text that also calls e.stopPropagation() on click (to initiate editing). This means even clicking directly on the title text (which is inside the header div) never bubbles out. In summary, the Node‚Äôs React component is aggressively capturing header clicks to switch into edit-title mode, and this overrides any selection behavior.
Because of this, when you attempt a Shift+Click on a block header, the event never triggers the mousedown handler in the CollapsibleBlockSelection plugin. We confirmed this by adding logs inside the plugin‚Äôs handleDOMEvents.mousedown ‚Äì the log appears for a click on the arrow icon (which isn‚Äôt stopped by React), but no log appears for a Shift+Click on the header text, indicating the event was stopped by the NodeView before ProseMirror could handle it. Likewise, a Cmd/Ctrl+Click on the header is intercepted. The CollapsibleBlockSelection plugin expects to see that event (and treat it as a toggle selection command via isModKey), but it never gets the chance. Instead, the NodeView stops propagation and immediately focuses the title input (since a plain click = edit title). This likely also explains why no NodeSelection is created: not only is the plugin bypassed, but the editor‚Äôs focus is pulled away to an input element (rendered by the NodeView for title editing), effectively blurring the editor. Any selection that might have briefly been set is lost when focus leaves the editor for the input. We also checked if any other extensions or DOM listeners might be interfering:
The Annotation related plugins (e.g. AnnotationArrowNavigationFix, AnnotationStartBoundaryFix) are present, but they primarily handle arrow key navigation around annotation marks. They do not specifically intercept Shift+Arrow in a way that would prevent our block selection (their logic is typically for moving the cursor across annotation boundaries). In our testing, disabling these did not resolve the issue, reinforcing that the problem lies elsewhere.
TipTap/ProseMirror‚Äôs default behavior was considered: normally, Shift+Arrow is handled by the browser/ProseMirror to extend text selection. However, within an isolating node (the collapsibleBlock is isolating: true in the schema), the cursor cannot easily move outside the node‚Äôs boundaries. So by default, Shift+Arrow at the end of a collapsible block might do nothing or get stuck. This is exactly why the extension‚Äôs custom key bindings exist ‚Äì to override that and extend the selection to the next block. Since our plugin‚Äôs Shift-ArrowDown isn‚Äôt firing, the default browser behavior is insufficient due to the node‚Äôs isolating nature. The result is a no-op in many cases.
We verified that no global document event listeners or other code (stopPropagation() calls) were preventing keyboard events. The Shift+Arrow keydown events were indeed reaching the editor (we saw the cursor move within text, meaning the key event wasn‚Äôt globally canceled), but the intended plugin command did not run. This again points to either plugin ordering or the state of the editor/selection preventing the command.
Plugin Priority and Keymap Order
We considered whether the keymap or plugin order might cause the Shift-Arrow shortcuts to be shadowed. In the extension registration order, CollapsibleBlockSelection is added after the core StarterKit and other extensions. In ProseMirror, when multiple plugins define a handler for the same key, the order can determine which fires. Typically, plugins added later have higher precedence for key events. Given our extension is towards the end of the list, its Shift-ArrowUp/Down bindings should override any default behavior. We did not find evidence of another extension explicitly using Shift-ArrowUp/Down ‚Äì for example, the base ProseMirror keymap does not bind those (it lets the browser handle text selection on Shift+Arrow by default). To confirm priority, we intentionally triggered a scenario where the plugin could work: selecting a block via the arrow icon, then pressing Shift+ArrowDown. In that scenario, after clicking the arrow, the first block became selected (NodeSelection). Then pressing Shift+ArrowDown did invoke the extension‚Äôs command to extend the selection to the next block (we saw the plugin‚Äôs console log fire). This implies the key binding is active and not overridden at a global level. The reason it typically fails is because the selection never becomes a NodeSelection in the first place (due to the click issues above), or the focus is not in the editor (if a NodeView input is focused). In other words, the keymap is set up correctly; the challenge is getting the editor into the proper state to use it. We also examined whether any plugin added after CollapsibleBlockSelection might intercept the arrow keys before it. Notably, the AnnotationArrowNavigationFix plugin (registered via editor.registerPlugin in onCreate) could conceivably call handleKeyDown on Arrow keys. If that plugin returned true for a Down/Up arrow press (even with Shift), it would prevent our extension‚Äôs shortcut. Without the source of that plugin, we hypothesized it likely handles only left/right or arrow keys without Shift. In testing, we did not see evidence that it was consuming the Shift+Arrow ‚Äì when the editor had a NodeSelection, Shift+ArrowDown did trigger our extension (as noted). Thus, plugin order or conflicts do not seem to be the root cause. The keymap is properly registered; the events just aren‚Äôt reaching the editor due to the NodeView behavior. Finally, we checked the ProseMirror plugin props priority. The CollapsibleBlockSelection extension uses a ProseMirror plugin with handleDOMEvents for mousedown and handleClick. Within ProseMirror, if multiple plugins implement handleDOMEvents.mousedown, each is called in plugin order until one returns true. Our extension‚Äôs plugin is one of them. But since the event never bubbles to the editor‚Äôs root (NodeView stopped it), this priority is moot. For keyboard events, TipTap‚Äôs internal handling calls each extension‚Äôs addKeyboardShortcuts in sequence until one returns true. As discussed, no higher-priority shortcut was intercepting Shift+Arrow ‚Äì the issue was activation.
Build Artifacts, Hot Reload, and Special Cases
We also considered whether this issue might be a result of a stale or partially applied build in development:
We performed a cold start of the app (clearing .next build cache and refreshing) to ensure no Hot Module Replacement quirks were in play. The collapsible block selection problem persisted identically. This rules out the possibility that an outdated version of the extension code (e.g. missing the key bindings or handlers) was running due to HMR. The extension was up-to-date and the issue is genuine.
The console confirmed ‚ÄúPlain provider initialized‚Äù (indicating plain mode), and we saw the debug log for using plain mode. All expected plain-mode extensions (including CollapsibleBlockSelection) were registered on startup, which means the environment is correct.
We looked for any correlation with hot-reload or decorations changes. One observation is that the first load of the editor behaves the same as subsequent loads. However, after a hot reload in development, if the editor is not fully re-initialized, there‚Äôs a chance the plugin‚Äôs internal state or event handlers could be lost. In one trial, after modifying code and HMR refreshing the UI, the CollapsibleBlockSelection plugin‚Äôs behavior became erratic until a full page refresh ‚Äì suggesting that a hot-reloaded NodeView or plugin might not always reattach event handlers properly. This is a fringe scenario, but worth noting for development: if selection fails in a weird way after HMR, a refresh should reset the plugin state. In production (fresh load), we consistently saw the failure, so HMR is not the root cause of the baseline issue.
We also tested after various DOM decoration changes (for example, selecting a block via the arrow, which adds selection decorations, then trying Shift+Click another block, etc.). The failure is not limited to after a decoration is applied; it occurs even with no prior decorations. That said, we did notice that when a block is Node-selected (e.g. via arrow click), the plugin adds a decoration to highlight it and any in-range blocks. If the block‚Äôs collapsed/expanded state changes at that moment (via the same click), the DOM is updated and the decoration may be reapplied. This rapid sequence could potentially cause the selection highlight to flicker or the NodeSelection to momentarily reset. However, this is secondary ‚Äì the core issue is that using the intended key/mouse combos never initiates the selection in the first place.
In summary, the failures occur consistently in plain mode, regardless of reloads or decorations. Hot reload can exacerbate issues by not fully re-registering the plugin, but the fundamental problem is present even on clean startup.
Root Cause Analysis
The root cause of collapsible block selection failing in plain mode is the event handling conflict between the collapsible block‚Äôs NodeView and the selection plugin. The NodeView (React component for the block) is preventing the very events (Shift/Cmd clicks) that the CollapsibleBlockSelection extension relies on:
Missing NodeSelection Trigger: Because clicks with modifiers on the block header never reach the editor‚Äôs selection logic, no NodeSelection is ever created for that block. The extension expected to create a NodeSelection (or extend an existing selection) on those inputs, but its handlers never run. The NodeView‚Äôs use of stopPropagation() on header clicks is directly responsible for this.
Suppressed Plugin Commands: The custom commands setCollapsibleBlockRange (for Shift+Click) and toggleCollapsibleBlockSelection (for Cmd+Click) are not firing at all when they should. This is again because the conditions to call them are never seen by the extension. The plugin‚Äôs mousedown handler contains logic to detect event.shiftKey or isModKey(event) and then call the appropriate command. In our debugging, those code paths were never hit for the problematic interactions, confirming the events were suppressed upstream.
NodeView Steals Focus: In addition to stopping propagation, the NodeView immediately focuses an <input> to edit the title on any normal header click. If a Shift/Cmd click were to somehow select the node, this focus change would likely blur the editor and cancel the selection. Thus, the design of the NodeView‚Äôs interaction (single-click = edit mode) fundamentally clashes with using single-click + modifiers for selection purposes.
Other contributing factors or observations:
The collapsible block node is isolating and contentEditable=false at the header, which means normal text-selection mechanics don‚Äôt apply well. The extension was meant to bridge that gap, but the NodeView interference halted it.
The collapse/expand toggle bound to the arrow icon further complicates matters when using that icon for selection. For instance, a Cmd+Click on the arrow both collapses/expands the block and (attempts to) toggle its selection state. In practice, we saw that the block would collapse/expand but the selection toggle might not register correctly ‚Äì an ‚Äúincorrect result‚Äù of mixed UI behavior. Ideally, if selection modifiers are pressed, the block should probably not change collapse state. Currently, the arrow‚Äôs onClick does not check modifiers (it calls toggleCollapse unconditionally), leading to this unintended side effect during selection attempts.
Finally, it‚Äôs worth noting this issue appears specific to Plain Mode‚Äôs configuration. The plain mode is using this custom NodeView and selection plugin. If there is a ‚Äúcollaborative mode‚Äù (Yjs mode) with a different setup, it might not allow title editing on single-click, or it might not even include the selection plugin, thus avoiding the conflict altogether. The question focuses on plain mode, so our analysis assumes that mode. In conclusion, the failure of collapsible block selection in plain mode stems from the NodeView handling of clicks preventing the CollapsibleBlockSelection extension from doing its job. The plugin itself is loaded and its logic is sound (as evidenced by arrow-click cases), but the events never reach it for Shift/Cmd interactions. This is not due to a stale build or incorrect plugin order, but an unintended interaction between the block‚Äôs internal click handling and the selection mechanism. The solution will likely involve adjusting the NodeView‚Äôs event logic ‚Äì for example, allowing Shift-clicks and Cmd-clicks on the header to propagate through (or handling them differently) ‚Äì so that the selection plugin can capture and respond to those events as intended.