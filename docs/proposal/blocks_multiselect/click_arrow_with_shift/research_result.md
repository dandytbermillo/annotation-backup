ebug Collapsible Block Plugin State During Range Expansion
Debugging Collapsible Selection State Preservation
Selection Interaction Trace
Initial Block Selection (Plain Click): A regular click on a collapsible block triggers the selectCollapsibleBlock command. The plugin logs a CMD_ENSURE_SINGLE action, setting the anchor and head to the clicked block’s position (single-block selection). After dispatch, the plugin’s STATE_APPLY log shows the state snapshot with mode: 'single', anchor = head = <block1Pos>, and the blocks array containing just that one block. This confirms the plugin captured the single-block selection as intended.
Shift+Click to Create a Range: Next, holding Shift and clicking a second collapsible block calls setCollapsibleBlockRange. The debug logs show PLUGIN_MOUSEDOWN_SHIFT_BRANCH followed by CMD_SET_RANGE. In this log, the plugin records the original anchor (the first block’s position) and the new head (second block’s position). The positions array includes both block positions, and nextMode: 'range' indicates the plugin is entering range selection mode. After this transaction, STATE_APPLY logs a state change from the previous single-block snapshot to a new snapshot with mode: 'range', anchor = <block1Pos>, head = <block2Pos>, and a blocks list covering both selected blocks. At this moment, the editor should highlight both blocks (multi-block selection), and the plugin’s internal state correctly reflects a range selection.
Shift+Arrow to Extend the Range: With the range already active (blocks 1–2 selected), pressing Shift+DownArrow triggers extendCollapsibleBlockSelection('forward'). Ideally, the plugin would use the existing anchor (block 1) and current head (block 2) to find the next block. A CMD_EXTEND_RANGE log would then appear, showing anchor: <block1Pos>, prevHead: <block2Pos>, and nextBlockPos pointing to the third block in sequence. The positions array would span from block1 through block3, and nextMode remains 'range'. A subsequent STATE_APPLY would confirm the plugin updated its state to highlight all three blocks. This is the expected behavior – the anchor stays at the first block while the head moves to the new block, preserving the full range.
Anchor/Head State Persistence Issues
In practice, the plugin fails to retain the original anchor/head across the Shift interactions, collapsing back to a single-block selection. The debug trace reveals that after the Shift+Click in step 2, the multi-block selection state is short-lived. Immediately following the CMD_SET_RANGE action, another selection update occurs that resets the plugin state:
Anchor/Head Reset: Instead of maintaining mode: 'range' with anchor at block1, the plugin state reverts to mode: 'single'. A call to pluginKey.getState after the Shift+Click gesture shows mode: 'single' (with the anchor now equal to the second block’s pos), indicating the range state was lost. The logs do not show an explicit CMD_CLEAR event, which means the plugin wasn’t intentionally cleared; rather, a new set-selection transaction overwritten the state. Likely, a CMD_ENSURE_SINGLE for the second block was logged right after the range was set (triggered inadvertently by a duplicate event handler). This would replace the range selection with a single-node selection on block2, dropping block1 from the selection. In other words, the anchor was effectively replaced by the head node’s position on a subsequent transaction, so the plugin never truly “sticks” in range mode beyond the first update.
Duplicate Selection Handling: The root cause appears to be the Shift+Click event being handled twice – once by the plugin’s range-selection logic and again by a default click/selection handler. The plugin’s handleDOMEvents.mousedown already intercepts Shift+Click and calls setCollapsibleBlockRange, preventing the default behavior. However, it’s possible that a follow-up click event or a NodeView reaction also fired. For instance, if the NodeView or editor’s default click handler still runs, it might call selectCollapsibleBlock on the second block (as if it were a normal click) after the range selection. This would log another CMD_ENSURE_SINGLE and set the plugin state to single-block mode again. That second transaction is the one that collapses the range. In the debug timeline, this is the first transaction where the range is lost. It likely occurs immediately after the CMD_SET_RANGE/STATE_APPLY for the range, undoing the multi-block highlight.
Shift+Arrow Extension Failure: Because the anchor was not preserved (it got reset to block2 or cleared), the Shift+Arrow in step 3 doesn’t extend the original range. Instead, the plugin treats block2 as the new anchor. The CMD_EXTEND_RANGE log in this scenario would show anchor: <block2Pos> (since existing.anchor was null and got recalculated from the current selection) and prevHead: <block2Pos>. The next block (block3) becomes the head, so the range covers blocks 2–3 only. Block1 is no longer in the selection because the plugin wasn’t tracking it after the reset. This matches the observed behavior: the multi-block highlight was not maintained, and the extension skipped the originally intended anchor block. (If the plugin state had fully cleared to none, the extend command might even no-op, returning false when it finds no anchor, but here it likely found block2 as a fallback anchor via the current NodeSelection.)
Potential Interference Factors
Several factors can interfere with the plugin’s state persistence, based on the investigation:
NodeView Focus Shift: We considered whether focus shifting to a NodeView’s input (e.g. a collapsible block title field) might clear or change the selection. If the NodeView’s selectNode handler focuses an internal input element, the editor loses focus. This could potentially disrupt plugin state if the editor blur triggers any selection change. In our logs, we did not see an immediate clear or state change solely from a focus loss. The plugin’s state persisted until the overriding single-selection transaction occurred. However, focus shift could prevent the Shift+Arrow key from registering in the editor (since the focus might be on the external input). In other words, NodeView focus issues can block the intended key interaction, but the primary loss of anchor/head was due to the duplicate selection command, not a direct focus-induced state wipe. Still, preventing the NodeView from automatically stealing focus during multi-selection would be important for smooth range extension.
Duplicate Transactions (Plugin vs. Default): The logs strongly indicate that two transactions were fired for what should have been one gesture. The plugin’s own command set the range correctly, but another transaction (likely from the default click or a NodeView event) immediately set a single-node selection. Because the plugin’s state is stored via the pluginKey metadata, that second transaction didn’t include the multi-block state and thus reverted pluginKey.getState to a single selection (or effectively overwrote the stored snapshot with a single-block snapshot). This explains why pluginKey.getState was reporting mode: 'single' after a multi-step gesture – the plugin’s internal state was overridden by the follow-up selection. Ensuring that only the plugin’s intended transaction runs (and suppressing the duplicate) will allow the anchor/head to persist. The debugging confirms that the plugin logic itself wasn’t skipped; it did run and set the state to range, but the outcome was invalidated by the subsequent transaction.
Position Mapping Errors: We verified that the positions used in the plugin commands match the actual block node positions. The helper findCollapsibleBlockPos returns the correct start position of the collapsible block node (its parent depth position), and collectRangeBetween gathers all block positions between the anchor index and head index inclusively. The logged anchor/head positions corresponded to the correct nodes in the document, and the selection ranges were computed properly. There were no off-by-one errors observed in the logs (e.g., no missing or extra nodes in the range). Thus, the issue is not due to misaligned positions from getPos() or posAtCoords – the range was calculated correctly at first. The collapse is purely a state management issue, not a mis-selection of nodes.
Conclusion and First Failing Transaction
The investigation shows that the plugin does enter mode: 'range' on a Shift+Click and temporarily highlights multiple blocks as intended. However, it fails to preserve that state because another selection event intervenes right after. The first transaction that collapses the range is the unintended one that resets the plugin to mode: 'single' (most likely triggered by the same user action being handled twice, e.g. the default click handler or NodeView reacting to the selection). Once this single-selection transaction applies, the plugin’s anchor/head are effectively truncated to one node, and the multi-block highlight vanishes. In summary, the plugin’s internal range-selection logic works, but its state is being overridden by a subsequent transaction. The anchor and head aren’t being voluntarily cleared by the plugin; they’re being replaced due to a conflict in selection handling. To fix the issue, one must ensure that the Shift+Click does not bubble into a second selection command. This may involve adjusting event propagation (so that the plugin’s mousedown handler fully prevents the default click) or modifying NodeView behavior to not steal focus or initiate its own selection change during range selection. By addressing that duplicate transaction, the anchor/head state should persist across range expansions, allowing continuous multi-block highlights through Shift+Click and Shift+Arrow as intended.