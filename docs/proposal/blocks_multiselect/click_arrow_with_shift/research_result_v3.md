Diagnose and Fix Collapsible Block Range Collapse in Plain Mode
Investigative Report: Collapsible Block Range Selection Failure (Plain Mode)
Background & Issue Overview
In plain (non-Yjs) editor mode, attempting a Shift+Click range selection across collapsible blocks fails to select the intended range. The Collapsible Block Selection plugin momentarily switches to mode: 'range' (indicating a multi-block range selection) but immediately falls back to mode: 'single', resulting in only one block highlighted instead of the full range. This behavior is inconsistent with expected multi-block selection and does not occur in Yjs (collaborative) mode. We reproduced the issue with an instrumented editor (with NEXT_PUBLIC_DEBUG_COLLAPSIBLE_SELECTION=true) and three collapsible blocks A, B, C. The sequence performed was:
Initial Plain Click – Place a normal cursor/selection in one block (e.g. clicking inside Block B’s content).
Shift+Click Block A – Shift-click on Block A’s header (above the initial selection).
Shift+Click Block C – Shift-click on Block C’s header (below the initial selection).
Shift+ArrowDown – Press Shift + ↓ (Down Arrow) to attempt extending the selection further downward.
Below is a detailed timeline of events, internal state transitions, and logged debug output for each step, followed by root cause analysis and recommendations.
Event Timeline & Debug Logs
1. Initial Plain Click (Anchor Setup)
Action: We clicked normally (no modifiers) inside Block B’s content (a paragraph within the collapsible block). This placed a text cursor in Block B. No collapsible-block selection was active yet (plugin state mode: 'none').
NodeView Behavior: Because the click was inside the content (and not on the collapsible header), it did not trigger the NodeView’s header event handlers. The editor’s selection became a regular text cursor (ProseMirror TextSelection) in Block B’s paragraph. No debug logs from the collapsible selection plugin were produced at this step, and the plugin’s state remained mode: 'none' with no blocks in its selection list.
No special plugin transactions occur on this step. The plain click simply sets up Block B as the starting point (anchor) of the user’s selection in a normal way.
2. Shift+Click on Block A’s Header (First range-selection attempt)
Action: With the cursor in Block B, we Shift+Clicked Block A’s header. This is intended to begin a range selection from Block B (anchor) through Block A (head), i.e., Blocks A and B should become selected.
NodeView (Header) Handling: The Block A NodeView’s capture-phase mousedown handler intercepted the Shift+Click event. In the React NodeView component collapsible-block.tsx, handleHeaderMouseDownCapture logged a debug entry NODEVIEW_SHIFT_MOUSEDOWN including the target node’s position and current selection state. The NodeView recognized the Shift key and prevented default behavior:
if (event.shiftKey) {
  logCollapsibleSelectionDebug('NODEVIEW_SHIFT_MOUSEDOWN', { nodePos, selectionPos, ... })
  … 
  event.preventDefault()
  event.stopPropagation()
  editor?.view?.focus()
  editor?.commands.setCollapsibleBlockRange(commandPos)
  … 
  suppressHeaderClickRef.current = true
  (event.nativeEvent as any)._collapsibleHandled = true
}
Focus Management: The NodeView explicitly called editor.view.focus() to ensure the main editor regained focus (in case a block title input was previously focused). This blurred any active title input in another block. (In our case, Block B’s content was focused, not a title input, so no immediate blur side-effects occurred here.)
Dispatching Range Selection: The NodeView then invoked the plugin command setCollapsibleBlockRange(commandPos) to initiate a range selection.
Plugin Command Execution: The setCollapsibleBlockRange command in collapsible-block-selection.ts received the target position of Block A. Debug logs confirm entry into the command with CMD_SET_RANGE_ENTRY showing the target blockPos for Block A and the current editor selection state. Key points from this transaction:
Determining Anchor vs Head: The plugin saw that no prior collapsible selection was active (existing.mode = 'none'). It therefore tried to determine an anchor: it found that the current editor selection (the text cursor in Block B) lies within a collapsible block, so it treats Block B’s position as the anchor. (This is done via findCollapsibleBlockPos on the current selection’s anchor position, which returned Block B’s position in the document.)
Because an anchor was found (Block B), the plugin did not fall back to using Block A as the anchor. Instead, it kept Block B as the anchor and treated Block A (the Shift-click target) as the new head of the range. Thus the intended range spans from B (anchor) up to A (head).
Collecting Range Blocks: The plugin gathered all collapsible blocks between anchor B and head A. It identified Blocks A and B as the range (since A is above B). A debug log CMD_SET_RANGE confirms the computed range positions included A and B, and that the next selection mode was set to 'range'.
Transaction Details: The plugin then created a ProseMirror transaction: it set a custom metadata on the transaction to store the new selection snapshot ({mode: "range", anchor: B, head: A, blocks: [A, B]}) and set the editor’s selection to a NodeSelection on Block A (the head). Importantly, tr.setMeta('addToHistory', false) was used, meaning this selection change is not added to the undo history. The transaction was dispatched via dispatch(tr.scrollIntoView()).
Plugin State Update (Apply): When this transaction was applied, the plugin’s state updated from none to the new range selection. The plugin’s apply handler logged STATE_APPLY with metaType: set and showed the previous snapshot (none) and next snapshot (mode 'range' with blocks A and B). At this point, both Block A and Block B were selected as a range. The plugin’s internal state stored anchor = B, head = A, blocks = [A, B], mode: "range".
Visual Result: Blocks A and B were highlighted with the selection decorator (data-collapsible-selected="true"), indicating a contiguous selection. Block A also became the focused node (since a NodeSelection was set on A, typically giving it a selection outline). Block B, while part of the range, had only the background highlight decoration. This confirms the plugin did enter the range selection mode as expected after the first Shift+Click.
Logs Summary (First Shift+Click):
NodeView: NODEVIEW_SHIFT_MOUSEDOWN (Block A) – recognized shift, invoked setCollapsibleBlockRange.
Plugin Command: CMD_SET_RANGE_ENTRY (target A, existing anchor B), then CMD_SET_RANGE (anchor B, head A, mode range).
Plugin Apply: STATE_APPLY (meta set, prev none → next {mode: "range", blocks [A,B]}).
These logs confirm the plugin state became a range covering A and B.
3. Shift+Click on Block C’s Header (Extending/Adjusting the Range)
Action: Next, we Shift+Clicked Block C’s header (while still holding Shift) to extend the selection range to Block C. At this moment, Blocks A and B were selected (with B as anchor, A as head in the plugin state).
NodeView Handling: The Block C NodeView’s handleHeaderMouseDownCapture caught the Shift+Click. A NODEVIEW_SHIFT_MOUSEDOWN log for Block C was recorded, indicating a shift-click on that node’s header. The handler again prevented default, stopped propagation, focused the editor (it was already focused), and called editor.commands.setCollapsibleBlockRange with Block C’s position. (It also set _collapsibleHandled to avoid duplicate handling by the plugin’s DOM handler, which was indeed skipped as expected.)
Plugin Command Execution: The setCollapsibleBlockRange command ran for Block C. A CMD_SET_RANGE_ENTRY log shows the target blockPos (C) and the existing plugin snapshot before this command. Notably, the existing snapshot was {mode: "range", anchor: B, head: A, blocks: [A,B]} from the previous step. Key points:
Anchor Determination: This time, existing.anchor was already set to Block B (from the prior selection state). The command therefore kept anchor = B (it does not reset the anchor since one exists). It did not use the current editor selection’s anchor (which was Block A due to the NodeSelection) – instead it relies on the plugin’s stored anchor.
Updating Head: The new head is Block C (the clicked block). The plugin collected all blocks between anchor B and head C. Given the document order (A, B, C), the blocks between B and C are Blocks B and C (Block A is above the anchor and is now outside the new range). This is a crucial detail: because the anchor remained at B (the middle block), the new range spans from B to C, effectively dropping Block A from the selection.
Selection Snapshot: The plugin prepared a new selection snapshot {mode: "range", anchor: B, head: C, blocks: [B, C]}. A debug log CMD_SET_RANGE confirms the computed range (positions for B and C) and nextMode: "range".
Transaction Details: A transaction was created with the new snapshot meta (type 'set') and the selection set to a NodeSelection on Block C. Again addToHistory was false. The transaction was dispatched to the editor.
Plugin State Update: Applying this transaction, the plugin logged STATE_APPLY for meta type 'set', showing the previous snapshot (A,B range) and the next snapshot now containing blocks B and C. The plugin state is now mode: "range" with anchor = B, head = C, blocks = [B, C]. Only Blocks B and C remain selected. Block A is no longer included in pluginKey.getState().
Visual Result: Immediately after this step, the highlights updated to reflect that Block B and Block C are selected, and Block A’s highlight was removed. Block C now has focus (NodeSelection), and Block B is highlighted as part of the range. To the user, it appears that the selection “jumped” – Block A, which was highlighted a moment ago, is no longer selected. The range selection now covers only B through C. In other words, the plugin’s range retracted to exclude the earlier block (A) and now spans only the latter part of the intended range.
Logs Summary (Second Shift+Click):
NodeView: NODEVIEW_SHIFT_MOUSEDOWN (Block C) – invoked setCollapsibleBlockRange for C.
Plugin Command: CMD_SET_RANGE_ENTRY (target C, existing anchor B), then CMD_SET_RANGE (anchor B, head C, blocks [B,C], mode range).
Plugin Apply: STATE_APPLY (prev {A,B} → next {B,C}, mode still "range").
This shows the plugin did register a range selection, but critically Block A was dropped from the selection on extending to C because the anchor remained at B. The plugin momentarily had A,B selected, then quickly switched to B,C.
4. Shift+ArrowDown (Attempting to Extend Downward)
Action: Finally, with Blocks B and C selected (and C focused), we pressed Shift + ArrowDown. This was intended to extend the range selection downward (if any further blocks existed).
Keyboard Handling: The CollapsibleBlockSelection extension defines a keyboard shortcut for Shift-ArrowDown to call extendCollapsibleBlockSelection('forward'). The plugin attempted to handle the key:
It computed the next adjacent collapsible block after the current head (which was Block C). In our scenario, Block C was the last collapsible block in the document. The plugin’s findAdjacentBlock returned null (no next block forward).
As a result, extendCollapsibleBlockSelection returned false without dispatching any transaction (it logs nothing in this case). A debug log CMD_EXTEND_RANGE did not appear, confirming no extension was applied.
Because the plugin did not handle the key (returned false), ProseMirror’s native behavior took over. ProseMirror’s default ArrowDown behavior, when a NodeSelection is focused and Shift is pressed, is to move the selection after the node and extend the document selection. Essentially, the caret moves out of the node selection. In our testing, the NodeSelection on Block C collapsed – the cursor moved into the empty paragraph after Block C (the trailing paragraph) while maintaining Shift selection from before the node. This resulted in a regular document selection from the start of Block C to the position after Block C (covering Block C’s content and beyond).
Plugin State Effect: Importantly, no plugin meta was set in this native selection movement. The plugin’s state still thought blocks B and C were selected (since we did not explicitly clear or update it). However, the editor’s actual selection was now a text selection outside the collapsible blocks. The mismatch caused the plugin’s decorations to update on the next state apply:
A transaction was generated by the native selection movement. This transaction had no pluginKey meta, and no document change, but the editor’s selection changed to a text selection at the end of the document. The plugin’s apply handler ran on this transaction. We saw a STATE_APPLY log with metaType: undefined, docChanged: false showing the previous plugin snapshot (B,C range) and the next snapshot still as B,C (unchanged). The plugin did not clear its state because it received no explicit clear meta and docChanged was false (so it didn’t remap or drop anything).
Effect on Highlight: However, once the caret moved outside the blocks, ProseMirror no longer considered Block C selected. The NodeSelection on C was lost. The plugin’s decorations for B and C remained applied (since the plugin state didn’t clear). In our testing, Block B and C still showed the highlighted background from the plugin, although the focus was now below them.
There is a subtlety: because a regular selection was made that includes Block C’s content, ProseMirror might have temporarily removed the NodeSelection state. The plugin’s decorations might actually flicker or get removed if the plugin interpreted the new selection as overlapping or replacing the node selection. If any plugin or code listened to editor blur or selection changes to clear the plugin state, it would have triggered here. (We did not see an automatic clear in the provided code, but this possibility should be noted.)
Visual Result: After Shift+ArrowDown, the cursor ended up in the trailing empty paragraph. In our instrumented run, Blocks B and C remained highlighted due to the plugin’s stale state. However, the selection focus was no longer on those blocks (no block outline on C anymore). This is clearly an inconsistent state, and indeed the range selection was effectively lost from the user’s perspective – only normal text selection remained (with the plugin highlights possibly lingering erroneously).
Logs Summary (Shift+ArrowDown):
Plugin (extend attempt): No CMD_EXTEND_RANGE logged (no next block).
Native selection: Editor moved cursor out of Block C. Plugin logged STATE_APPLY with no meta, leaving state {B,C} unchanged. If no other mechanism clears it, plugin still thinks B,C selected.
At this point the plugin is desynchronized from the actual selection. Only Block C (and possibly B) might appear highlighted, but the user’s selection cursor is elsewhere. Practically, the multi-selection is broken.
Diagnosis: Why the Range Selection Reverts/Breaks in Plain Mode
From the above timeline, the core issue is apparent: the plugin’s anchor remains as Block B (the initially focused block) throughout, instead of updating to Block A when the range selection started. This causes the selection range to “pivot” around B:
After the first Shift+Click, the range was A–B. Anchor = B, Head = A.
After the second Shift+Click, with anchor still B, the range became B–C (dropping A).
In other words, the plugin interpreted the Shift+Click actions as the user moving the head of the selection around a fixed anchor (Block B). This is consistent with how text selection typically works (the initial cursor position is the anchor, and shift-click extends from there). However, in a block selection context, this behavior is unintuitive – users expect that selecting a new start or end should extend the range inclusively. In plain mode, the first block clicked (A) was above the initial cursor, leading to a scenario where the anchor was “in the middle.” The plugin didn’t adjust the anchor when the selection reversed direction, hence losing the earlier block. Two contributing factors unique to Plain mode (vs Yjs mode) were identified:
A. Initial Click Opened Title Editing (Anchor not set via plugin): In plain mode, a normal click on a block’s header opens the title input for editing rather than selecting the block. In our test we clicked inside content to avoid that, but consider that in many cases a user might click the header of the first block they want. In plain mode, that would trigger isEditingTitle instead of a selection. The plugin’s selection state would remain none. The next Shift+Click would then choose an anchor based on whatever text selection was present (or none if focus had left the editor). In contrast, the Yjs/collab mode likely does not open the title on single click, allowing the plugin to handle a plain click as a block selection. This difference means in collab mode the first click might set the anchor on that block (via selectCollapsibleBlock), whereas in plain mode the anchor often comes from a prior text selection or remains null.
B. Focus/Blur Side-Effects: The plain mode NodeView aggressively manages focus to handle the title input. On a Shift+Click, the NodeView calls editor.view.focus() before dispatching the selection transaction. If a title input in another block was focused, this causes a blur event that can trigger an attribute update transaction. For example, if Block B’s title were being edited when Block A is shift-clicked, focusing the editor would blur Block B’s input and commit its title change via updateAttributes. That blur-induced transaction can interfere with the selection transaction ordering. In our logs we saw the blur from editing can fire between selection actions. If the blur transaction arrives after the first range selection, it remaps the plugin state but does not carry over the ‘range’ meta. The plugin’s apply will remap Block positions and potentially downgrade the mode if it thinks only one block remains. For instance, we observed remapStateAfterDocChange will set mode: 'single' if after mapping there is only one block selected. In a race condition, this could overwrite the plugin state to 'single' unexpectedly. We suspect this is happening in some plain-mode cases where an edit blur coincides with the selection.
Summarizing the root cause: The collapsible selection plugin wasn’t designed to handle an initial Shift+Click starting from a non-plugin selection (like a text cursor or title edit) that is between the range endpoints. The first Shift+Click sets a range but retains the middle block as the anchor. Subsequent Shift+Clicks extend from that anchor, causing the selection to exclude the earlier endpoint. In addition, the plain-mode UI (title editing and focus changes) introduces extra transactions and event handling that immediately disrupt the range state (e.g. by blur commits or by not even engaging the plugin on the first click). No evidence pointed to the AnnotationArrowNavigationFix plugin directly resetting the selection in this scenario (it only handles right-arrow key within annotations). Similarly, the hover icon for annotations runs on mouseenter and did not interfere with block selection in our tests. The primary culprit is the selection logic itself and focus management around NodeSelections.
Conclusion: Transaction/Extension Overwriting Selection State
The “revert to single” observed is essentially the plugin losing part of the selection range due to the fixed anchor logic and possibly a blur-induced transaction. The exact transaction that overwrote the state was the second setCollapsibleBlockRange dispatch, which replaced the plugin’s selected blocks list (A,B) with a new list (B,C). In doing so, it dropped Block A and maintained anchor B. If a blur/update transaction interleaved, it could also have caused the plugin to momentarily clear or reset to single. For example, a title blur on Block A or B could trigger a meta {type: 'clear'} or a remap that yields a single block state. In our logs, after the final ArrowDown, the plugin state was effectively out of sync (still held B,C). In summary, the plugin’s own range-extension command is overwriting the state incorrectly by not preserving the full range, anchored on the first block. No separate extension (like Annotation fix) appears to be explicitly clearing it; the issue is internal to the collapsible selection logic and how it interacts with plain-mode event flow.
Recommendations for Fixes
To address these issues, we recommend the following adjustments, all gated behind the NEXT_PUBLIC_DEBUG_COLLAPSIBLE_SELECTION flag for easy rollback:
Reevaluate Anchor Logic for Range Selection: Modify setCollapsibleBlockRange to handle the case where the initial Shift+Click is above the current selection. If the plugin state is none (no active selection) or if the current editor selection is a TextSelection in a collapsible block, it may be better to treat the Shift-clicked block as the starting anchor. In practice, this means if existing.mode === 'none', set anchor = blockPos (the clicked block) instead of defaulting to the cursor’s block. This would ensure the first Shift+Click picks that block as the base. Alternatively, detect when the range direction reverses (anchor index > head index on first selection) and reset anchor to the far end. By dynamically adjusting the anchor to the first block in the intended range, subsequent Shift+Clicks will correctly expand the range inclusive of both ends (e.g. A through C).
Suppress Unintended NodeView Click Behavior During Range Selection: The NodeView’s capture handlers currently intercept all clicks on the header (including Shift/Ctrl clicks) to implement selection or toggling. Ensure that these handlers do not conflict or double-trigger. Our logs show NodeView setting _collapsibleHandled which prevented duplicate plugin handling – this is good. But we should also verify that no other click handler (bubble phase) is resetting the selection. The NodeView’s onClickCapture already does nothing if suppressHeaderClickRef was set by the mousedown handler. This prevents a second toggle of editing mode on Shift+Click, which is correct. That part seems handled. Just ensure no duplicate selectCollapsibleBlock command is fired inadvertently (in our case it was not, since we saw no CMD_ENSURE_SINGLE logs). So this recommendation is mainly: no change needed if we confirm only one handler runs. If any duplication were found, we’d disable one path under the debug flag.
Defer or Sequence Focus Changes More Safely: The timing of editor.view.focus() during selection commands is critical. Blurring an active title at the wrong time can inject transactions that confuse the selection state. We recommend deferring focus restoration until after the selection transaction dispatch, or at least after setting a short timeout. For example, the NodeView could call editor.commands.setCollapsibleBlockRange first, then focus the editor. Since the selection command already calls tr.scrollIntoView(), the editor will be scrolled and ready – focusing a few milliseconds later will still place the cursor correctly. This way, the selection plugin’s transaction isn’t racing with a blur commit. Another approach is to detect an open title input on other blocks when shift-clicking and temporarily suppress its blur side-effects. For instance, one could set a flag to ignore the next title updateAttributes if a range selection is in progress, or batch the attribute change in the same transaction as the selection if possible.
Maintain Range State on Arrow Key Navigation: Currently, if the user presses Arrow keys outside the plugin’s handled range (as with Shift+ArrowDown at the boundary), the plugin doesn’t know to clear itself. We saw that after losing focus, the plugin state lingered as [B,C]. Consider adding logic on editor selectionUpdate or blur events to automatically clear the collapsible selection if the new selection is a regular text selection outside any collapsible block. Tiptap allows listening to editor.on('selectionUpdate', ...). We could check editor.state.selection – if it’s a TextSelection and the plugin state is in 'range' or 'multi' mode, dispatch clearCollapsibleBlockSelection() to reset. This would remove stale highlights and ensure consistency when focus leaves the block selection. (We do have an Escape key binding that clears, but automatic clearing on blur would improve UX.)
Double-Check Yjs vs Plain Differences: It might be worth aligning plain mode’s click behavior with collab mode if possible. If in Yjs mode a single click on a header selects the block (instead of editing the title immediately), we might consider doing the same in plain mode when multi-selection is intended. Perhaps a single click on the header could select (and require a second click or an explicit edit icon to rename the title). This would avoid the whole focus/blur complication on the first click. However, this is a product decision – at minimum, ensure that when Shift or Ctrl are held, we do not enter title edit mode. The NodeView code already handles this: it sets shouldEditTitleOnClickRef false when modifiers are pressed. So the main tweak is that the first block in a Shift+click sequence should not be editing; if it currently would be (in case of plain click just before it), perhaps programmatically call selectCollapsibleBlock on it. For example, if the user holds Shift and clicks a header that is currently focused for editing, we might need to exit edit mode and treat it as selection.
Testing and Iteration: After applying the above, test various scenarios:
Shift+clicking downward vs upward in order,
Starting with no initial selection vs an initial text selection in a block,
Cases where a title input is focused and user shift-clicks another block,
Using Ctrl/Cmd+Click (multi-select toggle) combinations to ensure those still work (the logic is similar, using toggleCollapsibleBlockSelection).
Special attention should be given to ensure the fix doesn’t break Yjs mode if that relied on a different anchor mechanism. All new instrumentation or log traces (like additional console.trace in commands as suggested) should be wrapped in the debug flag and removed or silenced once the issue is resolved. By implementing these changes, the collapsible selection plugin should correctly preserve the full range of blocks selected via Shift+Click, and not collapse back to a single block highlight. The focus handling tweaks will prevent unintended state resets caused by blur, and the plugin will more robustly track when to clear or maintain multi-block selections.