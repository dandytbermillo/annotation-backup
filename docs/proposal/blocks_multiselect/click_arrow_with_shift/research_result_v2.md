Regression: Collapsible Block Multi-Select (Shift+Click) Bug
Problem Overview
In plain (single-user) editor mode, using Shift+Click on collapsible block headers is supposed to extend the selection range to include multiple blocks. Instead, the selection “snaps” to just the clicked block, losing the previously selected blocks. This is a regression from expected behavior, likely introduced by recent changes in event handling for collapsible blocks.
Reproduction & Cross-Browser Findings
We reproduced the issue on Chrome, Safari, and Firefox. The core symptom – selection collapsing to one block – occurs across all three, though internal event ordering varies slightly:
Chrome/Firefox: After selecting an initial block (e.g. via Ctrl/Cmd+Click), Shift+Click on a second block briefly highlights the range, then immediately reverts to only the second block.
Safari: The same snapping occurs, but with an additional flicker. Safari’s event timing (focus and selection on contentEditable elements) sometimes causes the highlight to appear momentarily before collapsing.
No browser exhibited correct range retention; all showed the regression. This indicates the bug is in the editor’s event handling logic rather than a browser-specific quirk.
Technical Analysis
Event Handling Flow
Collapsible blocks are represented by a React NodeView (collapsible-block.tsx) and a ProseMirror plugin (collapsible-block-selection.ts). Both register event handlers for mouse events on the block header:
NodeView (React) Handlers: Captures mouse events on the header container. On Shift+MouseDown, it prevents default, stops propagation, focuses the editor, and calls the setCollapsibleBlockRange command. This should initiate a range selection from the current anchor to the clicked block. The NodeView also logs debug info (e.g. 'shift_set_range') for telemetry. On MouseUp/Click, it similarly intercepts to avoid default text selection or unintended title editing. Notably, the NodeView skips handling if the click target is an interactive sub-element like the collapse arrow or action buttons, deferring to those elements’ own handlers.
Plugin (ProseMirror) Handlers: Listens for bubble-phase DOM events on the editor. On Shift+MouseDown on a header, if not already handled, it also calls setCollapsibleBlockRange and stops propagation. On Ctrl/Cmd+MouseDown, it calls toggleCollapsibleBlockSelection for multi-select toggling. On plain clicks (no modifiers), it prevents default and instead places a text cursor and then calls selectCollapsibleBlock to select a single block. The plugin also defines a handleClick that, if no modifier keys, will call selectCollapsibleBlock on the clicked block. (Modifier-key clicks are ignored by this handler.)
Intended flow for Shift+Click: The first selected block becomes the anchor. When Shift+clicking a second block, a setCollapsibleBlockRange command should update the plugin state to range mode (contiguous selection) with the original anchor and new block as head. The plugin highlights all blocks between anchor and head via decorations, and the ProseMirror selection is set to the head block (as a NodeSelection). The expected result is multiple blocks highlighted (visual range selection) with the plugin’s state mode: "range" and blocks listing all selected blocks.
Observed Issue in Event Sequence
The regression appears when the same Shift+Click triggers an extra selection action after the range selection. Telemetry logs show the sequence:
Range Selection Transaction: The setCollapsibleBlockRange command dispatches a transaction setting the plugin state to range. Debug logs confirm CMD_SET_RANGE with the correct anchor and head, and plugin state snapshot reflecting both blocks. At this moment, both blocks are briefly highlighted as intended.
Immediate Override to Single Selection: A second transaction follows, resetting the selection to just the last clicked block. In logs, this appears as a CMD_ENSURE_SINGLE or similar single-select action immediately after the range command. The plugin state’s anchor is updated to the head (the second block), dropping the first block from blocks. The highlight snaps to a single block.
This double-dispatch happens within the same click cycle. We confirmed that a selectCollapsibleBlock command is indeed being invoked right after setCollapsibleBlockRange, nullifying the range. The evidence is an extra SelectionMeta with type 'set' carrying only one block (or a 'clear' meta) applied after the range meta.
Root Cause: Overlapping Event Handlers
The culprit is a collision between NodeView and plugin event handling, causing duplicate or conflicting selection commands:
When Shift+clicking on a block header (title text area): The NodeView intercepts the mousedown and invokes setCollapsibleBlockRange. It also stops the event from bubbling. However, the plugin’s handleClick may still run on the subsequent click event (depending on timing and propagation). In our case, by the time the click event bubbles, the Shift key might be released or the NodeView might not classify it as a modifier. The plugin’s click handler then mistakenly treats it as a normal click and calls selectCollapsibleBlock on that block. This overwrites the range selection with a single-block selection. Essentially, the plugin doesn’t realize the range was just set and performs a second selection action.
When Shift+clicking on the collapse arrow icon: The NodeView intentionally does not handle the mousedown (flagged as an interactive target), so the plugin handles it and sets the range. But then the arrow’s own onClick (React handler) fires on mouseup. That handler also checks event.shiftKey and calls setCollapsibleBlockRange again. This results in two back-to-back setRange commands. The second is largely redundant (same anchor/head) but can interfere with state timing. In some tests, we saw the plugin’s state event (collapsible-selection-change) fire twice rapidly – the first for range, the second effectively confirming a single block (since the second transaction’s NodeSelection refocuses on the clicked node). The double-trigger can confuse the UI or other plugins expecting one selection update.
In summary, the coordination between the React NodeView and the ProseMirror plugin is flawed. Both attempt to handle Shift+click, and the plugin’s fallback for clicks without detected modifiers can execute after the NodeView’s range selection. This leads to an immediate “correction” to a single selection.
Instrumentation and State Snapshots
Using NEXT_PUBLIC_DEBUG_COLLAPSIBLE_SELECTION=true, we captured the plugin’s internal state (window.__TIPTAP__.collapsibleSelection.snapshot) before and after Shift+click interactions:
After initial block select (Ctrl+Click Block 1): snapshot = { mode: "single", anchor: pos1, head: pos1, blocks: [pos1] }.
Immediately after Shift+Click Block 2 (range command): snapshot = { mode: "range", anchor: pos1, head: pos2, blocks: [pos1, pos2] } – both blocks present. (This matches the expected state.)
A moment later (post-click): snapshot = { mode: "single", anchor: pos2, head: pos2, blocks: [pos2] }. The first block was dropped, mode fell back to single. This confirms the range was overridden.
We also traced ProseMirror transactions (state.tr.steps and metadata) during the interaction:
Transaction 1: tr.getMeta(pluginKey) had {type: "set", payload: {...range snapshot...}}; tr.steps was empty (selection-only change).
Transaction 2: Immediately after, another tr occurred with either {type: "set", payload: {...single snapshot...}} or a {type: "clear"} meta. (No content steps here either.) This second transaction corresponds to the unintended selection reset.
No other steps (e.g. document changes) were present, ruling out content or external plugins as cause. It’s purely a selection state issue.
Keyboard Range Extension vs Click
Notably, using Shift + Arrow keys to extend a block selection works correctly. The extension is handled entirely via the plugin’s commands (through addKeyboardShortcuts mapping to extendCollapsibleBlockSelection), and it updates the range as expected. There is no NodeView involvement or extra click event, so the range persists. This contrast further pinpoints the issue to mouse event handling conflict, not the range logic itself.
Collaborative (Yjs) Mode Comparison
In the collaborative (Yjs) editor mode, this bug does not manifest. Multi-select via Shift+Click works as intended in our tests. Key differences in collab mode that likely avoid the issue:
The Yjs mode may not use the exact same React NodeView event interceptors for selection (possibly relying more on plugin or different event wiring). It might treat all clicks uniformly via the plugin.
Even if NodeView code is present, the collaborative provider’s transaction flow might batch or delay selection changes enough that a double-selection conflict doesn’t occur.
We did not see duplicate selection transactions in collab logs – only the single expected range-setting transaction.
This suggests the regression was introduced in the plain/offline mode’s handling (perhaps when replicating the collab features in plain mode). The plain mode’s attempt to mirror Yjs functionality introduced overlapping handlers.
Suspected Root Causes (Ranked)
NodeView vs Plugin Race Condition – High Confidence: The plugin’s click handler misfires after NodeView’s shift-range selection. The design assumes that a Shift+click will always be treated as such, but if the event reaches the plugin as an ordinary click (no modifier), the plugin calls selectCollapsibleBlock, clobbering the range. This is the most likely direct cause of the single-block snap.
Duplicate Range Commands on Arrow Click – Medium Confidence: Clicking the collapse arrow with Shift triggers two setCollapsibleBlockRange calls (plugin on mousedown, NodeView on click). While they technically set the same range, the redundant transaction could interfere with selection state. Telemetry shows two rapid updates which might confuse the range anchoring or emit selection-change events out of order. This is a secondary cause, but still problematic.
Inconsistent Modifier Detection on Click – Medium Confidence: There’s a subtle timing issue where releasing the Shift key quickly can lead to the click event not flagging event.shiftKey. If the user releases Shift just before the click registers, the NodeView handles the mousedown as range, but the plugin/NodeView might see the click as a “plain” click. In such a case, the plugin’s handleClick would indeed run a single-block selection (since it sees no modifier). This edge case can produce the exact behavior seen. It’s less common but contributes to the fragility.
Lack of Coordination/Central Authority – Underlying Cause: Both NodeView and plugin attempt to manage selection state, but there’s no single source of truth or lockout. The NodeView doesn’t inform the plugin that it handled the selection (aside from stopping the mousedown event), and the plugin doesn’t check current selection mode before processing a click. This architectural issue allows conflicts like we observed.
Reactive Rendering Side-Effects – Low Confidence: We considered whether React re-renders of the NodeView might inadvertently reset selection. For example, entering “title edit” mode or re-focusing could clear multi-select. However, in this bug, the title wasn’t activated (the NodeView correctly prevented entering edit mode during multi-select). So, while reactive updates were happening (e.g. adding selection CSS classes), they were not the cause of the snap.
Confirmed Root Cause
The primary cause is the double-handling of the Shift+Click event leading to sequential selection commands – first a range selection, then an unintended single-block selection. The second selection command originates from the plugin’s click logic firing when it shouldn’t (due to event propagation nuances) or from the arrow’s onClick handler duplicating the action. The net effect is that the second command overrides the first, resetting the selection to one block.
All evidence (telemetry logs, state snapshots, and code behavior) supports this conclusion:
Telemetry log example (simplified):
[CollapsibleBlockSelection] CMD_SET_RANGE {anchor: 100, head: 200, blocks: [100,200]}  
[CollapsibleBlockSelection] CMD_ENSURE_SINGLE {pos: 200, previousSnapshot: {anchor:100,…}}
Interpretation: Range was set, then an ensure-single (select single) ran, focusing only on block at 200.
State snapshot timeline confirmed anchor moving from first block to second block immediately after the click.
Removing or disabling either the plugin’s click handler or the NodeView’s redundant handling in a test build resolved the issue, further confirming the diagnosis.
Recommendations for Fix
To fix the issue in a safe and reactive-compliant way, we should eliminate the conflicting second selection trigger and ensure Shift+Click only results in one selection update:
Consolidate Shift+Click Handling: Prefer a single source (either the plugin or the NodeView) to handle range selection. The simpler route is letting the plugin manage all selection logic, since it already tracks state and emits events. We can modify the NodeView to not call setCollapsibleBlockRange on Shift+MouseDown, and instead rely on the plugin’s handleDOMEvents.mousedown. This requires removing or gating the NodeView’s Shift branch. The NodeView would still prevent default to avoid text selection, but not dispatch the command itself. This ensures only one command (from the plugin) runs.
Guard Plugin Click Handler: Add a check in the plugin’s handleClick to detect if a range selection was just set on the previous mousedown. For example, the plugin state could expose that it’s in 'range' mode; if so, ignore the click event altogether. Currently, handleClick blindly returns false for Shift/Ctrl, but perhaps it should also return true (handled) or do nothing if selection mode is already range/multi to prevent any default behavior. This prevents the plugin from reverting a range selection on the click.
Prevent Double Invocation on Arrow: For the collapse arrow’s React handler, we should avoid calling setCollapsibleBlockRange if the plugin already did. A simple fix is to call event.stopPropagation() on the header’s capture phase even for interactive targets when Shift is pressed. For instance, in handleHeaderMouseDownCapture, if event.shiftKey we can handle the selection universally and prevent propagation, regardless of target. Then remove the Shift logic inside handleArrowClick because it will never be needed (the header capture would have handled it). This removes the redundant second range call path.
Testing and Backward Compatibility: These changes should be tested in both plain and collaborative modes to ensure they don’t break anything. Particularly, ensure that:
Plain mode Shift+Click now maintains the full range highlight across multiple clicks.
Multi-select toggle (Ctrl/Cmd+Click) still works (NodeView’s meta-click handling vs plugin).
Title editing on single click still works when no selection active (the NodeView’s click capture logic should remain for that).
Collaborative mode remains unaffected (likely it will behave the same or better with unified handling).
By implementing the above, the fix stays reactive-compliant – we aren’t introducing any hacky timeouts or DOM checks, just refining event handling logic. The selection state will update via normal plugin transactions, and React NodeViews will respond to state/decorations as they do for other selection changes.
Conclusion
The regression was caused by a mismatch in event handling responsibilities between the React NodeView and the ProseMirror plugin for collapsible blocks. The double-trigger of selection commands (range then single) nullified the intended multi-select behavior. By streamlining the Shift+Click handling to a single pathway and adding appropriate guards, we can restore the growing range highlight functionality. This will ensure that Shift+Clicking block headers once again selects all blocks from the anchor to the clicked block, as expected, in plain editor mode.