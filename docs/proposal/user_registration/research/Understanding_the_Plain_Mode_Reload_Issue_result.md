Plain Mode Double Reload Issue Analysis
Understanding the Plain Mode Reload Issue
In plain mode (with Yjs disabled), the note content loading process relies on a custom offline provider and manual autosave logic. When you reload the page immediately after editing, a race condition can cause the app to display an outdated version of the note on the first load. Only after a second reload (once the latest save has definitely reached the server) does the correct content appear. Below is a step-by-step trace of the content flow and where things go wrong, followed by the root cause analysis and recommended fixes.
Content Save and Load Flow in Plain Mode
Autosave Process: As you edit the note, TiptapEditorPlain debounces input and periodically calls PlainOfflineProvider.saveDocument to persist changes. This save function optimistically updates the provider’s in-memory cache and then posts the content (with version numbers) to the backend (Postgres). On a normal timeline, the updated content is saved in Postgres and will be fetched on next load.
Pending Save on Unload: If you reload or close the tab before the last autosave completes, the app uses a backup mechanism. In the beforeunload or visibilitychange event, the editor writes the current content and metadata to localStorage (pending_save_{noteId}_{panelId}) and fires off an async save request without waiting for it to finish. In other words, the browser triggers saveDocument but “unload doesn’t wait for the network”. The local backup ensures your latest edits aren’t lost if the network save is interrupted.
Reload Content Loading: When the page is loaded again (in the same tab), the application initializes a fresh PlainOfflineProvider (with an empty in-memory cache) and the editor calls provider.loadDocument(noteId, panelId) to fetch the note content. Since this is plain mode (no Yjs), loadDocument will first check the provider’s cache and, finding nothing (the provider was re-created on reload), it falls back to the backend adapter’s data. This results in an HTTP GET to the server (/api/postgres-offline/documents/{noteId}/{panelId}) to retrieve the saved content.
Stale Data Returned: If the previous autosave didn’t complete before the reload (or was in flight and got canceled), then at this moment the server still has the older version of the document. As a result, loadDocument returns the last known content (missing your latest edits). The provider logs confirm that on reload it may load an older version if the “backup’s save hasn’t reached Postgres yet”. The editor then inserts this content into the TipTap instance (clearing the “Loading content…” state), so you end up seeing stale text from before your last edit.
Local Backup Restoration (delayed): The app does have your latest changes stored in localStorage from step 2, but it doesn’t apply them immediately on page load. A React effect in TiptapEditorPlain checks for a pending localStorage entry and, if found, attempts to restore it by calling provider.saveDocument with the backed-up content. This is essentially a client-side replay of the save that might have been missed. However, this restoration happens asynchronously after the initial content has been loaded into the editor. The code waits for the saveDocument promise to resolve before updating the editor state with the pending content. In practice, that means there’s a window where the editor is showing the stale content from step 4. Only once the backup save completes (posting the content to the server and updating the provider’s cache) does the editor state get set to the correct content. If the network request is fast, the content might update after a brief moment; but if not (or if the user doesn’t notice the silent update), the user perceives that the first reload still has the old text.
Second Reload (or waiting): By the time you refresh again, the last save will have reached the database, so the server now returns the latest content. The second reload therefore shows the correct text. In summary, the first reload was loading data from a stale source (server or cache), whereas the second reload pulls the now-updated data.
Why the First Reload Shows Stale Content
From the above flow, we can pinpoint the culprit as a race condition and caching mismatch during the reload:
Stale Server Data: The primary issue is that the first reload fetches from the server before the latest autosave is persisted. The provider’s cache was empty (new session), so it relied on the server and got an out-of-date version. In other words, the app is displaying exactly what the backend returned – which is stale because the most recent edits weren’t committed in time.
Local Backup Not Immediately Applied: Even though the latest content was saved locally, the logic to apply it kicks in only after the stale content is already rendered. The “pending-save restore” is conditional and delayed. It only runs if it detects that the provider’s content is stale, and even then it performs an async save then updates state. During that gap, the user sees the old content. If the user doesn’t realize an update is coming (there’s no loading indicator at that point), they might refresh again out of confusion. Essentially, the app did have the correct data (in localStorage) but didn’t use it to populate the editor on first load in a timely manner.
No In-Memory Cache Carryover: To clarify, the provider’s in-memory cache itself isn’t persisting stale data across the reload – it’s reinitialized on page load. The term “provider cache” in this context refers either to that in-memory map (which was empty on reload) or to other client-side caches. The stale content is coming from the server (or possibly a stored snapshot), not from a leftover in-memory value. So the bug is not that the provider intentionally served an old cached value; it’s that it had to fall back to an outdated source.
Canvas Snapshot Side-Effects: Compounding the problem, the application also restores UI state from a canvas snapshot on mount. This snapshot (stored in localStorage via canvas-storage.ts) includes panel layout and might include text metadata like panel titles or branch original text. If an old snapshot contains the note’s previous content (e.g. as an originalText for a branch or a panel preview), parts of the UI (tooltips, annotation overlays, etc.) could momentarily show that old content as well. For example, the sidebar or an annotation preview might use a stored snippet of the note text from last session, which hasn’t been updated yet. These snapshot artifacts are replaced once the provider fires its update events, but they can “briefly display stale text until the provider refresh arrives.”. This is a secondary factor – it means not only the editor, but also other UI elements, might show stale data on first load.
Event Timing: The provider does emit events (like document:saved or a conflict event) when it finishes saving or detects a newer version. In theory, one could use events like document:remote-update to refresh content. In this bug, however, the sequence of events isn’t fast enough to prevent the stale content flash. The app initially concludes loading as soon as the first loadDocument promise resolves (with stale data) and doesn’t await the pending-save’s completion. There is effectively a missing handshake to coordinate the backup restore before rendering content.
Root Cause Summary
In plain mode, the first page reload is pulling from a stale source (because the latest changes were not yet on the server) and the mechanism intended to correct that (the local pending-save restore) isn’t synchronized with initial render. The stale content issue is not because the provider is permanently stuck with an old cache; it’s because the app showed the user an old state while the real new state was still in transit. In short, this is a race condition between the autosave and the reload. The combination of “unload doesn’t wait for network” and immediate reload means the app initially loads an outdated document. The latest content was stored locally but only applied after a delay, resulting in the user seeing outdated text on that first reload.
How to Fix the Double-Reload Problem
To ensure the latest autosaved version loads on the first reload (and avoid needing a second refresh), we need to adjust the content loading and caching strategy. The goal is to deliver the up-to-date content to the editor immediately on reload. Here are the recommended code-level and lifecycle changes:
Promote the Local Backup Content Sooner: If a pending local backup exists and the server’s version is behind, the app should use the backup as the primary source on reload. In practice, this means modifying the reload logic to detect this scenario and inject the saved content before or alongside the remote fetch:
Version/Content Check: Include version or timestamp metadata in the pending_save payload (the code already plans for this) and compare it to the version fetched from the server. For example, if the local backup has changes that are not reflected in the loaded document (i.e. backup’s version is equal to or higher than the remote version, or simply if the backup content differs), treat the remote data as stale.
Synchronous Application: Immediately set the editor’s content to the pending backup without waiting for the network save. Essentially, trust the local copy as canonical if we know the server is lagging. The fix plan calls this “Pending Save Promotion” – when the local backup is newer, promote it immediately. In code, this could mean calling setLoadedContent(pendingContent) before or in parallel to the provider.saveDocument call, so the UI reflects the latest text right away. The provider can then finish pushing it to the server in the background. This way, the user never sees the outdated version on reload – either the content will appear correct from the start or update nearly instantly.
Avoiding Conflicts: If the backup promotion logic runs, we should also skip or carefully handle the normal loadDocument result. One approach is to delay finalizing the editor state until both sources are considered. For instance, you might initiate the server fetch but hold off on rendering its result for a moment: if the local backup is present and fresher, use that instead of the fetched data. This prevents the flicker from old to new. (The plan suggests possibly replaying the backup synchronously before snapshot restore runs.)
Cleanup: After applying the backup content, remove the pending_save entry from localStorage (to avoid re-applying it on every load) and update the in-memory version tracking. This ensures the provider’s version matches the content the user sees, preventing any further “stale document” save errors. (The current code already removes the backup on successful restore.)
Make Snapshot Restoration Content-Aware: To tackle the stale canvas snapshot data, update that system to avoid injecting outdated text:
The simplest solution is not to store full content or originalText in the snapshot at all (or to invalidate it on significant changes). The fix proposal suggests stripping text content from canvasItems before saving the snapshot, keeping only layout/state, and letting the live provider data populate the text. This “snapshot sanitization” would ensure that on reload, you don’t accidentally overwrite or mask the fresh content with an old cached string.
If for some reason the snapshot must include some text (for example, branch previews), implement a version guard: record the document’s last known version or save timestamp alongside the snapshot. On reload, compare it against the provider’s version. If the snapshot is older, skip using its text content. In practice, canvas-context.tsx could hold off on canvasDataStore hydration if it detects the provider has a newer version of the note. Only after the provider finishes loading (or issues a document:remote-update) should any UI elements use those text values. This prevents the UI from briefly showing stale originalText from the snapshot.
Additionally, consider applying the snapshot (restoring panel positions, etc.) after the editor content is loaded, not before. The proposed fix #2 suggests deferring snapshot application until the editor signals content is ready. This way, the visual layout comes back, but any text-related fields will by then have been updated by the provider.
Coordinate Provider Events (if needed): With the above changes, the content on first load should already be correct. However, it’s wise to ensure the app listens for any late-arriving updates:
If a conflict is detected (meaning the backup tried to save but the server already had a newer version), the provider might emit a document:remote-update or conflict event. The editor should listen for that and update accordingly (the code already attaches a handler for remote updates in plain mode). After our changes, conflicts should be rare – they would only happen if two saves were in flight – but the UI should still handle them gracefully (e.g., by choosing the latest version).
Ensure that no other component (parent panels, overlays) is using stale data after the provider has loaded. If some UI element still relies on a value from before (say, a note title or annotation context that wasn’t updated), explicitly refresh it once the document content is in sync. This may involve re-rendering components or clearing caches in the global store after the load completes. The plan’s “Parent-Child content flow” point is basically to let the editor drive the content loading, with others waiting for the editor’s completion event, to avoid any parallel fetch that could introduce stale data.
Improve Save Lifecycle (optional): Another angle is to reduce the chance of having an in-flight save at reload time:
The app already tries an async save on visibilitychange (when the tab is hidden) so that if you switch notes or tabs, it flushes the content. In addition, using techniques like navigator.sendBeacon for the unload save could help ensure the request is delivered even as the page unloads. This isn’t a complete fix (network latency can still make the reload beat the save), but it could narrow the window in which the server is out-of-date.
The team’s broader efforts like a sequential save queue and version bump guardrails will help in multi-save or multi-tab scenarios (preventing “stale document save” errors). While not directly the solution to the first-reload stale content, those changes ensure consistency: one save at a time and immediate conflict resolution if something was missed. Incorporating those will make the system more robust when implementing the backup promotion logic (so we don’t end up with two overlapping saves clobbering each other).
By implementing the above adjustments, the application will load the most recent content on the first try. In practice, after an edit, if you reload the page, the app will either fetch the up-to-date document from the server (if the save completed) or intelligently fall back to the locally saved content (if the server is behind), updating the editor before you notice anything is missing. This eliminates the need for a second refresh. The fixes also ensure that UI elements like annotations or previews do not flash old text, by only using provider-sourced content. In summary, the root cause was a timing/caching issue – the first reload showing stale data from an outdated source – and the cure is to tighten the content synchronization across the unload and reload cycle. By revalidating caches and prioritizing the latest known content (from local backup) during the reload, we can guarantee that the latest autosaved version is visible immediately on the first reload, resolving the double-reload problem. Sources:
Plain mode reload and pending-save behavior analysis
Proposed fixes for backup promotion and snapshot handling
Excerpts from PlainOfflineProvider and editor showing save/load logic
Tiptap plain editor handling of unload backup and restore