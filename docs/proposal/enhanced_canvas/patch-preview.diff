diff --git a/lib/canvas/canvas-storage.ts b/lib/canvas/canvas-storage.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/lib/canvas/canvas-storage.ts
@@
+import type { CanvasItem } from "@/types/canvas-items"
+
+const STORAGE_PREFIX = "annotation-canvas-state"
+const STATE_VERSION = "1.1.0"
+const LEGACY_KEY = STORAGE_PREFIX
+
+interface PersistedViewport {
+  zoom: number
+  translateX: number
+  translateY: number
+  showConnections: boolean
+}
+
+interface PersistedCanvasItem {
+  id: string
+  itemType: CanvasItem["itemType"]
+  position: CanvasItem["position"]
+  panelId?: string
+  panelType?: CanvasItem["panelType"]
+  componentType?: CanvasItem["componentType"]
+  dimensions?: CanvasItem["dimensions"]
+  minimized?: boolean
+  title?: string
+}
+
+export interface PersistedCanvasState {
+  noteId: string
+  viewport: PersistedViewport
+  items: PersistedCanvasItem[]
+  savedAt: number
+  version: string
+}
+
+function isBrowser(): boolean {
+  return typeof window !== "undefined" && typeof window.localStorage !== "undefined"
+}
+
+function storageKey(noteId: string): string {
+  return `${STORAGE_PREFIX}:${noteId}`
+}
+
+export function loadStateFromStorage(noteId: string): PersistedCanvasState | null {
+  if (!isBrowser()) return null
+
+  const candidates = [storageKey(noteId), LEGACY_KEY]
+
+  for (const key of candidates) {
+    const serialized = window.localStorage.getItem(key)
+    if (!serialized) continue
+
+    try {
+      const parsed = JSON.parse(serialized) as PersistedCanvasState
+      if (!parsed || typeof parsed !== "object") continue
+      if (!parsed.viewport || typeof parsed.viewport.zoom !== "number") continue
+      if (!Array.isArray(parsed.items)) continue
+      if (parsed.noteId && parsed.noteId !== noteId && key !== LEGACY_KEY) continue
+
+      return {
+        noteId,
+        viewport: {
+          zoom: parsed.viewport.zoom,
+          translateX: parsed.viewport.translateX,
+          translateY: parsed.viewport.translateY,
+          showConnections: parsed.viewport.showConnections,
+        },
+        items: parsed.items,
+        savedAt: parsed.savedAt || Date.now(),
+        version: parsed.version || STATE_VERSION,
+      }
+    } catch (error) {
+      console.warn("[canvas-storage] Failed to parse snapshot", { key, error })
+    }
+  }
+
+  return null
+}
+
+export function saveStateToStorage(
+  noteId: string,
+  snapshot: { viewport: PersistedViewport; items: CanvasItem[] }
+): boolean {
+  if (!isBrowser()) return false
+
+  try {
+    const payload: PersistedCanvasState = {
+      noteId,
+      savedAt: Date.now(),
+      version: STATE_VERSION,
+      viewport: snapshot.viewport,
+      items: snapshot.items.map((item) => ({
+        id: item.id,
+        itemType: item.itemType,
+        position: item.position,
+        panelId: item.panelId,
+        panelType: item.panelType,
+        componentType: item.componentType,
+        dimensions: item.dimensions,
+        minimized: item.minimized,
+        title: item.title,
+      })),
+    }
+
+    window.localStorage.setItem(storageKey(noteId), JSON.stringify(payload))
+    if (noteId && window.localStorage.getItem(LEGACY_KEY)) {
+      window.localStorage.removeItem(LEGACY_KEY)
+    }
+
+    console.table([
+      {
+        Action: "State Saved",
+        NoteId: noteId,
+        Items: payload.items.length,
+        SavedAt: new Date(payload.savedAt).toLocaleTimeString(),
+      },
+    ])
+    return true
+  } catch (error) {
+    console.error("[canvas-storage] Failed to save snapshot", error)
+    return false
+  }
+}
+
+export function clearStateFromStorage(noteId: string): void {
+  if (!isBrowser()) return
+  window.localStorage.removeItem(storageKey(noteId))
+}
+
diff --git a/components/annotation-canvas-modern.tsx b/components/annotation-canvas-modern.tsx
index abcdef0..1234567 100644
--- a/components/annotation-canvas-modern.tsx
+++ b/components/annotation-canvas-modern.tsx
@@
-import { useEffect, useState, forwardRef, useImperativeHandle, useRef, useCallback } from "react"
+import { useEffect, useState, forwardRef, useImperativeHandle, useRef, useCallback, useMemo } from "react"
@@
-import { CanvasItem, createPanelItem, createComponentItem, isPanel, isComponent } from "@/types/canvas-items"
+import { CanvasItem, createPanelItem, createComponentItem, isPanel, isComponent } from "@/types/canvas-items"
+import { loadStateFromStorage, saveStateToStorage } from "@/lib/canvas/canvas-storage"
@@
-const ModernAnnotationCanvas = forwardRef<CanvasImperativeHandle, ModernAnnotationCanvasProps>(({ 
-  noteId, 
-  isNotesExplorerOpen = false,
-  onCanvasStateChange 
-}, ref) => {
-  const [canvasState, setCanvasState] = useState({
-    zoom: 1,
-    translateX: -1000,
-    translateY: -1200,
-    isDragging: false,
-    lastMouseX: 0,
-    lastMouseY: 0,
-    showConnections: true
-  })
-
-  // Unified canvas items state
-  const [canvasItems, setCanvasItems] = useState<CanvasItem[]>([])
+const defaultViewport = {
+  zoom: 1,
+  translateX: -1000,
+  translateY: -1200,
+  showConnections: true,
+}
+
+const createDefaultCanvasState = () => ({
+  ...defaultViewport,
+  isDragging: false,
+  lastMouseX: 0,
+  lastMouseY: 0,
+})
+
+const createDefaultCanvasItems = (): CanvasItem[] => [
+  createPanelItem("main", { x: 2000, y: 1500 }, "main"),
+]
+
+const ensureMainPanel = (items: CanvasItem[]): CanvasItem[] => {
+  const hasMain = items.some((item) => item.itemType === "panel" && item.panelId === "main")
+  return hasMain ? items : [...items, createPanelItem("main", { x: 2000, y: 1500 }, "main")]
+}
+
+const ModernAnnotationCanvas = forwardRef<CanvasImperativeHandle, ModernAnnotationCanvasProps>(({
+  noteId,
+  isNotesExplorerOpen = false,
+  onCanvasStateChange,
+}, ref) => {
+  const [canvasState, setCanvasState] = useState(createDefaultCanvasState)
+
+  // Unified canvas items state
+  const [canvasItems, setCanvasItems] = useState<CanvasItem[]>(createDefaultCanvasItems)
+  const [isStateLoaded, setIsStateLoaded] = useState(false)
+  const autoSaveTimerRef = useRef<number | null>(null)
@@
-  useEffect(() => {
-    // Note: We no longer clear editor docs when switching notes
-    // The composite key system (noteId-panelId) already isolates docs between notes
-    // This allows content to load immediately when switching back to a previously viewed note
-    
-    // Check if we're in plain mode (explicit flag; avoids provider init race)
-    const isPlainMode = isPlainModeActive()
-    
-    if (!isPlainMode) {
-      // Initialize collaboration provider with YJS persistence
-      const provider = UnifiedProvider.getInstance()
-      
-      // Set the current note context
-      provider.setCurrentNote(noteId)
-      
-      // Check if this is a new note (check localStorage for existing data)
-      const existingData = localStorage.getItem(`note-data-${noteId}`)
-      const isNewNote = !existingData
-      
-      console.log('[AnnotationCanvas] Initializing note:', {
-        noteId,
-        hasExistingData: !!existingData,
-        isNewNote
-      })
-      
-      // Define default data for new notes
-      const defaultData = {
-        'main': {
-          title: 'New Document',
-          type: 'main',
-          content: '', // Empty content for new documents
-          branches: [],
-          position: { x: 2000, y: 1500 },
-          isEditable: true,
-          // Mark as new to force edit mode
-          isNew: isNewNote
-        }
-      }
-      
-      console.log('[AnnotationCanvas] Default data for main panel:', defaultData.main)
-      
-      // Initialize with defaults - the provider will merge with existing data if any
-      // For new notes, this sets empty content
-      // For existing notes, this preserves their content
-      provider.initializeDefaultData(noteId, defaultData)
-    }
-    
-    // Set main panel as the initial panel
-    setCanvasItems([createPanelItem('main', { x: 2000, y: 1500 }, 'main')])
-
-    return () => {
-      // Don't destroy note when switching - only cleanup when truly unmounting
-      // The provider's smart cache management will handle memory efficiently
-      // This allows content to persist when switching between notes
-    }
-  }, [noteId])
+  useEffect(() => {
+    const isPlainMode = isPlainModeActive()
+
+    if (!isPlainMode) {
+      const provider = UnifiedProvider.getInstance()
+      provider.setCurrentNote(noteId)
+
+      const existingData = typeof window !== "undefined"
+        ? window.localStorage.getItem(`note-data-${noteId}`)
+        : null
+      const isNewNote = !existingData
+
+      console.log('[AnnotationCanvas] Initializing note:', {
+        noteId,
+        hasExistingData: !!existingData,
+        isNewNote,
+      })
+
+      const defaultData = {
+        main: {
+          title: 'New Document',
+          type: 'main',
+          content: '',
+          branches: [],
+          position: { x: 2000, y: 1500 },
+          isEditable: true,
+          isNew: isNewNote,
+        },
+      }
+
+      provider.initializeDefaultData(noteId, defaultData)
+    }
+  }, [noteId])
+
+  useEffect(() => {
+    setIsStateLoaded(false)
+    setCanvasState(createDefaultCanvasState())
+    setCanvasItems(createDefaultCanvasItems())
+
+    if (autoSaveTimerRef.current) {
+      window.clearTimeout(autoSaveTimerRef.current)
+      autoSaveTimerRef.current = null
+    }
+
+    const snapshot = loadStateFromStorage(noteId)
+    if (!snapshot) {
+      console.table([
+        {
+          Action: 'No Saved State',
+          NoteId: noteId,
+          Time: new Date().toLocaleTimeString(),
+        },
+      ])
+      setIsStateLoaded(true)
+      return
+    }
+
+    console.table([
+      {
+        Action: 'State Loaded',
+        NoteId: noteId,
+        Items: snapshot.items.length,
+        SavedAt: new Date(snapshot.savedAt).toLocaleTimeString(),
+      },
+    ])
+
+    const viewport = snapshot.viewport
+    setCanvasState((prev) => ({
+      ...prev,
+      zoom: viewport.zoom ?? prev.zoom,
+      translateX: viewport.translateX ?? prev.translateX,
+      translateY: viewport.translateY ?? prev.translateY,
+      showConnections: viewport.showConnections ?? prev.showConnections,
+    }))
+
+    const restored = ensureMainPanel(
+      snapshot.items.map((item) => ({
+        ...item,
+        itemType: item.itemType,
+      })) as CanvasItem[]
+    )
+    setCanvasItems(restored)
+    setIsStateLoaded(true)
+  }, [noteId])
+
+  useEffect(() => {
+    return () => {
+      if (autoSaveTimerRef.current) {
+        window.clearTimeout(autoSaveTimerRef.current)
+        autoSaveTimerRef.current = null
+      }
+    }
+  }, [])
@@
   useEffect(() => {
     document.addEventListener('mousemove', handleCanvasMouseMove)
     document.addEventListener('mouseup', handleCanvasMouseUp)
@@
   }, [canvasState.isDragging, canvasState.lastMouseX, canvasState.lastMouseY])
@@
   useEffect(() => {
     const handlePanelEvent = (event: CustomEvent) => {
       if (event.detail?.panelId) {
         handleCreatePanel(event.detail.panelId)
       }
     }
 
     window.addEventListener('create-panel' as any, handlePanelEvent)
     return () => {
       window.removeEventListener('create-panel' as any, handlePanelEvent)
     }
   }, [noteId]) // Add noteId dependency to ensure we're using the correct note
+
+  const viewportSnapshot = useMemo(
+    () => ({
+      zoom: canvasState.zoom,
+      translateX: canvasState.translateX,
+      translateY: canvasState.translateY,
+      showConnections: canvasState.showConnections,
+    }),
+    [canvasState.zoom, canvasState.translateX, canvasState.translateY, canvasState.showConnections]
+  )
+
+  useEffect(() => {
+    if (!isStateLoaded) return
+
+    if (autoSaveTimerRef.current) {
+      window.clearTimeout(autoSaveTimerRef.current)
+    }
+
+    autoSaveTimerRef.current = window.setTimeout(() => {
+      saveStateToStorage(noteId, { viewport: viewportSnapshot, items: canvasItems })
+      autoSaveTimerRef.current = null
+    }, 450)
+
+    return () => {
+      if (autoSaveTimerRef.current) {
+        window.clearTimeout(autoSaveTimerRef.current)
+        autoSaveTimerRef.current = null
+      }
+    }
+  }, [noteId, viewportSnapshot, canvasItems, isStateLoaded])
