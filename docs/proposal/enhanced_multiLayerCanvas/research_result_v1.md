Internal Multi-Layer Canvas Flag Alignment and Migration Plan
Multi‑Layer Canvas Feature Flag Alignment Report
Current Flag Usage Patterns and Issues
Feature Flag Schema: The current feature flag schema defines ui.multiLayerCanvas (defaulted to true for testing) but no ui.layerModel flag exists. This means there’s no dedicated flag controlling the underlying layer manager. The ui.multiLayerCanvas flag is intended as the public switch between legacy (single-layer) and multi-layer canvas modes, but it’s the only flag in use.
LayerManager Hook (Env Override): In the layer manager hook (useLayerManager), the isEnabled determination ignores the UI flag and instead uses an environment override. It checks process.env.NEXT_PUBLIC_LAYER_MODEL !== '0' OR a nonexistent ui.layerModel flag (cast with as any). In practice, this means the layer manager is always active by default unless an environment variable explicitly disables it. The ui.multiLayerCanvas flag is not consulted here. As a result, turning off the UI flag in local storage or config does not actually disable the LayerManager logic – it only hides the UI cues.
UI Component Gating: Multiple components (canvas panels, layer controls, pop-up overlays, keyboard shortcuts) individually check the ui.multiLayerCanvas flag to conditionally render multi-layer UI elements. For example, the LayerControls component returns nothing if useFeatureFlag('ui.multiLayerCanvas') is false, and the PopupOverlay early-returns null when multi-layer mode is not enabled. Similarly, the keyboard shortcuts hook ignores layer switching keys if the flag is off. These components assume that when the flag is false, the app is in legacy mode and the layer manager is off. However, due to the override in useLayerManager, this assumption is violated – the LayerManager may still be running in the background.
Inconsistent Hybrid State: The above mismatch leads to a hybrid state when ui.multiLayerCanvas is turned off. The layer-based UI (layer switcher, layered popups, etc.) disappears as expected, but the underlying LayerManager continues to reorder panels and manage z-indices because it was never shut off. Panels might still register with the LayerManager and get programmatically reordered, even though the user sees no layer controls. This is confusing and unpredictable. For example, disabling the flag can cause popups or panels to behave oddly (since the overlay might not render, yet the manager is still adjusting DOM order).
Missing Flag Defaults: Because ui.layerModel (and a potential ui.panMode) are not defined in the schema, calls to useFeatureFlag('ui.layerModel') default to undefined. In the useLayerManager hook, undefined is falsy, so the code falls back on the NEXT_PUBLIC_LAYER_MODEL env check. In effect, the LayerManager is enabled whenever the env var isn’t '0' (including when it’s unset) – effectively always in most environments. This lack of a defined flag means no easy way to disable the layer manager via feature flags alone, complicating testing and rollout. QA and developers cannot reliably simulate a true single-layer (legacy) mode by just toggling flags, since the env override will continue to force multi-layer logic.
Testing Impact: The inconsistent flag handling makes it hard to test legacy mode. Automated tests or staging runs that try to set ui.multiLayerCanvas = false don’t get a clean single-layer mode – some layer logic persists. This undermines confidence in testing, since bugs might only appear when the env var is used. It’s also unclear for new contributors how to fully turn off the multi-layer system for regression tests, leading to potential oversight of legacy code paths.
Bottom line: The current implementation violates the “single source of truth” principle. We have a UI flag (ui.multiLayerCanvas) and an implicit backend flag (env var) competing. Disabling the UI flag does not fully disable the feature, leading to partial states. This is counter to the alignment plan’s goal of a single, predictable switch for multi-layer canvas. The missing ui.layerModel flag and ad-hoc overrides are the primary inconsistencies that need resolution.
Unified Gating with isLayerModelEnabled
To resolve the discrepancies, all components should use a unified gating condition that represents “multi-layer canvas fully enabled.” We introduce a new feature flag ui.layerModel to explicitly control the LayerManager, and we combine it with ui.multiLayerCanvas so both the underlying logic and UI obey one master toggle. The alignment plan calls this combined condition isLayerModelEnabled. Schema Update: First, extend the feature flags schema to include the new keys and establish explicit defaults:
// lib/offline/feature-flags.ts
interface FeatureFlags {
  // ... existing flags ...
  'ui.multiLayerCanvas': boolean;
  'ui.layerModel': boolean;      // NEW – controls LayerManager 
  'ui.panMode': boolean;         // NEW – future pan mode (optional)
}

const DEFAULT_FLAGS: FeatureFlags = {
  // ... existing defaults ...
  'ui.multiLayerCanvas': true,
  'ui.layerModel': true,
  'ui.panMode': false,
};
Both ui.multiLayerCanvas and ui.layerModel default to true (preserving current behavior where multi-layer canvas is on by default). This ensures that unless deliberately turned off, the app continues to use the multi-layer setup as it does today. Adding these keys to FeatureFlags means useFeatureFlag will recognize them without needing as any casts. LayerManager Hook: Next, remove the environment variable override and use the combined flags for enabling logic. In useLayerManager(), replace the old isEnabled definition:
- // LayerManager enabled by default; set NEXT_PUBLIC_LAYER_MODEL=0 to disable
- const isEnabled = useFeatureFlag('ui.layerModel' as any) ||
-                   process.env.NEXT_PUBLIC_LAYER_MODEL !== '0';
+ const isEnabled =
+   useFeatureFlag('ui.layerModel') && useFeatureFlag('ui.multiLayerCanvas');
This change makes the LayerManager truly respect the feature flags. Now both ui.layerModel and ui.multiLayerCanvas must be true for isEnabled to be true. We have effectively created a single toggle (isLayerModelEnabled) that can be flipped via flags. The environment variable NEXT_PUBLIC_LAYER_MODEL is no longer used for gating (it can be deprecated or removed), so environment or runtime JSON configurations should instead set the feature flags directly (e.g. via a NEXT_PUBLIC_FEATURE_FLAGS mechanism or by populating ui.layerModel in the config). This unification means that if either the UI aspect or the underlying logic is turned off, the entire multi-layer system is off – preventing the half-enabled state we saw before. UI Components: All components that previously checked ui.multiLayerCanvas now should check the unified condition. In practice, this can be achieved by either calling both flags or by consuming the isEnabled from useLayerManager. A straightforward approach is to replicate the combined check in each component’s logic:
LayerControls: Instead of const multiLayerEnabled = useFeatureFlag('ui.multiLayerCanvas'), use:
const isLayerModelEnabled =
  useFeatureFlag('ui.layerModel') && useFeatureFlag('ui.multiLayerCanvas');
// ...
if (!isLayerModelEnabled || !layerContext) {
  return null;
}
This ensures the layer controls panel only renders if the full layer model is enabled (both flags true). If either flag is false, we treat it as legacy mode – no layer UI is shown (and layerContext would likely be absent as well).
CanvasPanel: In the canvas panel component, which currently uses multiLayerEnabled = useFeatureFlag('ui.multiLayerCanvas'), we similarly define const multiLayerEnabled = useFeatureFlag('ui.layerModel') && useFeatureFlag('ui.multiLayerCanvas'). This combined flag can then be used for any conditional logic within the panel. For example, the computation of isLayerInteractive should be based on the combined flag rather than just ui.multiLayerCanvas alone. By doing so, if the layer model is disabled, the panel will treat itself as in a single-layer mode (e.g. always interactive, since there are no background layers to consider).
PopupOverlay (and PopupOverlayImproved): Both variants of the popup overlay component currently short-circuit if !multiLayerEnabled. This condition should also use the combined flag. For instance:
const isLayerModelEnabled =
  useFeatureFlag('ui.layerModel') && useFeatureFlag('ui.multiLayerCanvas');
if (!isLayerModelEnabled) {
  return null;
}
With this change, if the multi-layer system is disabled, the overlay will not mount a separate pop-up layer (we will handle the fallback logic separately). This prevents a scenario where the overlay might try to render while the rest of the system is legacy (or vice versa).
Keyboard Shortcuts: The useLayerKeyboardShortcuts hook guards its logic with if (!multiLayerEnabled) return in event handlers. We update multiLayerEnabled to be the combined isLayerModelEnabled as well. This way, none of the layer-switching hotkeys (Tab, Escape, etc.) will fire unless the LayerManager is fully active. This aligns with the idea that in legacy mode, those shortcuts (which toggle layers or manipulate multi-layer state) are irrelevant and should be inert.
After these changes, every part of the application uses the same source of truth for whether the multi-layer canvas is active. The UI will show layer controls and use layer-specific behaviors only when isLayerModelEnabled is true, and the LayerManager itself will only register and order nodes under the same condition. Importantly, this is an AND condition – if either flag is false, the combined mode is considered off (fail-closed). This ensures that if, for example, we wanted to kill-switch the feature in production, we could turn off either flag and be confident the entire multi-layer system is off. It also means we temporarily maintain two flags (one as an internal LayerManager toggle, one as the public UI toggle) which can be useful for gradual rollout or debugging, but they are always kept in sync logically. No-Op and Fallback Behavior: With isEnabled false, the useLayerManager hook already returns no-op functions and empty data structures (as it was designed to do). Panels calling methods like layerManager.focusNode or updateNode will safely no-op when the manager is disabled (those methods check isEnabled internally). However, to be explicit, we can also guard calls in critical places. For example, where CanvasPanel currently unconditionally calls layerManager.focusNode(panelId) on mouse-down to bring a panel to front, we could wrap this in if (layerManager.isEnabled). The result is the same (since focusNode does nothing if disabled), but it avoids unnecessary calls and clearly indicates the intent. With unified gating in place, disabling the multi-layer canvas flag truly disables the feature: no panels will register with LayerManager, no layer-based reordering will occur, and all layer-specific UI will be hidden. The legacy single-layer behavior can then be properly reinstated when the flag is off. In the next section, we discuss bridging any gaps (like ensuring popups and focusing still work in legacy mode).
One-Time Flag Migration Utility
Introducing new flags (ui.layerModel and ui.panMode) requires careful handling of persisted feature flag settings to avoid undefined or inconsistent states. We plan a one-time migration that runs at application startup to backfill missing flags in any stored feature flag configuration. Scenario: Users (or QA engineers) might have stored overrides in localStorage (offlineFeatureFlags) or there might be server-side feature toggles. For instance, if a user previously toggled off ui.multiLayerCanvas in local storage, their stored flags JSON might look like {"ui.multiLayerCanvas": false} with no knowledge of the new ui.layerModel key. Without migration, after our update, calling getFeatureFlag('ui.layerModel') would fall back to default (true), meaning the combined isLayerModelEnabled would be false && true – correctly false. This scenario is actually consistent (the feature stays off), but consider the inverse: if someone explicitly disabled the LayerManager via an env var or future flag but left ui.multiLayerCanvas true, we’d likewise want to ensure consistency. The migration’s goal is to ensure both flags are present for all users, so that no one continues running with only one of the two flags set. Approach: On application load, after reading any stored flags from localStorage, we merge in defaults for any missing keys. Pseudo-code for the migration:
// After loading runtimeFlags from localStorage:
let updated = false;
const defaults = DEFAULT_FLAGS;
['ui.layerModel', 'ui.panMode'].forEach(flag => {
  if (!(flag in runtimeFlags)) {
    runtimeFlags[flag] = defaults[flag];
    updated = true;
  }
});
if (updated) {
  try {
    localStorage.setItem('offlineFeatureFlags', JSON.stringify(runtimeFlags));
    console.info('[FeatureFlags] Migration: added missing flags', runtimeFlags);
  } catch (e) {
    console.error('Feature flag migration failed:', e);
  }
}
This will inject ui.layerModel (set to true by default) and ui.panMode (false by default) into the stored flags object if they were absent. We wrap the logic in a try/catch to be safe about storage access. We also log a message when a migration occurs (e.g., an info log indicating that we added the new flags and saved the updated config). This log is important for QA and developers to verify that the migration ran and that the old hybrid state cannot persist silently. Safeguards: The migration does not overwrite any existing flag overrides. If a user had manually set ui.multiLayerCanvas to false, we will add ui.layerModel: true (default) alongside it. In that case, the combined isLayerModelEnabled will still evaluate to false (false && true). If, in the future, someone explicitly sets ui.layerModel false and not ui.multiLayerCanvas, the migration would similarly add the missing one. Essentially, after migration, every stored flag blob will have both keys, ensuring the app’s logic sees a complete picture. The utility is idempotent – running it on subsequent loads will find no missing keys and do nothing (or it could set a marker to not run again once done). Server-side Toggles: If there are server-maintained feature flag records (for example, in a database or an .env configuration for staging/production defaults), those should be updated to include the new flags as well. The plan recommends using explicit defaults so that environment changes can toggle these without code deploys. In practice, that means ops can define ui.layerModel in the feature flag JSON or NEXT_PUBLIC_FEATURE_FLAGS environment, and QA can flip it. We should coordinate with the ops team to backfill ui.layerModel:true in any default configs. This, combined with the client-side localStorage migration, guarantees no environment starts with an undefined flag. By backfilling missing flags, we eliminate any “undefined flag” issues and ensure the LayerManager env check no longer forces itself on. QA can confidently toggle the combined flags on or off, knowing that both ui.multiLayerCanvas and ui.layerModel will be present and in sync by default.
Telemetry Enhancements for Flag Transitions
To safely roll out and later deprecate the legacy mode, we need visibility into when and how the feature flag state changes. We will add telemetry (structured logging and/or analytics events) around the isLayerModelEnabled state transitions. Event Schema: We introduce a new event (or log entry) for flag state changes. For example, an event CanvasLayerModelToggle with fields:
enabled – the new boolean state of isLayerModelEnabled (after change).
prevEnabled – the previous state (if known).
source_multi – where the ui.multiLayerCanvas value is coming from (e.g. "default", "runtime_override", or "env_override").
source_layerModel – likewise for ui.layerModel.
timestamp – when the change occurred (for ordering events).
Including the flag value sources is important. It allows us to diagnose if a state was enabled by default or by an explicit user/QA override. For instance, if a bug report comes in saying “the canvas is behaving oddly in single-layer mode,” the telemetry might show an event that enabled=false triggered at app startup with source_layerModel: "env_override" (meaning someone set an env flag to disable it). Support would then immediately know the app was intentionally put into legacy mode via config, which might explain the behavior. Logging Points: We will log this event in a few key places:
On Application Start: As soon as we determine the initial isLayerModelEnabled (after loading flags and env), emit a telemetry entry for the current state. This acts as a baseline. If the app boots up with enabled=false (legacy mode), we want that recorded.
On Flag Change at Runtime: Whenever setFeatureFlag('ui.multiLayerCanvas') or setFeatureFlag('ui.layerModel') is called (our dev/test toggling scenario), we will log an event. We can instrument the setFeatureFlag function to check if one of those keys is being set and then compute the new overall state and log it. Alternatively, we can use a React effect inside useLayerManager that watches the isEnabled boolean and logs whenever it changes value. Because our flags are global, tying into setFeatureFlag might be more direct. For example:
export function setFeatureFlag(flag, value) {
  // ...existing code to save flag...
  if (flag === 'ui.multiLayerCanvas' || flag === 'ui.layerModel') {
    const newState = getFeatureFlag('ui.multiLayerCanvas') && getFeatureFlag('ui.layerModel');
    debugLog('FeatureFlags', 'layer_model_toggle', {
      enabled: newState,
      source_multi: flag === 'ui.multiLayerCanvas' ? 'runtime_override' : (flagState('ui.multiLayerCanvas')),
      source_layerModel: flag === 'ui.layerModel' ? 'runtime_override' : (flagState('ui.layerModel'))
    });
  }
}
In this pseudo-code, flagState(x) would be a helper that returns the source of the current value (e.g., checks runtimeFlags vs ENV_FLAGS). The idea is to capture the act of a user or QA flipping the switch mid-session.
On Environment Override Detection: If we ever support live environment toggle (e.g., via a remote config push), the same logging should apply. In practice, environment flags likely only change on page load, not at runtime, so the startup log covers it.
All telemetry logs/events should be structured (JSON payloads or typed events) rather than simple console prints, so they can be aggregated in dashboards. For instance, we could send these events to our analytics pipeline (if one exists) to graph how often and where the legacy mode is used. This will directly feed into the deprecation strategy (e.g., verifying that <1% of sessions use legacy mode). Debug Visibility: In addition to back-end telemetry, we can add a developer-facing indicator. During development, it’s helpful to know which canvas mode is active. We can log a console message on boot like console.info("Canvas Model: " + (isEnabled ? "Multi-Layer" : "Legacy Single-Layer")). This “debug badge” doesn’t affect production users but helps developers and QA quickly confirm the current state. We might also expose the state in a global (for example, attach something like window.__canvasModel = 'multi-layer' for debugging or show a subtle UI label in dev builds). Propagation Strategy: The toggle events should propagate to any monitoring/alerting setup. For example, if we notice frequent flapping (switching on and off) in telemetry, that could indicate a problem (maybe a code path inadvertently disabling the flag). We might set up an alert if enabled=false ever shows up in production unexpectedly (since after rollout we expect it to be on nearly all the time). If we have remote logging, the debugLog utility could send the data to the server. If not, at minimum, the info will be in browser logs for QA to report. By instrumenting these transitions, we gain observability into the feature’s usage. This data will guide final deprecation (we’ll know exactly when it’s safe to remove legacy mode because no one is using it, per the logs) and will help catch any edge cases during rollout (e.g., if someone flips the flag and something doesn’t update, we’ll see the attempt in logs).
Testing and QA Scenarios
To ensure the alignment is correct and nothing breaks, we need to test both legacy mode (multi-layer off) and multi-layer mode (on) across a variety of scenarios. Below are recommended unit and integration tests, including runtime toggle behavior, to cover our bases:
Unit Tests – LayerManager Hook: Extend unit tests for useLayerManager to validate its behavior in both states. For example, when isLayerModelEnabled is false, calling registerNode should return undefined and not throw or alter state. Similarly, getOrderedNodes should return an empty list in legacy mode. We should explicitly set up tests where we simulate the flags as false (perhaps by monkey-patching getFeatureFlag or using a test hook) and assert that each method of the hook is a no-op. Also test the true case to ensure normal operation remains unchanged. This gives confidence that the LayerManager cleanly disengages when disabled.
Unit Tests – UI Components: For components like LayerControls, PopupOverlay, and others that gate on the flag, write tests to assert they render or not render appropriately. For example, render LayerControls with a context where isLayerModelEnabled=false and confirm it returns null (nothing). Conversely, with the flag true, it should render and show the expected elements (e.g., layer toggle buttons). For CanvasPanel, we can simulate a scenario with multi-layer off and verify that it does not call certain LayerManager methods. This might involve spying on layerManager.focusNode to ensure it wasn’t invoked during a drag, when the flag is false.
Integration Test – Legacy vs Multi-Layer Behavior: Create end-to-end tests (using a framework like Playwright or Cypress) that load the application in both modes and exercise core functionality:
Legacy Mode (Single-Layer): Launch the app with the feature flags disabled (e.g., by setting localStorage offlineFeatureFlags = {"ui.multiLayerCanvas": false, "ui.layerModel": false} before app start, or using a URL param in dev if available). Then verify:
The layer controls UI is absent (no layer switcher button on the canvas).
Opening multiple panels: the ordering should follow a simple stacking (likely the last opened panel is highest by DOM order or via a basic z-index increment). Since LayerManager isn’t active, panels should not be dynamically reordering on focus. We can test this by opening two panels and checking that clicking the first panel does not bring it in front of the second automatically (since in single-layer mode there’s no LayerManager to do so). Instead, focus might be managed via the DOM or not at all.
Popups (like comment or link previews) still appear in legacy mode. With our code changes, when isLayerModelEnabled is false, PopupOverlay doesn’t render a separate layer. We need to ensure that popups have a fallback: for instance, they might simply render in the main DOM (inline). A test should trigger a popup (e.g., simulate a hover that creates a popup) and confirm it is visible. This likely requires that our implementation of “render inline when disabled” is done – otherwise, popups would vanish entirely when the flag is off. Assuming we implement that fallback, the test would assert that popups are found as children of the main canvas rather than in a distinct overlay container.
Keyboard shortcuts that switch layers (Tab, etc.) should have no effect. We can simulate a Tab keypress and verify that it does not change any application state (for example, no active layer change because only one layer is present). In multi-layer mode, the same test would expect the active layer to toggle to “popups” on Tab press.
Basic interactions like dragging panels, resizing them, editing content should function without errors in legacy mode. We should especially check drag-and-drop: in multi-layer mode, dragging might involve LayerManager updates; in legacy, dragging should still move the panel (via direct DOM updates) and not throw any exceptions. An automated test can simulate a drag and ensure the panel’s position updates accordingly.
Multi-Layer Mode: Run the app with defaults (flags on) and verify all current multi-layer features:
LayerControls are visible and the layer toggle (e.g., Tab key or clicking the UI) switches layers in the UI context.
Panels register with the LayerManager: open a couple of panels and ensure that clicking a panel brings it to front (highest z-index) consistently. This can be verified by checking the computed z-index or order of elements after focusing different panels. It should reflect the LayerManager’s ordering (which could be by last focus time).
Popups render in their own layer element (e.g., a separate overlay div) above the notes layer. An integration test can ensure that a popup’s DOM node is in the correct container (not mixed with the notes DOM) and that its z-index is managed by the LayerManager’s scheme (perhaps using getPopupZIndex rules).
Keyboard shortcuts: press Tab and verify the active layer switches (maybe by observing a change in the UI state or an attribute in the layerContext). Press Escape or the digit keys and verify focus changes as intended (e.g., Ctrl+2 focusing popups layer should activate the popups layer in the context).
New features like pan/zoom: If pan/zoom mode exists (the plan mentions ui.panMode), ensure that it only activates in multi-layer mode. For instance, if pan mode is toggled on, it should do nothing if isLayerModelEnabled is false (since that mode likely requires layers). This might involve a unit test for any pan mode related code if present, or otherwise a note for QA to test zooming and panning in both modes (zoom might be limited or disabled in legacy).
No regressions: The multi-layer path should continue to operate exactly as before for all core functions (drag, drop, editing, syncing positions, etc.), since we haven’t functionally changed those beyond flag checks.
Runtime Toggle Test: We should simulate toggling the feature flags on the fly to observe the app’s response. For example, start the app in multi-layer mode, then programmatically set ui.multiLayerCanvas=false and ui.layerModel=false via setFeatureFlag (this mimics a QA engineer using a dev console or a test control to flip the flag). In a controlled test environment, we can then verify:
The application ideally should not instantly break or partially re-render in a wrong state. According to our plan, the preferred behavior is to show a reload prompt when a mid-session toggle happens. We might implement a mechanism where changing the flag triggers a warning banner like “Canvas mode changed – please refresh to apply changes.” Our test can assert that this banner appears. (If we choose not to implement a banner and instead support hot-swapping, then we’d test that all components respond to the context change without refresh. However, hot-swapping is risky, so a reload prompt is safer).
Ensure that no duplicate registrations or memory leaks occur. For instance, if the flag goes from true → false, the useLayerManager effect cleanup should detach any listeners or interval timers in LayerManager. In a test, we could toggle off and then on again (with a refresh in between ideally) and use tooling to check there aren’t multiple LayerManager instances or residual event handlers. This is more of a QA/manual test, but it’s worth considering.
Confirm localStorage persistence: toggling via setFeatureFlag should have saved the new values. A test can read localStorage.offlineFeatureFlags after the toggle and ensure it contains the expected JSON (e.g., {"ui.multiLayerCanvas":false,"ui.layerModel":false} if we turned both off). Then refresh the page (in the test) and verify it indeed comes up in legacy mode.
Cross-Environment Testing: Prepare a QA checklist (as mentioned in the plan) to be executed manually across different devices and breakpoints. This isn’t an automated test, but we document scenarios like:
Desktop vs tablet layouts: do both show/hide layer controls correctly with the flag?
Zooming in/out behavior in both modes (does zoom only apply to the multi-layer canvas? Is there any glitch if someone zooms while in legacy mode?).
Panel focus and ordering with nested panels (e.g., a note panel with an explorer sub-panel – in multi-layer mode they might both register in the LayerManager; in legacy, ensure the sub-panel doesn’t get lost underneath).
Integration with other systems: e.g., does the collaboration or isolation context treat the panel differently based on layer mode? (The canvas-panel code references isolation context that might not be affected by layers, but we check).
These scenarios ensure that turning the feature on or off doesn’t break core usability. We should run through them for both flag states before rollout, as recommended.
By covering the above tests, we gain confidence that the system behaves correctly in both modes and that the runtime flag logic is robust. Automated tests (especially the integration test that flips the flag) will help prevent regressions in the future – for example, if someone inadvertently assumes LayerManager is always on, a test where it’s off will catch the mistake.
Deprecation and Legacy Sunset Strategy
With the multi-layer canvas fully controlled by a robust feature flag, we can plan for the eventual removal of the legacy mode. The goal is to retire the single-layer code path once it’s no longer needed, but only after careful monitoring. Here’s a safe deprecation path:
Define Exit Criteria: Establish clear metrics indicating that legacy mode can be turned off for good. For example, require that for at least two release cycles, no critical bugs are reported that force using single-layer mode (i.e. “zero QA blockers in single-layer mode for two releases” as a confidence sign). Also use telemetry to ensure that legacy mode usage in the wild is minimal – for instance, telemetry shows <1% of sessions (or users) have the feature disabled over some time period. In practice, since we default the flags to true, a very low usage likely means only QA or edge cases are turning it off.
Gradual Rollout & Monitoring: During the interim, treat the flags as a temporary safety net. We might leave the option for QA to toggle the flags in staging/prod if needed for emergency fallback. But plan not to expose this to end users unless absolutely necessary. Meanwhile, collect data:
Monitor error logs to see if any errors are happening only when isLayerModelEnabled = true (which could indicate new issues in multi-layer logic). If so, legacy might still be needed as fallback.
Conversely, verify that running in legacy mode doesn’t produce new errors either (we don’t expect new development there, but just in case).
Track performance metrics in both modes if relevant (ensuring multi-layer doesn’t degrade performance significantly; if it did, that might delay deprecation until optimized).
Announcement and Documentation: Once confident, communicate the intent to remove legacy support. This includes:
Updating internal docs or proposals with the decision to fully migrate to multi-layer only.
Perhaps marking the legacy code paths with comments or @deprecated annotations to warn contributors. We could add a note in the CODEOWNERS or engineering guide: “Do not add new features behind ui.multiLayerCanvas without also considering ui.layerModel – legacy mode is slated for removal.” This prevents drift or new flags reintroducing a split.
If we have a developer changelog or release notes, mention that single-layer mode will be retired in an upcoming release, so teams are aware (especially if any teams were using it intentionally).
Merge or Consolidate Flags: Decide whether to merge the two flags into one before removal. We currently have ui.multiLayerCanvas (public) and ui.layerModel (internal). Having both was useful for transition, but long-term it’s redundant. Options:
Merge: Stop distinguishing between them and use one canonical flag. For example, pick ui.multiLayerCanvas as the enduring name (since it’s what front-end devs recognize) and drop ui.layerModel. Or vice versa if we prefer the new name. Merging could be done by having one flag’s value drive both (they should always be in sync by now). The final state is either one flag in code or perhaps a single truth managed in a remote config.
Retire: If we conclude that multi-layer canvas is here to stay permanently, we could remove both flags entirely, making the multi-layer logic always-on. This is the cleanest end state: eliminate all conditional code and treat multi-layer as the only implementation. This would involve deleting the flag definitions and any if (isLayerModelEnabled) checks, essentially unifying the code path.
In either case, plan the code changes for this carefully and perhaps behind a final minor release where the flag is effectively locked true. Capture the decision in the project docs (for historical record) as suggested.
Remove Legacy Code Paths: Once the flag is permanently true in production, proceed to strip out the legacy support:
Remove the ui.multiLayerCanvas and ui.layerModel entries from the FeatureFlags interface (and any default overrides). Update or remove any code that was dealing with loading/saving them (the migration utility can be retired at this point).
Excise the conditional branches: e.g., in useLayerManager, remove the isEnabled check entirely (or rather, simplify isEnabled to always true and then likely inline the LayerManager directly since no off-switch needed). In components, eliminate the if (!isLayerModelEnabled) return null guards and the related fallback code. Essentially, everything always assumes multi-layer mode now.
Remove the now-unused LayerProvider context or any legacy focusing logic that might have been reintroduced for single-layer mode. If we implemented manual z-index management for legacy, that can go too.
Clean up tests: remove or adjust tests that were specifically covering the legacy-off mode. (We might keep some around in the short term if we want to test ui.multiLayerCanvas “just in case,” but if the code is gone, tests should be removed accordingly.)
Delete any dead code related to the old single-layer system if it exists (for example, if there were old code paths for popups in single layer, etc., that we kept around, those can be purged).
Telemetry Cleanup: After removal, we should also retire the telemetry events associated with toggling. For instance, the CanvasLayerModelToggle events can be deprecated, since after a certain version, the state no longer changes (it’s always on). We might keep a simple log at app startup indicating “multi-layer canvas active (flag removed)” for a version or two for sanity, but eventually, the special logging can be removed to reduce noise. Any dashboard tracking of “who has it off” will become moot once no one can have it off.
Final Verification: In the first release with legacy code removed, pay extra attention to stability. Ensure the rollout is done when we’re confident (e.g., not right before a major deadline, in case something goes unexpectedly). QA should do a full regression in the new always-on mode. If something goes wrong, the plan to recover would be either a hotfix reintroducing the flag (not ideal) or instructing affected users to use an older version until fixed. However, with all the telemetry and phased rollout, we expect no surprises at this stage.
Throughout this process, future features must continue to respect the combined flag until removal. For example, if “pan mode” or “panel resizing” features are developed while the flag still exists, they should be conditioned on isLayerModelEnabled. This prevents introducing any new functionality that only works in multi-layer mode without being properly gated. We can even add a checklist item in pull requests or a linter to enforce that any code touching the canvas/layers checks the flag if it relies on multi-layer structures. This discipline ensures we don’t regress into a hybrid state through new code while we transition. Ultimately, once metrics show the legacy path is truly unused and unnecessary, we can confidently remove it, simplifying the codebase and reducing maintenance overhead. The feature flags themselves, having served their purpose, will either be consolidated or deleted, and the multi-layer canvas will be the only canvas – fulfilling the original goal of the project with a clean implementation.