Refactor Popup Overlay to Use Camera-Based Auto-Scroll and Canvas Coordinates
Patch Sequence for Shared-Camera Integration (Replacing Legacy Overlay Path)
Patch 1: Canvas-State Enforcement
Goal: Unify the coordinate system so that popups use the canvas’s coordinate space (the shared “camera”) instead of fixed screen positions. This ensures popups move/zoom consistently with the main canvas.
Store & Use Canvas Coordinates: Whenever a popup is created, immediately compute and store its position in canvas coordinates. For example, on popup creation the code now converts the screen position to canvas space using the current canvas transform. Every popup in hoverPopovers gets a canvasPosition that mirrors its location in the world coordinate system.
Canvas Position as Source of Truth: Update logic to prefer canvasPosition everywhere for positioning and persistence. The state and persistence payload now treat canvasPosition as the authoritative location. In building the save payload, we already store each popup’s coordinates under canvasPosition – this remains, but we drop any reliance on raw screen coordinates. Rendering also prioritizes popup.canvasPosition when positioning elements (falling back to popup.position only if needed for compatibility).
Enforce Canvas Mode Globally: Remove or disable any “hybrid” or legacy coordinate modes. The CoordinateBridge can be locked to canvas mode (no more screen or hybrid modes), ensuring all coordinate transformations assume a unified canvas space. The connection lines adapter already defaults to using canvasPosition when available, which aligns with this enforcement.
Outcome: All popup positions are now managed in the canvas coordinate system. This means popups inherently respect the main canvas transform (pan/zoom) going forward, laying the groundwork for a truly shared camera. Legacy screen-space positioning is effectively deprecated in this patch.
Patch 2: Overlay Transform Integration
Goal: Tie the overlay layer’s transform directly to the main canvas’s transform (the “shared camera”), instead of using an independent overlay transform. This makes the overlay move and scale in lockstep with the main canvas.
Remove Separate Overlay State: Eliminate the PopupOverlay component’s internal transform state and panning logic. Previously, the overlay maintained its own transform with independent pan/zoom handlers. In this patch, we remove that state (useState({x,y,scale}) in PopupOverlay) and its pointer event handlers for panning the overlay background. The overlay will no longer track its own camera.
Use Main Canvas Context: Leverage the main canvas’s transform (from the LayerProvider context) for the overlay. Instead of updating containerRef.current.style.transform within PopupOverlay on pointer moves, the overlay’s container now simply reflects the canvas transform provided by the context. For example, whenever the main canvas pan/zoom changes, we apply the same translate3d(... scale(...)) to the overlay container. This can be done by reading layerContext.transforms.notes (the main canvas transform) and applying CoordinateBridge.containerTransformStyle() to the overlay container style each render, rather than calculating it locally.
Unified Camera Movement: Ensure that user interactions update one shared transform. If the user drags the background in the main canvas or the overlay layer, it will affect the single camera transform. We might repurpose the overlay’s background pointer handlers to simply call the main canvas’s pan functions. For instance, a pointer drag on the overlay now invokes the canvas pan logic (or updates the context’s transform), rather than moving a separate overlay plane. The result is that whether you drag the canvas or the overlay area, you’re moving the same “camera”.
Outcome: The overlay layer is now essentially a view into the same coordinate system as the main canvas. There is only one camera transform in use. Popups will stay anchored relative to the canvas content when panning or zooming, with no desync. The legacy code path that rendered popups in a fixed-position layer is fully retired at this point – the overlay is always rendered inside the transformed canvas container.
Patch 3: Drag & Scroll Rework
Goal: Adapt popup dragging and auto-scroll behaviors to the unified camera system. We ensure that moving a popup or approaching window edges scrolls the shared canvas (not just the overlay), and adjust calculations for canvas scaling.
Popup Dragging in Canvas Space: Update the popup drag logic to account for the canvas transform. In the previous implementation, dragging a popup computed new popup.position in screen pixels and then updated canvasPosition by adding the same pixel delta. Now, we adjust this to use canvas-space deltas. If the canvas is zoomed, the screen movement dx, dy should be divided by the current scale before updating popup.canvasPosition. We modify the drag end handler to calculate the final canvas coordinates correctly. For example, updatedCanvasPosition = { x: popup.canvasPosition.x + dx/scale, y: popup.canvasPosition.y + dy/scale } (using the current canvas scale) instead of simply adding raw pixels. This keeps popup positions accurate under zoom. The final state update will set the popup’s canvasPosition to this new value (and likewise update position for legacy reference).
Unified Auto-Scroll: Rework edge-of-screen auto-scrolling to scroll the entire canvas. In the old overlay mode, when a user dragged a popup near the window edge, handleAutoScroll would translate all popups’ positions to simulate scrolling. With a shared camera, we instead propagate these scroll deltas to the canvas transform. In practice, this means calling the canvas pan function or updating the context’s transform by deltaX, deltaY when the cursor nears an edge. The useAutoScroll hook remains the trigger, but its onScroll callback now pans the global canvas. We remove the loop that individually offset each popup, since the entire overlay moves with the canvas now.
Smooth Integrated Panning: Ensure that panning the canvas (via background drag or auto-scroll) and dragging popups don’t conflict. Because both operations now affect one transform, we add checks to disable one when the other is active (e.g., if a popup is being dragged, maybe temporarily pause background panning on that layer to avoid double updates). We also maintain the visual fidelity improvements from before (like using requestAnimationFrame for smoother drag updates) but now applied to the single camera.
Edge Constraints: Retain logic to prevent dragging popups completely out of view. The existing drag code clamps popup positions to certain bounds (e.g., targetLeft and targetTop were clamped to not go beyond a minimum visible area). We keep similar constraints, but now they’ll be applied in canvas terms if needed (to ensure popups remain at least partially in the viewport after a drag).
Outcome: Dragging a popup or panning via edge scroll feels seamless in the unified canvas. When you drag a popup around, it stays under the cursor and the whole canvas view can auto-scroll if you reach an edge – effectively moving all content (notes and popups together) since it’s one plane. All coordinate math now respects the current zoom level, preventing any jumpiness or scale-related misplacement of popups.
Patch 4: Persistence Cleanup
Goal: Simplify and solidify the persistence of popup layout now that the shared-camera mode is always on. We remove legacy handling and ensure the saved data is consistent with the new coordinate system.
Single Source of Truth in Save Data: Confirm that we persist only canvas-based coordinates. The OverlayLayoutPayload already uses canvasPosition for each popup, and this remains unchanged. We clean up any remnants of legacy fields – e.g., if there were any code paths saving raw screen position or flags for “multiLayerEnabled”, those are removed. The saved layout schema (OVERLAY_LAYOUT_SCHEMA_VERSION) can remain the same if it already assumed canvas coords, but we double-check this. (If older saved layouts were in screen coordinates, a one-time migration could convert them via CoordinateBridge.screenToCanvas on load, though since plain mode previously didn’t persist legacy overlays, this might be unnecessary.)
Loading Path Alignment: Ensure that loading a saved layout correctly populates the state in canvas coordinates. The apply function already takes persisted canvasPosition values and uses them for both position and canvasPosition in state. We keep this logic, but drop any conditional that would have handled a legacy mode (for example, no need to treat data differently if collaboration mode is off – we always assume canvas positions now). The isOverlayPersistenceEnabled() check remains tied to plain mode (so we only load/save in single-user mode), which is correct for now since collaboration mode is not yet supported.
Remove Feature Flags: Any feature flag or config that allowed toggling the shared-camera mode is removed. Since this new behavior is the default and only path, we eliminate flags like multiLayerEnabled from being optional. In practice, the NotesExplorerPhase1 component was already forcing multiLayerEnabled=true; we make this permanent by removing the conditional rendering of legacy overlays and always rendering through the unified PopupOverlay.
Stability Improvements: As part of persistence cleanup, we also tidy up the save timing and conflict resolution. The existing debounce/save queue logic remains, but we verify it works with the potentially more frequent updates (due to unified panning affecting all popups). The conflict handler on save merges server state by applying envelope.layout via applyOverlayLayout – this already uses canvas positions, so it should continue to work without change. We add comments or minor checks if needed to clarify that all positions are in canvas space now (for future maintainers or when collaboration syncing is added).
Outcome: The overlay layout persistence is streamlined for the new system. There is a single code path for saving and loading popup layouts, and it consistently uses canvas coordinates. With legacy mode gone, the code is simpler – no branching based on mode – making it easier to maintain and extend (e.g., adding Yjs synchronization in the future).
Patch 5: Connection Lines Unification
Goal: Simplify connection line rendering now that popups share the canvas space. We remove the old “legacy” connection line logic and ensure all lines are drawn in the unified coordinate system for consistent appearance during movements.
Always Use Canvas Coordinates for Lines: The ConnectionLineAdapter is kept in “layered” mode permanently, since all popups have canvas positions in this new setup. We can remove the currentMode toggle and any references to legacy mode. Its adaptConnectionLines will always compute start/end points using popup.canvasPosition (with the existing offsets to connect bottom of parent to top of child). We retain the visibility culling and styling logic, but it now exclusively operates in the one coordinate space.
Remove Redundant Legacy Rendering: Delete the legacy SVG connection line rendering code from the React component. Previously, when not in multi-layer mode, lines were drawn via a separate <svg className="fixed"> over the viewport with manual bezier calculations. This patch removes that block entirely, since multi-layer (canvas unified) mode is always on. All connection lines are now rendered by the PopupOverlay’s internal SVG (which lives inside the transformed container) using the adapter’s output.
Verify Line Positioning: We double-check that the connection lines align correctly with popup edges in the new system. The adapter currently offsets the start/end points by fixed amounts (e.g. +150px to x for half popup width, +40px to y for header height) when using canvas coords. These values should correspond well to the actual popup dimensions defined in CSS (300px width, 40px header). Since those haven’t changed, the lines should connect at the proper points. We test a few scenarios to ensure lines draw smoothly when popups are dragged or panned. The dynamic styling (lighter or thicker lines during drag) remains as implemented.
Z-index and Rendering Order: Make sure connection lines appear below popups but above the canvas content. In the unified overlay, this is already handled by drawing lines in the overlay’s SVG before rendering the popup <div>s. We keep that structure. With legacy code gone, the z-index layering is simpler (one less SVG overlay element to juggle).
Outcome: Connection lines are fully integrated into the shared camera system. They move and scale correctly as the user pans or zooms, always maintaining connections between parent/child popups. The old duplicate logic for drawing lines in fixed screen space is gone, reducing code complexity. Visually, users should notice that lines now stay attached to popups even as the entire view moves (since everything moves together).
Patch 6: Tests and Verification
Goal: Add and update tests to ensure the new shared-camera overlay behavior works as expected and prevent regressions. We focus on both unit tests for utilities and integration tests for user-visible behavior.
Coordinate Utility Tests: Create unit tests for the CoordinateBridge conversions to confirm screen/canvas calculations are correct. For example, test that converting a point to canvas and back to screen returns the original point for a given transform, and that scaling is handled properly. This is especially important now that drag uses these conversions under the hood. We also test preserveRelativePositions if used, to ensure it maintains popup relationships during transform changes.
Drag & Drop Behavior: Write integration tests (or React component tests) simulating popup drag and drop. The test would open a popup, simulate a drag movement to a new location, and then assert that the popup’s final canvasPosition has changed by the expected amount. We also verify through the DOM that the popup’s <div style="left:…, top:…"> has moved accordingly. If the canvas was zoomed in the test, we assert that the movement accounts for the scale (i.e., dragging by 100px with 2x zoom moves the popup 50 canvas units, for instance).
Panning and Auto-Scroll: Test that panning the canvas moves popups. For example, programmatically call the canvas pan function or simulate a pointer drag on the canvas background, then check that a previously opened popup’s screen position shifted the correct amount (and its internal canvasPosition remains constant relative to the canvas). Similarly, simulate moving the cursor near the edge while dragging a popup to trigger auto-scroll, and assert that the canvas transform changed (instead of individual popup positions).
Persistence Round-trip: Add a test to save and load a layout. Open a couple of popups, drag them to known positions, then invoke the save logic. Retrieve the saved OverlayLayoutPayload (perhaps by intercepting the adapter’s output) and confirm it contains the expected canvasPosition values. Then simulate loading that layout via applyOverlayLayout and verify the popups restore to the same positions. This ensures no data is lost in conversion and the layout persists correctly across sessions.
Connection Lines Rendering: Test that connection lines appear and update correctly. For instance, open nested popups (parent and child), then verify that an SVG path is present connecting them. Change the state (drag the child popup or pan the view) and confirm the SVG path’s d attribute updates to reflect the new positions. We can also check that the styling toggles (e.g., opacity or stroke width) change when dragging starts and ends, matching the intended behavior.
Removal of Legacy Paths: Go through any existing test cases that might have referenced the old overlay mode or feature flag. Update or remove those, since the legacy code is gone. For example, if there were tests expecting popups to be in a fixed container, update them to expect transformed coordinates now. Ensure no test tries to toggle multiLayerEnabled off – that capability no longer exists.
Outcome: The test suite will pass with all popups and connection lines operating under the new unified camera system. The added tests give confidence that popups remain consistent under pan/zoom, that persistence is correct, and that no regressions to the legacy behavior will slip in. This final patch establishes a solid foundation so the shared-camera behavior can replace the legacy overlay path completely, with automated checks guarding its functionality going forward.