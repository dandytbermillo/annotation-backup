# Universal Selection Resolver Plan

**Status:** Draft
**Owner:** Chat Navigation
**Last updated:** 2026-02-05

## Purpose
Provide a single, hybrid selection follow-up resolver that:
- Keeps ordinals/labels active until stop/new list/TTL.
- Prevents "Unknown option type" by never routing widget items through `handleSelectOption()`.
- Preserves the separation between chat-created lists (Tier 3) and widget lists (Tier 4.5).
- Uses deterministic-first with constrained LLM fallback for messy real-world phrasing.

## Non-Goals
- Do not merge widget lists into `pendingOptions` / `activeOptionSetId`.
- Do not change widget registry or builder schemas beyond what's needed to resolve follow-ups.
- Do not alter LLM intent routing or doc retrieval behavior.

## Pre-Read Compliance
- **Isolation Reactivity Anti-Patterns:** Not applicable to this plan (no new providers/hooks). The plan avoids provider/consumer contract drift and keeps routing logic centralized.

## Definitions
- **Chat Selection Context:** Options generated by chat routing (panel disambiguation, known-noun prompts, meta-explain, re-show). Uses `pendingOptions`, `activeOptionSetId`, `lastClarification`, `lastOptionsShown`.
- **Widget Selection Context:** Options generated from widget registry lists (Tier 4.5). Never stored in `pendingOptions`.

## Requirements
1. **Two separate contexts, never mixed**
   - `chatSelectionContext` (existing state)
   - `widgetSelectionContext` (new state)
2. **Precedence rule**
   - If both exist and input is selection-like, resolve against chat context first.
3. **Selection-like gate**
   - The resolver must only engage when `isSelectionLike(input)` is true.
4. **Clarifiers register only**
   - Clarifiers should register a context but never execute directly.
5. **Clear rules**
   - Clear only on explicit stop/cancel, explicit start-over, new list registration, or TTL expiry.
   - Do not clear on ordinary commands.

## Implementation Plan

### Phase 1 — Add Widget Selection Context State
**File:** `lib/chat/chat-navigation-context.tsx`
- Add `WidgetSelectionContext` interface:
  - `optionSetId: string`
  - `widgetId: string`
  - `segmentId?: string`
  - `options: Array<{ id: string; label: string }>`
  - `timestamp: number`
  - `turnsSinceShown: number`
- Add state + setters:
  - `widgetSelectionContext`
  - `setWidgetSelectionContext()`
  - `clearWidgetSelectionContext()`
  - `incrementWidgetSelectionTurn()`
 - **TTL handling:** increment `turnsSinceShown` once per user turn (parallel to `incrementLastOptionsShownTurn`).

### Phase 2 — Centralize Registration Helpers
**Location:** `components/chat/chat-navigation-panel.tsx` **or** a shared helper module (recommended) `lib/chat/selection-context-helpers.ts`
- `registerChatSelectionContext(...)`
  - Sets `pendingOptions`, `activeOptionSetId`, `lastClarification`, `lastOptionsShown`.
- `registerWidgetSelectionContext(...)`
  - Sets `widgetSelectionContext` only. Does **not** touch chat selection state.
- `clearSelectionContext(reason)`
  - Clears chat and widget contexts based on reason (stop/cancel/start_over/new_list/ttl).

### Phase 3 — Replace Option-Creation Sites
- Chat sources use `registerChatSelectionContext`:
  - Panel disambiguation
  - Meta-explain ambiguity
  - Known-noun disambiguation
  - Re-show options
- Widget clarifiers use `registerWidgetSelectionContext`:
  - Tier 4.5 LLM `need_more_info`
  - LLM disabled/timeout clarifier
 - **Clarifier message options:** if a widget clarifier shows pills, populate `message.options` for re-show/repair UI, but **do not** write widget options into `pendingOptions`.
 - **Option-type grounding clarifiers (new lists):**
   - If `option` candidates are not found in `findLastOptionsMessage`, still register a fresh chat selection context **only when** you can safely attach execution data (from the candidate payload or a lookup).
   - If you cannot attach data, do **not** leave stale `pendingOptions` active; clear chat selection context and still render the pills in `message.options` for UI-only display.
 - **Widget list grounding clarifiers (source: `widget_list`):**
   - Candidates must be typed `widget_option` and registered via `registerWidgetSelectionContext`.
   - If widget list candidates cannot be typed as `widget_option` (missing `widgetId`/`segmentId`), do **not** register chat context; clear stale chat context and keep pills UI-only.

### Phase 4 — Universal Follow-Up Resolver
**File:** `lib/chat/routing-dispatcher.ts`
- Add `resolveSelectionFollowUp(input)` after Tier 3 and before known-noun (Tier 4) routing.
- Gate: `isSelectionLike(input)` must be true.
- Question-intent filter: default to requiring `hasQuestionIntent(input) === false`, **except** for polite command-style ordinals (for example, `"can you open the second option pls"`), which must still be treated as selection follow-ups.
- **Deterministic scope (minimal/high-confidence only):**
  - ordinal words/numbers/badge letters
  - exact label matches
  - keep core ordinal coverage (`first/second/last`, numeric ordinals, badge letters) in deterministic matching
  - avoid aggressive synonym expansion as a primary strategy
- **Ordinal parsing:** use embedded ordinal extraction (e.g., `resolveOrdinalIndex`) so phrases like "can you open that second one pls" resolve for both chat and widget contexts (do not rely solely on strict `isSelectionOnly`).
- Resolution order:
  1) If `chatSelectionContext` active → strict deterministic match → `handleSelectOption`.
  2) Else if `widgetSelectionContext` active → strict deterministic match → `execute_widget_item`.
  3) Explicit command escape: if input is a named command resolvable by known-noun routing (or explicit command with no active-candidate match), do not trap it as a selection miss; allow Tier 4 known-noun execution.
  4) If deterministic misses and active executable context exists → call constrained selection LLM with only active context candidates.
  5) On LLM `select(choiceId)` → execute selected candidate by context source.
  6) On LLM `need_more_info`/timeout/error → show targeted retry prompt.
  7) Else fall through.
 - **Context plumbing:** add `widgetSelectionContext` to dispatcher context (alongside `pendingOptions`, `activeOptionSetId`, etc.) and pass it into the resolver.
 - **LLM safety contract:** constrained output only (`select` with valid `choiceId` or `need_more_info`), never execute without valid candidate id.

### Phase 5 — Clarification Intercept Bypass for Widget Context
**File:** `lib/chat/chat-routing.ts`
- If `widgetSelectionContext` is active, skip clarification-mode handling and return `{ handled: false }` to allow the dispatcher resolver to run.
- Optional defensive guard: only if `lastClarification.options` are **all** `widget_option`, also skip clarification-mode handling.
- Keep existing chat clarification logic for chat-only contexts.

### Phase 6 — Clear Rules
- Clear selection context only when:
  - Stop/cancel confirmed
  - Explicit start-over
  - New list registration (replaces old)
  - TTL expiry
- Do **not** clear on ordinary commands.

## Reliability Addendum

1. **Unified selection contract**
   - Use one normalized selection contract for both chat and widget sources:
     - `source: 'chat' | 'widget'`
     - `optionSetId`
     - `orderedOptions[]` (display order = ordinal order)
     - `executionRef` per option
     - `turnsSinceShown`
     - `uiOnly` flag
2. **Execution refs at registration**
   - Register execution refs when the clarifier is created (no late reconstruction from unrelated state).
   - Widget options must carry `{ widgetId, segmentId, itemId }` at registration time.
3. **`uiOnly` behavior**
   - If execution refs are missing, mark the context `uiOnly: true`.
   - In `uiOnly` mode, keep pills clickable for UI display, but do not allow ordinal follow-up execution from that context.
4. **Full state replacement**
   - Registering a new selection context must replace competing selection state:
     - `pendingOptions`
     - `activeOptionSetId`
     - `lastClarification`
     - `lastOptionsShown`
     - `clarificationSnapshot`
     - `widgetSelectionContext`
   - Invariant: do not end registration with dual active executable contexts (chat XOR widget). The only allowed overlap is when one context is `uiOnly`.
5. **Tier bypass rules**
   - When an active executable context exists (`uiOnly: false`) and input is selection-like, bypass lower routing tiers until the universal resolver runs.
   - When `uiOnly: true`, do not bypass broadly; return a targeted clarifier (for example, "Tap an option pill to choose.") and avoid background tier hijacking.
   - In executable contexts, deterministic miss should route to constrained LLM before broader grounding/doc fallback.
6. **Required logs**
   - Emit explicit logs for:
     - `selection_context_registered`
     - `selection_context_ui_only`
     - `universal_resolver_hit`
     - `resolver_bypassed_by_tier`
7. **Reliability acceptance tests**
  - Long-phrase ordinal works for chat options (`"can you open the second option pls"`).
  - Long-phrase ordinal works for widget clarifiers (`"can you open that second one pls"`).
  - New clarifier context does not allow stale list binding.
  - `uiOnly` context shows pills but does not execute ordinals.
  - Question-intent inputs do not trigger selection execution.
8. **Deterministic miss behavior with active context**
   - If an active executable selection context exists and deterministic ordinal/label matching fails, call constrained LLM over active context candidates first.
   - If constrained LLM returns `need_more_info`/fails, return a targeted retry prompt (for example, "I didn't catch that. Say first/second, or tap an option.") before broader Tier 4.5/doc fallback.

## Acceptance Tests
1. **Widget clarifier + ordinal follow-up**
   - Clarifier: "summary144, summary155?" → "first option" opens widget item.
2. **Chat clarifier + ordinal follow-up**
   - "Panel D/E?" → "second option" executes correct chat option.
3. **Stop clears both contexts**
   - Stop/cancel clears chat + widget selection contexts.
4. **Selection-like gate**
   - "what does summary144 mean?" does **not** trigger selection resolver.
5. **Hybrid long-tail follow-up**
   - Active clarifier + `"pls open the initial choice now"` resolves via constrained LLM to a valid candidate (or returns targeted retry, not multi-list/doc detour).
6. **Explicit command escape with active context**
   - Active clarifier context + `"open links panel d"` executes panel command via known-noun routing, not retry prompt and not selection resolution.

## Risks / Mitigations
- **Risk:** Cross-list binding if contexts leak.
  - **Mitigation:** Strict separation + precedence rule + resolver gating.
- **Risk:** Resolver intercepts non-selection queries.
  - **Mitigation:** `isSelectionLike` gate and question intent guard.

## Notes
- This plan does not change widget registry schemas. It only manages selection routing.
- Coordinate with `widget-ui-snapshot-plan.md` to keep chat vs widget separation consistent.
