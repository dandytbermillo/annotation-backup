# Universal Selection Resolver Plan

**Status:** Draft
**Owner:** Chat Navigation
**Last updated:** 2026-02-12

## Purpose
Provide a single, hybrid selection follow-up resolver that:
- Keeps ordinals/labels active until stop/new list/TTL.
- Prevents "Unknown option type" by never routing widget items through `handleSelectOption()`.
- Preserves the separation between chat-created lists (Tier 3) and widget lists (Tier 4.5).
- Uses deterministic-first with constrained LLM fallback for messy real-world phrasing.

## Non-Goals
- Do not merge widget lists into `pendingOptions` / `activeOptionSetId`.
- Do not change widget registry or builder schemas beyond what's needed to resolve follow-ups.
- Do not alter LLM intent routing or doc retrieval behavior.

## Pre-Read Compliance
- **Isolation Reactivity Anti-Patterns:** Not applicable to this plan (no new providers/hooks). The plan avoids provider/consumer contract drift and keeps routing logic centralized.

## Normative Dependency (Mandatory)

This plan is implementation-scoped and inherits arbitration policy from:
- `deterministic-llm-arbitration-fallback-plan.md` (global policy)
- `deterministic-llm-ladder-enforcement-addendum-plan.md` (active-option enforcement)

Required rule inheritance for resolver work:
1. Deterministic first.
2. If not high-confidence resolved in active options, call constrained LLM on bounded candidates.
3. If LLM fails/abstains/timeout/429/low-confidence, return safe clarifier (no execute).

Operational shorthand:
- **If the system is not 100% sure in active-option scope, it must not force execution; it must ladder to bounded LLM.**

Conflict rule:
- If this file conflicts with the addendum on ladder behavior, the addendum wins.

Scope note:
- This dependency governs selection/arbitration flows; cross-corpus Tier 2b behavior is separately governed by routing-order + known-vs-doc plans.

## Definitions
- **Chat Selection Context:** Options generated by chat routing (panel disambiguation, known-noun prompts, meta-explain, re-show). Uses `pendingOptions`, `activeOptionSetId`, `lastClarification`, `lastOptionsShown`.
- **Widget Selection Context:** Options generated from widget registry lists (Tier 4.5). Never stored in `pendingOptions`.

## Requirements
1. **Two separate contexts, never mixed**
   - `chatSelectionContext` (existing state)
   - `widgetSelectionContext` (new state)
2. **Precedence rule**
   - Explicit scope cue wins first (`from chat`, `in chat`, `from active widget`, etc.).
   - If no explicit scope cue and input is selection-like, active latch/default source wins (widget-first when latched).
   - Do not use a blanket "chat first when both exist" rule.
   - **Hard ordering constraint:** explicit scope-cue resolution must run before any widget-selection-context bypass. A pre-bypass return must not suppress a valid `from chat` / `in chat` re-anchor.
3. **Selection gate + unresolved exception (canonical)**
   - Resolver defaults to `isSelectionLike(input)` gating.
   - Exception: if active executable option context exists and deterministic resolution is unresolved, do not early-escape on strict selection-like gating; run bounded LLM ladder before unrelated fallback.
4. **Clarifier registration vs execution**
   - Clarifier registration paths should register context only and must not execute directly.
   - Execution is allowed only in resolver/runtime execution paths under deterministic high-confidence or Phase C gated LLM select.
5. **Clear rules**
   - Clear only on explicit stop/cancel, explicit start-over, new list registration, or TTL expiry.
   - Do not clear on ordinary commands.

## Implementation Plan

### Phase 1 — Add Widget Selection Context State
**File:** `lib/chat/chat-navigation-context.tsx`
- Add `WidgetSelectionContext` interface:
  - `optionSetId: string`
  - `widgetId: string`
  - `segmentId?: string`
  - `options: Array<{ id: string; label: string }>`
  - `timestamp: number`
  - `turnsSinceShown: number`
- Add state + setters:
  - `widgetSelectionContext`
  - `setWidgetSelectionContext()`
  - `clearWidgetSelectionContext()`
  - `incrementWidgetSelectionTurn()`
 - **TTL handling:** increment `turnsSinceShown` once per user turn (parallel to `incrementLastOptionsShownTurn`).

### Phase 2 — Centralize Registration Helpers
**Location:** `components/chat/chat-navigation-panel.tsx` **or** a shared helper module (recommended) `lib/chat/selection-context-helpers.ts`
- `registerChatSelectionContext(...)`
  - Sets `pendingOptions`, `activeOptionSetId`, `lastClarification`, `lastOptionsShown`.
- `registerWidgetSelectionContext(...)`
  - Sets `widgetSelectionContext` only. Does **not** touch chat selection state.
- `clearSelectionContext(reason)`
  - Clears chat and widget contexts based on reason (stop/cancel/start_over/new_list/ttl).

### Phase 3 — Replace Option-Creation Sites
- Chat sources use `registerChatSelectionContext`:
  - Panel disambiguation
  - Meta-explain ambiguity
  - Known-noun disambiguation
  - Re-show options
- Widget clarifiers use `registerWidgetSelectionContext`:
  - Tier 4.5 LLM `need_more_info`
  - LLM disabled/timeout clarifier
 - **Clarifier message options:** if a widget clarifier shows pills, populate `message.options` for re-show/repair UI, but **do not** write widget options into `pendingOptions`.
 - **Option-type grounding clarifiers (new lists):**
   - If `option` candidates are not found in `findLastOptionsMessage`, still register a fresh chat selection context **only when** you can safely attach execution data (from the candidate payload or a lookup).
   - If you cannot attach data, do **not** leave stale `pendingOptions` active; clear chat selection context and still render the pills in `message.options` for UI-only display.
 - **Widget list grounding clarifiers (source: `widget_list`):**
   - Candidates must be typed `widget_option` and registered via `registerWidgetSelectionContext`.
   - If widget list candidates cannot be typed as `widget_option` (missing `widgetId`/`segmentId`), do **not** register chat context; clear stale chat context and keep pills UI-only.

### Phase 4 — Universal Follow-Up Resolver
**File:** `lib/chat/routing-dispatcher.ts`
- Add `resolveSelectionFollowUp(input)` after Tier 3 and before known-noun (Tier 4) routing.
- Gate:
  - Primary: `isSelectionLike(input)` is true.
  - Required exception: if active executable option context exists and deterministic resolution is unresolved, do not block the ladder on strict selection-like gating; proceed with bounded LLM path per addendum Rule G.
- Question-intent filter: use shared utilities only (`hasQuestionIntent` + `isPoliteImperativeRequest`) to avoid local regex drift. Polite command-style ordinals (for example, `"can you open the second option pls"`) remain selection follow-ups.
- Arbitration source of truth: use shared classifier/threshold contracts from the addendum (`classifyArbitrationConfidence` + Phase C gates). Do not add local confidence heuristics.
- **Deterministic scope (minimal/high-confidence only):**
  - ordinal words/numbers/badge letters
  - exact label matches
  - keep core ordinal coverage (`first/second/last`, numeric ordinals, badge letters) in deterministic matching
  - avoid aggressive synonym expansion as a primary strategy
- **Ordinal parsing:** use embedded ordinal extraction (e.g., `resolveOrdinalIndex`) so phrases like "can you open that second one pls" resolve for both chat and widget contexts (do not rely solely on strict `isSelectionOnly`).
- Resolution order:
  1) Respect explicit scope cue binding resolved upstream.
  2) If no scope cue and active widget latch exists with selection-like input, resolve widget context first.
  3) Otherwise use active selection context deterministic matching (chat or widget).
  4) Explicit command escape is allowed only when active-option ambiguity is not unresolved (for example, no active executable option context, or deterministic command confidence is high and non-colliding).
  5) If deterministic is unresolved and active executable context exists -> constrained LLM on bounded active-context candidates before unrelated downstream fallback.
  6) On LLM `select(choiceId)`: execute only under Phase C gates from the addendum; otherwise safe clarifier.
  7) On `need_more_info`/timeout/429/error/abstain/low-confidence/feature-disabled -> safe clarifier (no execute).
  8) Else fall through.
 - **Context plumbing:** add `widgetSelectionContext` to dispatcher context (alongside `pendingOptions`, `activeOptionSetId`, etc.) and pass it into the resolver.
- **LLM safety contract:** constrained output only (`select` with valid `choiceId` or `need_more_info`), never execute without valid candidate id.
- **Bounded candidate contract (required):**
  - Candidate pool must be derived from the currently resolved scope/context only.
  - Explicit `from chat` / `in chat` must bind to chat-origin executable options; widget-item candidates are out-of-scope for that arbitration call.
  - If source binding is unclear, ask for scope clarification (`need_more_info`) rather than mixing pools and guessing.

### Phase 5 — Clarification Intercept Bypass for Widget Context
**File:** `lib/chat/chat-routing.ts`
- If `widgetSelectionContext` is active, skip clarification-mode handling and return `{ handled: false }` to allow the dispatcher resolver to run.
- Optional defensive guard: only if `lastClarification.options` are **all** `widget_option`, also skip clarification-mode handling.
- Keep existing chat clarification logic for chat-only contexts.
- **Ordering guard (required):**
  - Scope-cue normalization/re-anchor checks must run before widget-context bypass.
  - If explicit chat scope cue is present, bypass must not early-return into widget-first routing.

### Phase 6 — Clear Rules
- Clear selection context only when:
  - Stop/cancel confirmed
  - Explicit start-over
  - New list registration (replaces old)
  - TTL expiry
- Do **not** clear on ordinary commands.

## Reliability Addendum

1. **Unified selection contract**
   - Use one normalized selection contract for both chat and widget sources:
     - `source: 'chat' | 'widget'`
     - `optionSetId`
     - `orderedOptions[]` (display order = ordinal order)
     - `executionRef` per option
     - `turnsSinceShown`
     - `uiOnly` flag
2. **Execution refs at registration**
   - Register execution refs when the clarifier is created (no late reconstruction from unrelated state).
   - Widget options must carry `{ widgetId, segmentId, itemId }` at registration time.
3. **`uiOnly` behavior**
   - If execution refs are missing, mark the context `uiOnly: true`.
   - In `uiOnly` mode, keep pills clickable for UI display, but do not allow ordinal follow-up execution from that context.
4. **Full state replacement**
   - Registering a new selection context must replace competing selection state:
     - `pendingOptions`
     - `activeOptionSetId`
     - `lastClarification`
     - `lastOptionsShown`
     - `clarificationSnapshot`
     - `widgetSelectionContext`
   - Invariant: do not end registration with dual active executable contexts (chat XOR widget). The only allowed overlap is when one context is `uiOnly`.
5. **Tier bypass rules**
   - When an active executable context exists (`uiOnly: false`) and input is selection-like, bypass lower routing tiers until the universal resolver runs.
   - Apply the same unresolved exception as Requirement #3: if active-option ambiguity is unresolved, do not bypass the bounded LLM ladder solely due to strict selection-like gating.
   - When `uiOnly: true`, do not bypass broadly; return a targeted clarifier (for example, "Tap an option pill to choose.") and avoid background tier hijacking.
   - In executable contexts, deterministic miss should route to constrained LLM before broader grounding/doc fallback.
6. **Required logs**
   - Emit explicit logs for:
     - `selection_context_registered`
     - `selection_context_ui_only`
     - `universal_resolver_hit`
     - `resolver_bypassed_by_tier`
7. **Reliability acceptance tests**
  - Long-phrase ordinal works for chat options (`"can you open the second option pls"`).
  - Long-phrase ordinal works for widget clarifiers (`"can you open that second one pls"`).
  - New clarifier context does not allow stale list binding.
  - `uiOnly` context shows pills but does not execute ordinals.
  - Question-intent inputs do not trigger selection execution.
8. **Deterministic miss behavior with active context**
   - If an active executable selection context exists and deterministic ordinal/label matching fails, call constrained LLM over active context candidates first.
   - If constrained LLM returns `need_more_info`/fails, return a targeted retry prompt (for example, "I didn't catch that. Say first/second, or tap an option.") before broader Tier 4.5/doc fallback.
   - If explicit scope is present but candidate pool for that scope is insufficient or stale, ask a scope-specific clarifier (for example, "Do you mean the earlier chat options or items in the active widget?") and do not execute.
9. **Loop-guard continuity (required)**
   - Use one loop-guard key contract: `normalizedInput + sortedCandidateIds + optionSetId/messageId`.
   - Within the same unresolved cycle, suppress repeated LLM calls but preserve prior suggested ordering.
   - Reset guard on new cycle boundaries (input/candidate-set/set-id change, successful resolution, clarification cleared, chat reset).

## Acceptance Tests
1. **Widget clarifier + ordinal follow-up**
   - Clarifier: "summary144, summary155?" → "first option" opens widget item.
2. **Chat clarifier + ordinal follow-up**
   - "Panel D/E?" → "second option" executes correct chat option.
3. **Stop clears both contexts**
   - Stop/cancel clears chat + widget selection contexts.
4. **Question-intent gate**
   - "what does summary144 mean?" does **not** trigger selection execution.
5. **Hybrid long-tail follow-up**
   - Active clarifier + `"pls open the initial choice now"` resolves via constrained LLM to a valid candidate (or returns targeted retry, not multi-list/doc detour).
6. **Explicit command escape with active context**
   - Active clarifier context + `"open recent"` (non-colliding command) executes command via known-noun routing.
   - Command-like input that remains unresolved against active options must still follow the bounded LLM ladder before unrelated fallback (see blocker #7).
7. **Ladder compliance (mandatory blocker)**
   - Active option context + deterministic unresolved input must attempt bounded LLM before any unrelated downstream fallback.
7a. **Standalone unresolved no-escape blocker (mandatory)**
   - Active option context + command-like unresolved input (for example typo/polite variant) must not escape to unrelated downstream routing before bounded LLM attempt.
8. **Safe fallback compliance (mandatory blocker)**
   - LLM fail/abstain/timeout/429/low-confidence must produce safe clarifier and must not execute.
9. **Precedence compliance (mandatory blocker)**
   - Ordinal without scope cue + active latch resolves active widget first.
   - Ordinal with explicit scope cue resolves to the cued source (`from chat` -> chat, `from active widget` -> widget).
10. **Phase C gate compliance (mandatory blocker)**
   - LLM `select` executes only when addendum gates pass; otherwise clarifier-only.
11. **Scope-cue precedence blocker (mandatory)**
   - With active widget selection context, explicit `from chat` input must reach scope-cue re-anchor logic (no early bypass return).
12. **Scope-bound candidate blocker (mandatory)**
   - `from chat` arbitration must not pass widget-entry-only candidates to LLM when chat panel options exist.
13. **Need-more-info blocker (mandatory)**
   - When scope is explicit but candidates are insufficient/ambiguous for that scope, resolver must return clarifier/`need_more_info` (no forced execution, no unrelated fallback).

## Risks / Mitigations
- **Risk:** Cross-list binding if contexts leak.
  - **Mitigation:** Strict separation + precedence rule + resolver gating.
- **Risk:** Resolver intercepts non-selection queries.
  - **Mitigation:** primary `isSelectionLike` gate + unresolved-active-option exception + shared question-intent guard.

## Notes
- This plan does not change widget registry schemas. It only manages selection routing.
- Coordinate with `widget-ui-snapshot-plan.md` to keep chat vs widget separation consistent.
