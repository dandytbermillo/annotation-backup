Inserting a collapsibleBlock in TipTap – Behavior and Fixes
Selection Position After insertCollapsibleBlock
After running the insertCollapsibleBlock command, we need to verify where the cursor lands. In typical cases, the selection remains inside the newly inserted collapsible block’s content (i.e. the cursor is placed within the block’s inner content). The extension’s command then finds the block by scanning up the selection’s ancestor chain for a node of type collapsibleBlock. If it finds the block (setting a collapsibleDepth), it means the selection’s $from is indeed inside the block. In those cases the cursor stays within the block (e.g. at the end of the template content that was inserted).
However, there is an edge case: If the block is inserted at a point that was at the end of an existing paragraph (especially at the end of the document), the ProseMirror transaction may split the paragraph and leave the cursor in the original paragraph above the new block. In other words, the selection “jumps back” to the parent context instead of staying inside the block. In that scenario, the loop that searches for the collapsible block node finds nothing (collapsibleDepth remains null) because $from is still in the preceding paragraph, not within the new block. This confirms that when inserting at a document end position, the default behavior places the selection outside the block (in the previous sibling), whereas inserting in the middle of text tends to keep the selection inside the block’s content.
Doc Snapshot Examples: For clarity, consider a document with a paragraph:
Before insertion (cursor at end): <p>Some text…[]</p> (cursor at end of paragraph)
After inserting block: <p>Some text…</p><div data-collapsible-block>…</div> and cursor stays in the paragraph above (since the paragraph was split at its end, effectively leaving the cursor before the block). The $from is in the paragraph, so no collapsible block is an ancestor in this case.
Conversely, if the cursor was in the middle of a paragraph:
Before: <p>Hello []world</p> (cursor between “Hello ” and “world”)
After: <p>Hello </p><div data-collapsible-block>…</div><p>world</p>. Here ProseMirror splits the paragraph into two around the inserted block. The selection after insertion will typically end up at the start of the second “world” paragraph (i.e. outside the block in this default scenario). Thus, even in a mid-paragraph insertion, the cursor doesn’t automatically stay inside the block – it moves to the content after the block. This default placement is why our extension code must handle the trailing paragraph carefully.
Transaction Mapping and Trailing Paragraph Insertion
The extension’s command addresses the need for a blank paragraph after the collapsible block by computing an insert position with ProseMirror’s mapping utilities. It finds the position immediately after the new block node using $from.after(collapsibleDepth). In practice, once collapsibleDepth is identified (the depth of the new block in the document), insertPos = $from.after(collapsibleDepth) gives the position right after the entire collapsible block node. The code then checks the node at that position (nodeAfter) in the transaction’s current document state:
If nodeAfter exists and is already a paragraph, it means there’s already a paragraph immediately following the block. For example, if the block was inserted in the middle of a paragraph, ProseMirror automatically created a paragraph for the text after the insertion point (as in the “world” paragraph above). In that case, the extension skips inserting another paragraph, since a trailing paragraph (with content) is already present. This prevents duplicate blank paragraphs.
If nodeAfter is not a paragraph (either there is a different node or, more commonly, nodeAfter is null because the block is at the end of the document), the command will insert a new empty paragraph at insertPos. This ensures that the collapsible block is not the final node – a blank paragraph is appended as a place for the cursor to go after the block.
Mapping Behavior: In a mid-paragraph insertion, the position $from.after(collapsibleDepth) actually points before the auto-generated trailing paragraph (since that paragraph is a sibling that comes right after the block). The nodeAfter check detects that paragraph and avoids adding another. At end-of-doc insertion, $from.after(depth) will equal the end of the document (no node after), so the new paragraph gets inserted in the transaction. This logic guarantees we add a trailing paragraph only when needed, based on the post-insert document state.
Avoiding Double or Missing Trailing Paragraphs
The above logic is designed to be reliable in inserting exactly one trailing paragraph when necessary. If a paragraph already follows, we do nothing to avoid double-inserts. If no paragraph follows, we insert one in the same transaction to maintain consistency. Under normal circumstances (e.g. inserting in the middle of a doc or at doc end), this means you should end up with exactly one blank paragraph after the block.
However, as noted, there is a potential skipped insertion scenario when the selection isn’t inside the block after insertion (like the end-of-document case where the cursor stayed in the previous paragraph). In that case, our code will wrongly think nodeAfter is irrelevant because it never found the block at all (collapsibleDepth was null, so we return early without inserting). The result would be a missing trailing paragraph at the document end. This is a corner case that highlights why ensuring the selection is correctly placed is important. In practice, we’d want to adjust the command so that the selection either remains in the new block (so collapsibleDepth is found) or we handle a null collapsibleDepth by still inserting a paragraph after the newly inserted node.
Aside from that edge case, the sibling check using nodeAfter works well to avoid duplicate paragraphs. For example, if a user inserts a collapsible outline in the middle of a paragraph, the text after the cursor becomes a normal paragraph following the block. The command sees that and refrains from adding an extra empty paragraph, so you don’t end up with two paragraphs in a row. Conversely, if the block is at the end with no sibling, the empty paragraph is reliably added in the same step.
Undo/Redo History Impact
We must ensure that inserting the block and the trailing paragraph count as a single user action in history. With TipTap’s command chaining, multiple changes can be combined into one transaction (and thus one undo step)
tiptap.dev
tiptap.dev
. However, the current implementation may be causing two separate transactions: one for the block insertion (commands.insertContent(...)) and one for the trailing paragraph (tr.insert(...) with dispatch). If these are dispatched separately, the user would experience two undo operations – e.g. first Undo removes the blank paragraph, second Undo removes the block – which is not ideal for a single insert action.
In our extension code, the trailing paragraph is inserted via a chained custom command, but note that we explicitly call dispatch(tr) inside that command. This suggests that the second insertion might be applied as its own transaction. Unless TipTap’s chaining is capturing these into one atomic transaction, it’s safer to assume they may appear as separate steps in the history. Indeed, if you test Undo after inserting a block, you might find that it requires two presses to completely undo the insertion (one to remove the empty paragraph, one to remove the block).
Merging into one step: The goal is to have both inserts happen in one transaction or at least one undo group. The best practice is to perform the trailing paragraph insertion as part of the original transaction that creates the block. This could be done by constructing a single ProseMirror transaction that inserts both the block and (if needed) an empty paragraph, before dispatching. By doing so, the history plugin will treat it as one change. If it’s not feasible to do in one commands.insertContent, another approach is to mark the trailing-paragraph addition transaction with addToHistory: false so it doesn’t create a separate undo step
discuss.prosemirror.net
. ProseMirror allows tagging a transaction with metadata to skip history: “You can set an addToHistory metadata property of false on a transaction to prevent it from being rolled back by undo.”
discuss.prosemirror.net
. In TipTap, you can do this via the chainable command API (editor.chain().setMeta('addToHistory', false)) before the insert, or directly on the transaction as shown in the ProseMirror docs. Using this meta flag on the trailing-paragraph insertion ensures it doesn’t record an extra undo entry.
Recommendation: Refactor the command so that the block insertion and trailing paragraph insertion occur in one captured transaction. For example, you might manually create the collapsible block node and an empty paragraph node, then use tr.replaceSelectionWith(blockNode) followed by tr.insert(insertPos, paragraph) on the same tr, before finally dispatching once. This would yield one history item. If sticking with the current approach, consider using tr.setMeta('addToHistory', false) on the trailing paragraph step so that TipTap’s history (or ProseMirror’s history plugin) merges it with the previous insertion. The end result should be a single Undo that removes the block and its trailing paragraph together.
Comparison to Similar Node Insertions (Callouts, Toggle/Details Nodes)
Other TipTap/ProseMirror extensions that insert container-like nodes have tackled this problem in various ways:
TipTap Callouts: A callout (an aside/admonition box with content) is conceptually similar – it’s a block node that contains inner content and you typically want to continue writing after it. The TipTap callout extension (in TipTap v2 StarterKit or similar packages) doesn’t explicitly insert an extra paragraph on creation, likely because many setups include the Trailing Node plugin or rely on the user pressing Enter to exit. In some editors, pressing Enter on an empty callout might automatically convert that callout back to a paragraph or create a new paragraph below. If the callout extension doesn’t handle Enter key specifically, one must ensure a trailing paragraph exists so the user can click or arrow-down out of the callout. The common solution is indeed to use a trailing node plugin or command similar to what we’re doing.
Toggle Lists / Collapsible Lists: These are often implemented as list items that can nest content and collapse, like an outline or details block. In Outline or Notion, for example, a “toggle list” item is essentially a bullet that can contain child blocks. Exiting from such a list item usually happens by pressing Enter twice or Enter on an empty item. ProseMirror’s standard list behavior (from splitListItem in the list commands) is that pressing Enter in an empty list item will lift it out of the list – effectively creating a new paragraph below the list. This is analogous to exiting a toggle block. TipTap likely leverages ProseMirror’s list commands: for instance, if you had a toggle list implemented as a bullet list, hitting Enter on an empty sub-item would use liftEmptyBlock or splitListItem to break out. In our case, the collapsible outline isn’t a list item; it’s a standalone node, so the exit behavior must be handled differently (either by always appending a paragraph or by a custom key binding).
Code Blocks (exit behavior): A good parallel is how code blocks work. ProseMirror provides an exitCode command that specifically handles moving out of a code block. When the cursor is at the end of a code block and the user presses Enter, exitCode will insert a default block (paragraph) after the code block and move the cursor to it
tiptap.dev
. TipTap includes this in its default keymap for code blocks. We can mirror that approach: essentially, our trailing paragraph insertion is doing an “exit” facilitation similar to exitCode. The difference is we’re triggering it immediately on insert, rather than waiting for an Enter key. But the concept is the same – ensure there’s a paragraph to move into. Notably, TipTap’s code block doesn’t automatically add a trailing paragraph on creation (because you typically continue typing inside it), but the exit mechanism is there when needed. For collapsible blocks, users often want to continue normal writing after the block, so proactively adding the paragraph (as we do) is a user-friendly approach.
TipTap Trailing Node Extension: TipTap actually provides a built-in Trailing Node extension for exactly this purpose – to guarantee the document always ends with an empty node of a given type (often a paragraph)
tiptap.dev
. Many editors include this by default to avoid the situation where a user can’t place the cursor after the last node (especially if the last node is non-text). If we enable the trailing node extension (configured for paragraph) in the editor, it would automatically handle adding a blank paragraph after any final block node. This means even for our collapsibleBlock, if it ends up at the end of the doc, an empty <p> would appear after it. This is a more generic solution; however, it will add trailing paragraphs in all cases where the doc ends in a non-paragraph node (images, embedded content, etc.), which is often desirable. If not using that extension globally, our manual approach must replicate that behavior just for the collapsible block command.
Keyboard vs Transaction Approaches: Some similar extensions use a keyboard shortcut or input rule to handle exiting. For example, as mentioned, lists and code blocks rely on pressing Enter (or a specific key) to exit the node. Another pattern is chaining commands: e.g., TipTap’s toggleNode or wrapInList commands might internally call a sequence of ProseMirror commands (splitBlock, lift, etc.) to both insert the node and move the cursor appropriately. In our case, the chain of insertContent then insert(trailing paragraph) is effectively chaining two commands. We might consider, alternatively, using something like:
editor.chain().focus()
  .insertCollapsibleBlock()      // our command
  .createParagraphNear()         // TipTap/PM command to insert an empty paragraph next
  .run()
Where createParagraphNear is a ProseMirror command that “creates an empty paragraph after the selected block node” if possible
tiptap.dev
. This could simplify adding the trailing paragraph as part of a single chain. (This command is available in TipTap’s command list). Ensuring the selection stays inside the block for the moment of adding might be necessary, or one could set a NodeSelection on the block and then createParagraphNear. In any case, the strategies used by callouts and toggleable nodes boil down to: use existing commands like splitBlock/liftEmptyBlock on Enter or always append a paragraph after insertion. We chose the latter for immediate reliability.
Plain Mode vs Yjs Collaborative Mode Differences
When using TipTap in plain (single-user) mode versus Yjs collaborative mode, the core insertion logic should remain the same, but there are a few considerations:
Transaction Handling: In Yjs collab mode, all changes are mediated through Yjs updates. Multiple ProseMirror steps combined quickly might be batched differently. The plain mode uses the standard ProseMirror history plugin (as we enabled history: true in StarterKit), whereas the collaborative mode might use Yjs’ own history or none at all (since Yjs uses its undo manager). In practice, our goal is still one logical operation. If our plain-mode implementation results in two ProseMirror transactions, it would also produce two Yjs updates. Ideally, we want to emit one Yjs update for this entire insert. So merging into one transaction is even more important in collab mode to avoid conflicting or extra steps that could be visible to other users. In collaborative mode, if two separate transactions occur back-to-back, you might momentarily desync remote cursors or create odd undo groupings on each client. By making it a single transaction (or marking the second part as non-history), we minimize those issues.
Trailing Node Plugin in Collab: Often collaborative editors include the trailing node plugin to avoid empty-doc or selection-stuck problems. If the Yjs version of this editor already had a trailing paragraph extension always on, the behavior after insertion might already ensure a blank paragraph at the end. In that case, our manual insertion of a paragraph might be redundant (or the trailing plugin might immediately add one if we didn’t). It’s worth checking if the Yjs mode had that extension active. The plain mode “Option A” here seems to re-implement all the fixes from collab mode, so possibly the Yjs mode relied on the trailing node plugin instead of custom code. Ensure that in collab mode, the addition of a trailing paragraph still works as expected – Yjs should treat it just like any other content insertion. There is a known issue that if the trailing node extension is used with a custom document schema in collab, it can create an empty paragraph on every remote update
github.com
 (a Nextcloud issue reference), but that’s more about initial load. In our context, one extra paragraph at the end is intended behavior.
Selection Mapping Differences: The Yjs collaborative plugin (prosemirror-yjs) may sometimes handle selection mapping slightly differently, but typically it respects ProseMirror transactions. One thing to watch: if the selection wasn’t inside the block (the edge case we discussed), a remote user might see the cursor still in the old paragraph while a block appears after it. This could be confusing. The fix – ensuring the cursor ends up inside the new block or at least at the end of the new blank paragraph – should be applied consistently in both modes. We didn’t find evidence that collab mode inherently fixes the selection placement; it likely behaves the same as plain mode unless additional logic was added.
In summary, there aren’t fundamental differences in how insertCollapsibleBlock should behave between plain and Yjs modes, but it’s crucial to implement the solution (single-transaction insert with trailing paragraph) in a way that’s compatible with collaborative editing. That means using the chain or transaction approach that merges steps, so that collaborators see one atomic change. The good news is that if we do this as one ProseMirror transaction, Yjs will emit it as one update. No extra undo steps will be introduced in Yjs mode either (Yjs undo/redo will treat the whole insertion as one item as well, or you can manage it with Yjs’ undo manager). Just be mindful of any Yjs-specific plugin like “awareness cursors” – if the selection is moved programmatically (e.g. to inside the block), those should update accordingly.
Best Practice: Implement the fix in plain mode (single transaction insertion) and test it in collaborative mode to ensure the behavior is consistent. The goal is that after using the “Outline” template button, the new collapsible section appears with the cursor inside it (probably at the start of the first paragraph in the block’s content), and an empty paragraph is already present after the block in the document. This way the user can immediately start typing in the block, or navigate out and continue writing after it, all in one seamless action that Undo/Redo treats as one step. This approach mirrors what other node insertions (like code blocks and lists) do via their own commands (e.g. exitCode or list splitting), and it aligns plain and collaborative behavior for a smoother editing experience.
Sources: The analysis above is supported by the extension code and ProseMirror documentation: the insert command’s selection handling and depth logic, the transaction logic for adding a trailing paragraph, and ProseMirror’s guidance on managing history entries
discuss.prosemirror.net
 and exiting block nodes
tiptap.dev
.