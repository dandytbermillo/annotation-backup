From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
Subject: [PATCH] Break toolbar skip loop and gate snapshot auto-centering

---
 components/annotation-canvas-modern.tsx | 212 ++++++++++++++++++++++++++------
 1 file changed, 175 insertions(+), 37 deletions(-)

diff --git a/components/annotation-canvas-modern.tsx b/components/annotation-canvas-modern.tsx
--- a/components/annotation-canvas-modern.tsx
+++ b/components/annotation-canvas-modern.tsx
@@
-    setTimeout(() => {
-      const mainPanel = restoredItems.find(item => item.itemType === 'panel' && item.panelId === 'main')
-      if (mainPanel?.position) {
-        const mainStoreKey = ensurePanelKey(noteId, 'main')
-        const panelPosition = mainPanel.position
-        const panelDimensions = mainPanel.dimensions ?? DEFAULT_PANEL_DIMENSIONS
-
-        // Get current camera state for visibility check and panToPanel
-        const currentCameraForVisibility = {
-          translateX: canvasState.translateX ?? 0,
-          translateY: canvasState.translateY ?? 0,
-          zoom: canvasState.zoom ?? 1
-        }
-
-        // panToPanel expects x/y instead of translateX/translateY
-        const currentViewport = {
-          x: canvasState.translateX ?? 0,
-          y: canvasState.translateY ?? 0,
-          zoom: canvasState.zoom ?? 1
-        }
-
-        // Check if panel is visible in current viewport
-        const isPanelVisible = isPanelVisibleInViewport(
-          panelPosition,
-          panelDimensions,
-          currentCameraForVisibility
-        )
-
-        // Check if this is a newly opened note (centering mechanism)
-        const isNewlyOpened = freshNoteSeeds?.[noteId] !== undefined
-
-        // Decision tree:
-        // 1. Newly opened note → Always center (regardless of visibility)
-        // 2. Reload/tab switch + visible → No centering, just highlight
-        // 3. Reload/tab switch + NOT visible → Center it
-        const shouldCenter = isNewlyOpened || !isPanelVisible
-
-        if (shouldCenter) {
-          panToPanel(
-            mainStoreKey,
-            (id) => id === mainStoreKey ? panelPosition : null,
-            currentViewport,
-            (newState) => {
-              if (newState.x !== undefined && newState.y !== undefined) {
-                setCanvasState(prev => ({
-                  ...prev,
-                  translateX: newState.x!,
-                  translateY: newState.y!,
-                }))
-              }
-            }
-          )
-          debugLog({
-            component: 'AnnotationCanvas',
-            action: 'auto_center_on_snapshot_restore',
-            metadata: {
-              noteId,
-              panelPosition,
-              reason: isNewlyOpened ? 'newly_opened_note' : 'note_not_visible_in_viewport',
-              isPanelVisible
-            }
-          })
-        } else {
-          // Panel is visible, skip centering
-          debugLog({
-            component: 'AnnotationCanvas',
-            action: 'skipped_auto_center',
-            metadata: {
-              noteId,
-              panelPosition,
-              reason: 'panel_already_visible_in_viewport',
-              isPanelVisible: true,
-              panelScreenBounds: {
-                x: (panelPosition.x + currentCameraForVisibility.translateX) * currentCameraForVisibility.zoom,
-                y: (panelPosition.y + currentCameraForVisibility.translateY) * currentCameraForVisibility.zoom,
-                width: panelDimensions.width * currentCameraForVisibility.zoom,
-                height: panelDimensions.height * currentCameraForVisibility.zoom
-              },
-              viewportSize: {
-                width: typeof window !== 'undefined' ? window.innerWidth : 0,
-                height: typeof window !== 'undefined' ? window.innerHeight : 0
-              }
-            }
-          })
-        }
-      }
-    }, 100)
+    setTimeout(() => {
+      const runVisibilityCheck = () => {
+        const mainPanel = restoredItems.find(
+          item => item.itemType === 'panel' && item.panelId === 'main'
+        )
+
+        if (!mainPanel?.position) {
+          return
+        }
+
+        const latestState = canvasStateRef.current
+        const mainStoreKey = ensurePanelKey(noteId, 'main')
+        const panelPosition = mainPanel.position
+        const panelDimensions = mainPanel.dimensions ?? DEFAULT_PANEL_DIMENSIONS
+
+        const currentCameraForVisibility = {
+          translateX: latestState.translateX ?? 0,
+          translateY: latestState.translateY ?? 0,
+          zoom: latestState.zoom ?? 1,
+        }
+
+        const currentViewport = {
+          x: currentCameraForVisibility.translateX,
+          y: currentCameraForVisibility.translateY,
+          zoom: currentCameraForVisibility.zoom,
+        }
+
+        const isPanelVisible = isPanelVisibleInViewport(
+          panelPosition,
+          panelDimensions,
+          currentCameraForVisibility
+        )
+
+        const panelScreenBounds = {
+          x:
+            (panelPosition.x + currentCameraForVisibility.translateX) *
+            currentCameraForVisibility.zoom,
+          y:
+            (panelPosition.y + currentCameraForVisibility.translateY) *
+            currentCameraForVisibility.zoom,
+          width: panelDimensions.width * currentCameraForVisibility.zoom,
+          height: panelDimensions.height * currentCameraForVisibility.zoom,
+        }
+
+        const viewportSize = {
+          width: typeof window !== 'undefined' ? window.innerWidth : 0,
+          height: typeof window !== 'undefined' ? window.innerHeight : 0,
+        }
+
+        const isNewlyOpened = freshNoteSeeds?.[noteId] !== undefined
+        const shouldCenter = isNewlyOpened || !isPanelVisible
+
+        debugLog({
+          component: 'AnnotationCanvas',
+          action: 'auto_center_visibility_check',
+          metadata: {
+            noteId,
+            isNewlyOpened,
+            isPanelVisible,
+            panelPosition,
+            panelScreenBounds,
+            viewportSize,
+            camera: currentCameraForVisibility,
+          },
+        })
+
+        if (shouldCenter) {
+          panToPanel(
+            mainStoreKey,
+            id => (id === mainStoreKey ? panelPosition : null),
+            currentViewport,
+            newState => {
+              if (newState.x !== undefined && newState.y !== undefined) {
+                setCanvasState(prev => ({
+                  ...prev,
+                  translateX: newState.x!,
+                  translateY: newState.y!,
+                }))
+              }
+            }
+          )
+          debugLog({
+            component: 'AnnotationCanvas',
+            action: 'auto_center_on_snapshot_restore',
+            metadata: {
+              noteId,
+              panelPosition,
+              reason: isNewlyOpened
+                ? 'newly_opened_note'
+                : 'note_not_visible_in_viewport',
+              isPanelVisible,
+            },
+          })
+        } else {
+          debugLog({
+            component: 'AnnotationCanvas',
+            action: 'skipped_auto_center',
+            metadata: {
+              noteId,
+              panelPosition,
+              reason: 'panel_already_visible_in_viewport',
+              isPanelVisible: true,
+              panelScreenBounds,
+              viewportSize,
+            },
+          })
+        }
+      }
+
+      if (typeof window !== 'undefined') {
+        requestAnimationFrame(runVisibilityCheck)
+      } else {
+        runVisibilityCheck()
+      }
+    }, 100)
@@
-  }, [noteId, onSnapshotLoadComplete, skipSnapshotForNote, onSnapshotSettled, activeWorkspaceVersion])
+  }, [
+    noteId,
+    onSnapshotLoadComplete,
+    onSnapshotSettled,
+    activeWorkspaceVersion
+    // skipSnapshotForNote intentionally omitted to prevent the guard from re-running after
+    // we clear the flag via onSnapshotSettled. The flag is read during the render triggered by
+    // setSkipSnapshotForNote, so the skip still applies on each new note selection.
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  ])
