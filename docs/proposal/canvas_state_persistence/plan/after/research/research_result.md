Likely Root Cause and Lifecycle Analysis
1. Snapshot Restore (Most Likely): The code restores a saved “snapshot” of the canvas state (including panel positions and camera) when opening a note. This happens immediately on note mount and can reposition the main panel to a previously saved coordinate (an “old” position) before centering occurs. The snapshot effect runs on the noteId change, merging saved panel coordinates into the canvas state and setting the viewport to the last saved translateX/Y (camera). In the described scenario, the snapshot likely places the main panel at an outdated location while the canvas (viewport) is initially at that saved offset (appearing motionless). Shortly after, the centering logic kicks in and pans the viewport, bringing the panel back to the expected position. The timing suggests the snapshot restore’s panel placement is happening just before the explicit centering, causing a visible “teleport” of the panel to the old coordinate (then corrected by the pan).
2. Centering Retries and Timing: The note-open handler triggers multiple camera-center operations in rapid succession. Upon selecting a note, it calls centerNoteOnCanvas immediately and schedules another centering shortly after. Additionally, after the canvas snapshot load completes, it schedules two more centering attempts (with delays) via pendingCenterAfterLoadRef. This aggressive retry behavior means the viewport is being adjusted several times. If a center call happens before the panel’s correct position is established (e.g. running while the snapshot is still restoring or the panel DOM isn’t ready), it may center on a wrong coordinate. Notably, the centering implementation will even fall back to a stored workspace or dataStore position if the panel isn’t yet in the canvas items. This suggests that an early center attempt could use a stale position (e.g. a cached workspace coordinate) and initiate a pan based on that. However, because centering moves the camera (viewport) rather than the panel itself, it mainly accounts for the panning part of the “snapback” (the smooth viewport motion). The instant teleport of the panel is better explained by the panel’s position being reset (via snapshot or seeding) rather than the camera. In short, the centering system contributes to the timing chaos – multiple centering calls can conflict or override each other – but on its own it moves the viewport, not the panel’s world position.
3. Workspace Seeding: On a first-time note open (when no saved state is present), the canvas uses “workspace seeding” to place the main panel at a pre-defined coordinate (from the workspace data or a default). This runs in an effect and is skipped if the panel already exists or if state was hydrated from storage. If a bug causes this to run in cases it shouldn’t (for example, running for a note that isn’t truly brand new), it could override the panel’s position with a workspace mainPosition at an odd time. That would manifest as the panel jumping to that coordinate (since this effect directly mutates the panel’s position in state). Given the telemetry in code, the conditions aim to prevent running during note switches or after snapshot hydration. It’s less likely the primary culprit here, because the scenario involves reopening an existing note (which likely had a snapshot or cached position, causing the hydration/snapshot path to be taken instead of seeding). Nonetheless, if this did run erroneously, it would target the panel (not the camera) and could cause a sudden panel relocation prior to centering – another possible source of the teleport.
4. Camera Persistence (Least Likely): The camera persistence system is passive in this flow. It listens to camera changes and queues them to save (debounced) to a database. Unlike snapshot restore, the provided code doesn’t apply a persisted camera state on load – it only saves changes. There is no evidence of a “load last camera position from DB on note open” in the code; instead, the last viewport is restored from the snapshot (local storage) as discussed above. Therefore, the camera persistence hook isn’t likely causing the snapback. The only theoretical impact could be if it persisted a transient camera state mid-centering, but that wouldn’t affect the immediate UI. We can consider this component safe in terms of not moving the camera or panel during the note-open sequence.
Ranking Summary: Snapshot restore is the top suspect for the panel “teleport” (it repositions the panel instantly based on saved data). Centering logic (especially overlapping retries) is the next suspect for the viewport pan and potential race conditions. Workspace seeding is a moderate risk if it inappropriately adjusts panel coordinates on note switch. Camera persistence is benign for UI state (save-only in this context). The combination of snapshot restore and immediate centering is very likely what produces the snapback: the main panel is rendered at an old position from the snapshot, then the camera centering (possibly using a different target) corrects the view.
Instrumentation Points for Timing & Causality
To diagnose the exact sequence and culprit, we should add instrumentation (e.g. console logs or debug telemetry) at the following points in the lifecycle:
Canvas State Updates (Viewport Changes): Instrument setCanvasState in the canvas component to log when the translateX/translateY are set and by whom. The code already logs calls to setCanvasState, but we should ensure it captures a timestamp and the call stack or an identifying tag (e.g. “snapshot restore vs centerOnPanel vs user pan”). This will tell us when the viewport is moving versus when it’s static. Noting the sequence of translateX/Y changes (and their origin) will distinguish the initial “teleport” (likely no camera move, just panel moved) from the subsequent pan (camera changes).
Panel Position Mutations: Wrap the points where the main panel’s position is set or changed. Key places:
The workspace seeding effect where we call setCanvasItems to update the main panel position to workspaceMainPosition. We should log when this runs, for which note, and what position is being applied. If this fires during the problematic note open, it’s likely involved in the jump.
The snapshot restore merge where setCanvasItems merges in restoredItems. Logging here should capture the restored main panel coordinates vs. any previous position. This will confirm if the panel was placed at an old coordinate from storage.
Also log the initial creation of the new panel in the canvas (within the noteIds sync effect) – it chooses a target position (default or workspace) for new panels. Logging the chosen targetPosition for the main panel on creation will show if a cached/workspace position was used initially.
Centering Operations: Instrument the centering logic in centerNoteOnCanvas and the underlying canvasRef.current.centerOnPanel:
When handleNoteSelect calls centerNoteOnCanvas, log the noteId and a timestamp (and maybe whether a snapshot is detected for that note). We want to see if the initial center call happened before or after the snapshot restore completed. Similarly, log the onSnapshotLoadComplete event firing and the centers it triggers.
Inside centerOnPanel (the imperative canvas method), add logs for each attempt to find the panel’s position. The implementation already prints console info when it finds a position from various sources (canvasItems, dataStore, workspace, DOM). We should enhance this to clearly indicate which source was used on the first attempt during the problematic sequence. For example, if it logs “Using workspace position for panel…position: {x, y}”, that means the panel wasn’t yet in state and it fell back to an older saved position. Capturing the timing of that relative to the snapshot merge is crucial.
Camera Persistence Hooks: While this is not expected to move anything, we can still instrument when the persistence flush runs or if any camera state is loaded. Ensuring that no unexpected camera set occurs from this path can help rule it out. For instance, log in the useCameraPersistence effect if it ever reads an initial camera (in this implementation it doesn’t, which is good) and when it persists a camera (just to see if it fires during the flurry of center moves).
Misc Timing Markers: It may also help to log at the start and end of the critical effects: e.g., when workspaceSeedAppliedRef effect is triggered vs when it finishes, when snapshot restoration starts and ends (we can log right before calling onSnapshotLoadComplete as a “snapshot done” marker), and when each center retry attempt runs. Having these timestamps will let us sequence the events:
e.g., “Opened note X – starting snapshot restore at T0”,
“workspace seeding applied position (if any) at T1”,
“centerOnPanel first attempt at T2 (panel not found, used fallback?)”,
“snapshot restore merged panel at position P (old) at T3”,
“onSnapshotLoadComplete at T4 (triggering post-load centering)”,
“viewport translateX/Y updated at T5…”, etc.
By correlating these instrumentation logs, we can definitively see which system alters the panel or camera first and causes the out-of-order update.
Recommended Fix Proposal
Based on the code review, the primary fix should address the race between snapshot restoration and centering. We want to avoid the panel jumping to a saved position only to be immediately re-centered. A few strategies to consider:
Defer or Conditionalize Centering when a Snapshot is Present: If a snapshot is being restored for the note, we should let that complete before doing any manual centering. Currently, the code always calls centerNoteOnCanvas as soon as a note is opened (even if we have saved state). We could gate this: for example, set a flag if loadStateFromStorage found a snapshot for the note, and skip the immediate centering in handleNoteSelect. Instead, rely on the pendingCenterAfterLoadRef logic which centers the note right after the snapshot load is complete. This ensures the canvas isn’t briefly showing the old layout. In practice, that means removing or guarding the centerNoteOnCanvas(noteId) call on note select when we anticipate onSnapshotLoadComplete will fire shortly. The pendingCenterAfterLoadRef already queues a center-on-note after snapshot loading, so the immediate center becomes redundant in that case (and harmful due to timing).
Synchronize Panel State with Centering: We should ensure the panel’s final position is set before doing the big camera move. If we skip restoring the old camera offset altogether (when the intention is to center), the panel wouldn’t appear to teleport. For example, we might choose to initially load the panel at the workspace/default position but not apply the old translateX/Y. Or conversely, apply the snapshot’s panel positions but hold off on rendering the panel until we adjust the camera. One idea is to defer applying the snapshot’s viewport if we know a center-on-note will occur. Perhaps mark in state “pending center” and temporarily disable using snapshot.viewport in the initializer, so that the canvas starts in a neutral state (or already centered on the new panel’s position). This would eliminate the jarring offset on open. In summary, coordinate snapshot restore with centering: either don’t restore the camera (only restore panel layout) or delay showing it.
Guard Camera Persistence during Auto-Pan: During the automatic centering sequence, we can temporarily disable camera persistence updates. This is more of a cleanup to prevent persisting transient states. For instance, the slow pan animation (2s ease-in-out in centerOnPanel) might be sending camera updates to the backend. It’s wise to pause or ignore persistence while programmatically animating the camera. We could set the enabled flag to false in useCameraPersistence via some context state while a center animation is in progress, then re-enable after it completes. This avoids any feedback loop or interference (though in our case it’s mostly to avoid noise – it won’t fix the visual snap, but it prevents, say, a persisted mid-pan camera from being restored later unexpectedly).
Eliminate Redundant Centering Retries: The centering logic is robust but perhaps overly so (calling center multiple times with timeouts). Once we trust the sequence (with the above fixes), we might not need the extra 150ms delayed center in handleNoteSelect. It could be causing more harm than good (e.g., interrupting the smooth animation of the first center). Consider removing or significantly simplifying the retry scheme: for example, do a single center-on-note after load (which itself tries up to 10× internally to find the panel). That should suffice. Reducing these overlapping timers will make the viewport movement more predictable.
Workspace Seeding Safeguard: As a precaution, ensure the workspace seeding effect cannot run for notes that have existing positions or snapshots. The code’s conditions already aim for that (checking hydrationStatus.success and initialNoteRef). If our instrumentation shows any anomaly here (e.g., workspace_seed_applied_new_note firing when it shouldn’t), we should tighten the conditions. For instance, we might explicitly check a “hasSnapshot” flag and prevent seeding if true. Gating that ensures we don’t override the panel position from snapshot with a workspace position. In an extreme case, we could remove this effect entirely and handle initial placement in one place (the noteIds sync or the hydration logic), to avoid confusion.
Applying these changes would likely resolve the snapback. In concrete terms, one approach would be:
Skip immediate centering if note had saved state: Modify handleNoteSelect to detect if resolveMainPanelPosition (or a new hasSavedLayout check) returns something. If so, set pendingCenterAfterLoadRef but do not call centerNoteOnCanvas right away. Let the onSnapshotLoadComplete callback do it. This way, the panel will load into its last known state (which might even already be near the center of the viewport if the user left it there) and then a single smooth pan will adjust if needed, with no initial jump.
Alternatively, always center on open and ignore old camera: If the product decision is to always focus the note freshly, we could do the opposite – not restore the old camera at all. Always start at a neutral camera (perhaps the default or current canvas view) and then center. This would sacrifice the “resume where you left off” behavior in favor of consistency. Given the user’s complaint, they likely prefer the note to appear centered. So this is viable: do not apply snapshot.viewport.translateX/Y when opening via the workspace list. The code already computes a centered position for new notes with no state – perhaps we use a similar approach for existing notes: combine the known panel position with current view to center it immediately.
Verify with Instrumentation: After implementing, we’d use the added instrumentation to verify the sequence: the panel should no longer ever be drawn at an out-of-date coordinate. The viewport should transition at most once, smoothly, to the final centered position. Any residual “snap” in logs (panel coordinate changes without user action) would indicate further tweaks needed.
In summary, the fix centers on coordinating the snapshot restore and centering so they don’t step on each other. By deferring one or the other and eliminating unnecessary intermediate steps, we can prevent the panel from appearing to jump and “snap back”. This targeted adjustment, along with better logging, will address the root cause of the teleport-then-pan behavior and make it far easier to follow the canvas state changes in the code.
Additional Observation (2025-10-20)
- Attempting to override the snapshot’s main-panel position with workspace/pending coordinates forced multiple notes to the same default (e.g., 2000 × 1500) and left them overlapped. This shows the workspace cache is still stale and should not replace the snapshot blindly. Any fix needs to reconcile snapshot data, workspace state, and live centering rather than unilaterally forcing one source.

Next Steps
- Instrument snapshot restore vs. centering to capture which event modifies `translateX/translateY` and panel positions.
- Refresh workspace cache when we know the latest position (after successful centering) instead of overriding during restore.
- Revisit centering retries; ensure they wait until hydration reports the new position to avoid using stale fallback coordinates.
