Resolving the flushSync Warning in a TipTap Portal with Annotation Marks
Background: The flushSync Warning in React
When using React TipTap (built on ProseMirror) inside a React portal, you may encounter a runtime warning in the console:
Warning: flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.
This warning indicates that a call to React’s flushSync function occurred while React was in the middle of a render/update cycle. In general, flushSync forces React to synchronously apply state updates immediately. If it’s invoked at the wrong time (e.g. during another component’s rendering lifecycle), React complains because it could disrupt the normal batched rendering process
github.com
. In our case, the warning appears when rendering a TipTap <EditorContent> inside a floating Inspector portal, specifically when the editor content includes annotation marks.
Context: The application uses TipTap v3 with a custom extension for “annotation” marks (e.g. inline comments or highlights) and a floating block inspector component (implemented in lib/extensions/collapsible-block.tsx). The inspector is shown via ReactDOM.createPortal when showInspector is true, and it renders a <EditorContent> tied to a TipTap editor instance. Notably, the TipTap editor is initialized with immediatelyRender: false for SSR compatibility. The inspector itself remains functional (interactive) despite the console warning, but the warning signals an underlying timing issue in how updates are flushed.
Root Cause Analysis
TipTap’s Rendering Mechanism: Under the hood, TipTap integrates React with ProseMirror by using React NodeViews. A NodeView in ProseMirror is a custom rendering for a document node, often backed by a React component in TipTap. TipTap’s ReactNodeViewRenderer creates a React component and attaches it into the ProseMirror DOM via a React portal
roseline.oopy.io
. To coordinate this, TipTap sometimes calls flushSync from React DOM to mount or update the React component immediately. For example, in TipTap’s source, the ReactRenderer class does:
// In TipTap ReactRenderer (simplified)
if (editor.isInitialized) {
  // On subsequent renders (editor already initialized), flush synchronously
  flushSync(() => { this.render() })
} else {
  // On first render, no flushSync needed
  this.render()
}
This is done to fix cursor position issues and keep the ProseMirror view in sync
roseline.oopy.io
. In essence, if the editor is already running (initialized), TipTap forces an immediate render of any new React NodeView content. Calling flushSync here ensures the DOM is updated synchronously for the new NodeView, rather than batched later, so that the editor’s state (like selection and cursor) remains correct.
Why the Warning Appears: The warning arises when flushSync is invoked during React's rendering lifecycle. In our scenario, that happens if a TipTap component tries to flush updates while React is in the middle of mounting or reconciling components. A common trigger is mounting a TipTap NodeView or re-mounting the <EditorContent> with an already-initialized editor. For instance, if the Inspector portal appears and attempts to render <EditorContent> for an editor that was previously initialized, TipTap’s internal logic will call flushSync as part of that mounting process (because editor.isInitialized is true)
roseline.oopy.io
. React sees this as “flushSync inside a lifecycle” (since the portal’s mount is in progress) and issues the warning.
Annotation Marks as a Contributing Factor: The warning only surfaces when annotation marks are present because they likely introduce a React NodeView or extra render step that triggers flushSync. In TipTap, simple text or basic nodes (like paragraphs) don’t use React NodeViews and thus mount without flushSync. However, annotation functionality is often implemented either as a custom mark with decorations or as an inline node with a NodeView (for example, a highlight with an interactive badge or comment icon). If the annotation extension utilizes a React-driven element (even indirectly), it can provoke the flushSync behavior. Indeed, developers have observed that content containing extensions with addNodeView will trigger this exact warning on re-render
github.com
. In our case, when an annotated segment is being rendered in the inspector, TipTap likely tries to mount a React component for it, or the annotation triggers an immediate state update in a NodeView. This causes TipTap to call flushSync while the inspector portal is rendering, hence the warning.
Another possible contribution is that the Inspector’s collapsible block extension might itself use a NodeView. For example, if the inspector is a custom NodeView that opens in a portal for editing a block’s content or metadata, it would invoke flushSync on mount. If that NodeView’s React component uses hooks that update state immediately (e.g. in useEffect on mount), it can cause a nested re-render. A TipTap user reported a similar issue: “In my node views, I have some hooks that trigger re-renders after the view mounted, I think that caused the flushSync was called from inside a lifecycle method issue.”
github.com
. In their case, the combination of the NodeView’s initial synchronous render and an immediate re-render led to the flushSync warning. The presence of annotation marks could be causing a similar double-render situation (for instance, the annotation extension might update some state or decorations right after initial load).
Summary of Root Cause: The flushSync warning is essentially a timing bug caused by TipTap’s attempt to synchronously mount or update the editor’s React components (NodeViews/portals) at an unsafe time. In a portal scenario, toggling the inspector on with existing annotation content means the TipTap editor is already initialized, so <EditorContent> will flush a render immediately, colliding with React’s ongoing render work
roseline.oopy.io
. Annotation marks contribute by introducing the very React-rendered content (or extra transactions) that invoke flushSync. This is an internal implementation detail of TipTap’s integration with React, not a fatal error in our code – but we can refactor our usage to avoid provoking the warning.
Strategies to Eliminate the Warning (While Keeping Interactivity)
To fix this, we need to avoid calling flushSync during React render. Since flushSync is called inside TipTap, our approach is to adjust when and how TipTap components mount or update. Below are several non-breaking refactor strategies:
1. Defer Portal Rendering to Outside the Render Cycle
Instead of mounting the inspector’s <EditorContent> immediately during the React render phase, we can defer it to the next task or microtask. In practice, this means delaying the actual insertion of the TipTap editor into the DOM until after React has completed the current update. There are a couple of ways to do this:
Use a microtask or timeout: For example, when showInspector becomes true, render a lightweight placeholder in the portal and then, in a useEffect, mount the real <EditorContent> after a tick. You can implement a custom <DelayedMount> component that waits one tick (using Promise.resolve() or setTimeout(0)) before rendering its children. One developer resolved the flushSync issue by wrapping the complex content in a delayed render: “so I created a delay component… And now the issue is gone.”
github.com
github.com
. In our case, we might do:
{showInspector && (
  <DelayedMount delay={0}>
    <EditorContent editor={inspectorEditor} />
  </DelayedMount>
)}
The first render shows nothing (or a fallback) and schedules the actual editor mount right after the commit. By the time <EditorContent> really mounts, React’s lifecycle is idle, so TipTap’s internal flushSync happens outside the original render cycle (avoiding the warning). The trade-off is a very slight delay (a few milliseconds) in showing the inspector content, which is usually not noticeable.
Trigger portal open in a layout effect: Similar in concept, you could render the portal only after an effect runs. For instance, manage an internal portalVisible state that you set to true in a useLayoutEffect/useEffect when showInspector is true. This way, React completes the parent update, then immediately executes the effect to show the portal. This again shifts the <EditorContent> mount to after rendering. A microtask timing (using Promise.resolve().then(...)) also works for deferring work to the next event loop tick
github.com
. This technique has minimal impact on interactivity — the inspector remains responsive, just the rendering is scheduled slightly later to placate React.
Trade-off: These approaches add a bit of complexity and an extra render step, but they do not break any functionality. The inspector might appear an instant later, but remains fully interactive. The upside is that React’s warning is eliminated because we respected its scheduling. This solution is stable and does not require altering TipTap’s source; it merely changes when we mount TipTap components.
2. Reinitialize or Reset the Editor Before Portal Mount
Another strategy is to ensure the TipTap editor isn’t in the “initialized” state when mounting in the portal, so that TipTap won’t call flushSync at all on first render. There are two ways to achieve this:
Destroy and recreate the editor instance for the inspector: If the inspector’s editor is separate from the main content editor (for example, a dedicated editor to edit an annotation’s text or a block’s content), you can create a fresh TipTap editor instance each time the inspector opens. A new editor will treat its first <EditorContent> mount as initial (not calling flushSync). In TipTap’s default behavior, editor.isInitialized is false until the first EditorContent attaches, so no flushSync is used on that first mount
roseline.oopy.io
. By reconstructing the editor each time, you avoid the re-mount flushSync issue altogether. The editor content (e.g. the annotation text or block data) can be passed in as JSON or HTML when instantiating. Since you use immediatelyRender: false, TipTap will not attempt to render until we mount it manually, giving us control.
Trade-off: Recreating the editor can be slightly expensive if done very frequently, and you need to be careful to persist any changes the user made (e.g. save the annotation draft before closing, then re-load into a new editor). However, if the inspector is for editing a self-contained piece of content (like a comment), re-initializing might be perfectly acceptable and keeps the lifecycle clean. The user likely won’t notice this under the hood, as long as the content is preserved.
Manually reset TipTap’s internal initialization flag: This is a more hacky variant, but worth mentioning for completeness. TipTap’s <EditorContent> component (in React) internally tracks an initialized flag to decide whether to flush sync. In fact, a patch was proposed in TipTap’s repository to reset the initialized state on unmount so that a re-mount won’t trigger flushSync
github.com
. If you have access to TipTap’s internals or a way to monkey-patch, you could emulate this: e.g. call editor.view.destroy() or set editor.contentComponent.initialized = false when your inspector unmounts. This forces TipTap to treat the next mount as a fresh render. However, directly mutating internals is high-risk and not recommended in production, as it relies on non-public APIs. It’s safer to either destroy the whole editor (which calls TipTap’s own cleanup) or use the re-creation approach above. We mention this because it highlights the root cause: the editor was still flagged as initialized on re-mount, which is why flushSync was being called – resetting that flag prevents the unwanted synchronous flush
github.com
.
Trade-off: Reinitializing or resetting the editor ensures no flushSync is called during a React render, at the cost of additional editor setup each time. The approach is non-breaking to the UI (assuming content is synced), but consider performance if the content is large or if the inspector opens very frequently. In many cases (like editing small annotation texts or block settings), this cost is negligible and yields a clean, warning-free render.
3. Avoid Immediate State Updates in NodeViews or Extensions
If the flushSync issue is exacerbated by how the annotation or inspector extension is implemented, we should refactor those to avoid any immediate re-renders during mount. For example, if the collapsible block’s React NodeView (the inspector component) runs a hook on mount that calls setState, that will schedule a React update while the NodeView is mounting, which can coincide with TipTap’s flushSync. The safer pattern is to perform such updates after the initial render.
One technique (similar to strategy 1) is to delay any heavy UI initialization in the NodeView. In a shared TipTap discussion, a developer solved the flushSync warning by deferring the rendering of a complex child component in their NodeView by 100ms
github.com
github.com
. They created a wrapper that initially renders a fallback (e.g. “Loading…”) and then, using setTimeout in an effect, swaps in the real component. This ensured that the NodeView’s initial mount was simple and didn’t trigger additional React renders until after TipTap’s flush had completed. In our inspector, if we have any child components that aren’t immediately needed, we could apply a similar delay or use requestAnimationFrame to kick their rendering down the road by one frame.
For annotation marks: if the annotation extension triggers any synchronous logic on document load (for instance, iterating over marks to populate a sidebar, or adding decorations), consider making those asynchronous. Using Promise.resolve().then(...) or setTimeout with 0 delay can move such logic out of the critical render path. By doing so, you let the TipTap editor finish its initial render quietly. Then your extension’s post-processing can run without causing React to interject with warnings.
Trade-off: The goal is to remove any back-to-back renders during initialization. As a result, the UI might show a placeholder for a brief moment (as in the “Loading...” example), or some annotation-related UI might appear a split-second later. This is usually an acceptable trade-off to ensure stability. The interactive parts (buttons, forms, etc.) of the inspector remain functional; we’re only staggering their rendering to appease React’s timing. This approach does not break any data flow – it merely postpones it slightly.
4. Use Alternative Rendering Paths for Annotations (Advanced)
If after the above, the annotation marks themselves still seem to cause trouble, consider whether you can change how they’re rendered or handled:
Render annotations without React NodeViews: If your annotation mark doesn’t truly need a React component (for example, it just highlights text and maybe shows a tooltip on hover), you might implement it purely with ProseMirror decorations or DOM attributes. Marks in ProseMirror can be rendered as <span> with a class, and you can use CSS for highlighting. Any interactive behavior (like clicking to open the inspector) can be done by handling editor events or using a minimal external React component (outside the ProseMirror content) that appears on selection. By not using ReactNodeViewRenderer for annotations, you avoid TipTap’s flushSync logic entirely for those elements. This is a more architectural change: essentially treating annotations as a presentation layer concern (via CSS or absolutely positioned popovers) rather than embedded React components. It can drastically simplify rendering timing, at the cost of writing some manual DOM/CSS logic for interactivity.
Represent annotations as separate nodes (if appropriate): If managing annotations as marks is too complex, another approach is to use a node to encapsulate annotated text. For instance, a custom inline node that contains a child text node could represent an annotation. This node could be rendered with a simpler DOM structure. However, note that if you still use a React NodeView for it, you might reintroduce flushSync issues. A plain ProseMirror NodeView (not React) or a straightforward renderHTML in the extension could be safer. The trade-off here is that making every annotation a node could complicate your document schema and selection logic (marks are generally better for text highlights). This would be a heavy refactor and should be considered only if other methods fail.
Manual ProseMirror view mount (experimental): In special cases, you could bypass <EditorContent> for the portal and manually mount a ProseMirror EditorView into a DOM element of your choosing. TipTap’s Editor instance exposes a ProseMirror view (editor.view) and the underlying state. You might create a duplicate or synchronized view for the inspector. However, maintaining two EditorViews for one document is advanced and could lead to synchronization issues (e.g., two cursors). This is generally not recommended unless you have deep ProseMirror expertise. It’s a high-risk experiment: we mention it only because it theoretically avoids using React to render the content (thus no flushSync), but it introduces a host of complexity (e.g., ensuring the two views mirror each other). In most cases, sticking to one view and using the above React timing fixes is far preferable.
Trade-off: These alternative approaches are high-risk and often not necessary. They can eliminate flushSync at the root by reducing React’s involvement in rendering the annotation content, but they increase development complexity. If your current architecture already uses TipTap’s mark and NodeView system, try the timing solutions first before considering a major schema change.
Concurrent React Considerations
It’s worth noting that React 18+ concurrent features (like automatic batching, transitions, or Strict Mode double-invocations in development) make timing issues more prominent. TipTap’s use of flushSync is somewhat at odds with React’s concurrent rendering philosophy, which is why these warnings appear. In a fully concurrent scenario (e.g. if you were to use startTransition or if your app was SSR streaming), a flushSync could even cause harder errors or UI flicker. The TipTap team has been addressing some of these concerns in updates – for instance, they adjusted flushSync usage by queueing it in a microtask to avoid lifecycle conflicts
github.com
. The fix we discussed (resetting initialized on unmount) is part of making TipTap’s React integration more concurrency-friendly.
When embedding TipTap in portals or modals, test in development mode with Strict Mode enabled to catch these issues early. The Strict Mode intentionally invokes mount/unmount twice and uses concurrent rendering, which can trigger flushSync warnings reliably. Ensuring your implementation doesn’t throw warnings in Strict Mode is a good proxy for being concurrent-safe. If you still see flushSync warnings after applying the strategies above, it might indicate an underlying TipTap bug that needs a patch (in which case, checking TipTap’s issue tracker for recent fixes is advised).
Best Practices for TipTap Editors in Portals/Modals
To wrap up, here are some clean architectural patterns and recommendations for using TipTap editors inside portals or modals:
Mount Editors One at a Time: Avoid mounting multiple heavy editors simultaneously during one React render pass. If you open a modal with a TipTap editor while another editor is mounting, consider staggering them or ensuring they use separate instances. TipTap editors are global-ish in behavior (each creates a ProseMirror view and intercepts input events), so having two at once is fine, but be mindful of performance and event conflicts.
Prefer Fresh Editor Instances for Temporary UIs: For ephemeral UI like a floating inspector, it’s often cleaner to spin up a new Editor instance for that context rather than trying to share or recycle the main editor. The main document editor and the inspector editor can communicate through your application state (e.g., when an annotation is saved, apply it to the main editor’s doc). This decoupling prevents internal state bleed-through. With separate instances, you also isolate any flushSync or rendering quirks to that one editor.
Use immediatelyRender and shouldRerenderOnTransaction wisely: Since you have immediatelyRender: false for SSR (which is good to avoid hydration mismatches), you can programmatically trigger the initial render once on the client. For example, after the component mounts, you might call editor.commands.focus() or simply rely on the first transaction to render. If performance is a concern, you might also set shouldRerenderOnTransaction: false on the inspector’s editor, because you likely don’t need the React component re-rendering on every minor selection change. That option prevents needless React updates on each keystroke
tiptap.dev
, which can reduce the chance of any unintended flushes. Just be sure to manually update any UI that depends on editor state (TipTap provides hooks or commands to query active marks, etc., which you can call on relevant events).
Keep Portal Content Mounted if Re-used Frequently: If an inspector opens and closes very often (for example, a popover that might reopen for many different highlights), consider not unmounting the <EditorContent> at all. You could keep the component mounted and simply hide/show it with CSS or conditional rendering of a parent container. By keeping it mounted, you avoid repeating the mount process that triggers flushSync. Instead, you can update the editor’s content or state as needed for the new context. This approach ensures the expensive initialization happens only once. The downside is memory overhead if you keep many editors alive, so use this pattern judiciously (e.g., for a single inspector element that gets reused, it’s fine).
Monitor Known Issues and Updates: The flushSync warning is a known issue in libraries that use portals (even React-Bootstrap had similar reports). Keep an eye on TipTap’s releases and GitHub issues for any official fixes. For instance, the TipTap team addressed a similar bug by deferring flushSync to a safer time
github.com
. If a future version of TipTap further refines this, upgrading might resolve the warning without any workarounds. Until then, the strategies above are your toolbox for a stable integration.
Conclusion
The flushSync warning when using TipTap’s <EditorContent> in a React portal with annotation marks is essentially a timing issue caused by TipTap’s synchronous rendering of React components (NodeViews) colliding with React’s render cycle. By understanding TipTap’s internals and the role of annotation marks, we identified that re-mounting an already-initialized editor (especially with React-driven extensions) is the root trigger. We explored several solutions – deferring the portal’s rendering, resetting or recreating the editor instance, adjusting extension behavior, and more – all aimed at preventing that forbidden flush during React’s render phase.
Each solution comes with trade-offs in complexity, but all are non-breaking: they preserve the editor’s interactivity and user experience. In fact, most changes are under the hood, affecting when things render rather than what renders. Implementing a slight delay or lifecycle reset can eliminate the console noise and future-proof your editor against React’s stricter rendering model.
By applying these refactors and following best practices for embedding editors in modals/portals, you can maintain a clean, warning-free console and ensure your TipTap editor remains robust even as React evolves. The key is to let React do its work on its own schedule and introduce TipTap’s synchronous updates only when React is ready for them – essentially, moving those flushSync calls “to a scheduler task or microtask,” exactly as the warning advises.
github.com
Sources: