Isolation Reactivity Anti‑Patterns (Do Not Repeat)

Context
- Area: Isolation Provider + Minimap/Control Panel UI
- Recent attempt: add provider-level version bump, new snapshot API, UI gating, and “reason” tagging.
- Outcome: introduced a runtime error and confusing behavior while not addressing the original root cause cleanly.

Observed Error (from user report)
- File: `lib/isolation/context.tsx (257:30) @ useIsolatedDetails`
- Trace head (excerpt):
  - `useIsolatedDetails  lib/isolation/context.tsx (257:30)`
  - `EnhancedControlPanel  components/canvas/enhanced-control-panel.tsx (23:45)`
  - `ModernAnnotationCanvas  components/annotation-canvas-modern.tsx (493:9)`
- Source snippet at failure site:
  - `return useSyncExternalStore(ctx.subscribe, ctx.getIsolatedDetailsSnapshot, getServerSnapshot)`

Likely Root Causes
- Context shape drift across consumer/provider boundaries during an iterative patch:
  - New consumer hook `useIsolatedDetails()` depended on `getIsolatedDetailsSnapshot`, added in the provider in the same patch. Hot reload or stale chunk can leave consumer expecting a method the current provider instance lacks.
  - If `ctx.subscribe` or `ctx.getIsolatedDetailsSnapshot` is undefined (API mismatch), calling `useSyncExternalStore` throws at that callsite.
- UI hard dependency on a new hook during stabilization created a single point of failure in `EnhancedControlPanel`.
- Behavior conflation: adding “manual vs auto” reason tags changed UI semantics without a migration path and created inconsistency with other consumers (e.g., minimap stripes vs. list filters).

Specific Anti‑Patterns To Avoid
- Do not expand `IsolationContextValue` and immediately bind new UI to the new fields within the same change set. This risks runtime API skew (provider/consumer not in lockstep) and brittle hot-reload behavior.
- Do not introduce new hooks that call `useSyncExternalStore` unless the provider contract is proven present and stable. A null/partial context must never reach `useSyncExternalStore`.
- Do not gate correctness at the UI layer (buttons) instead of in the provider logic. UI gating can hide issues and mislead users.
- Do not change core priorities (e.g., marking main panel as `critical`) in the same patch as reactivity fixes. That couples behavioral changes and complicates verification.
- Do not replace a working subscription (`useIsolatedIds`) with a brand-new API (`useIsolatedDetails`) during a hot path refactor.

Concrete Errors Generated By The Attempted Fix
- Runtime failure in `useIsolatedDetails`: `ctx.subscribe` or `ctx.getIsolatedDetailsSnapshot` unavailable at the time of render (line 257).
- UX confusing state: “Isolate Unresponsive” behavior/label changed while minimap and list criteria diverged (manual vs auto).
- Increased surface area for regressions: multiple components adopting the new hook simultaneously without a fallback.

Safer Alternatives (Future Work, Not Implemented Now)
- Keep UI on the stable `useIsolatedIds()` subscription. If details are required, extend the provider with a backwards‑compatible shim, but have the UI fall back gracefully when the new field is absent.
- If adding a version counter, make it internal only at first. Do not export new hooks until verified end‑to‑end.
- Provider‑only gating: isolation actions (manual or auto) should be validated in the provider; UI should just request and render.
- Introduce new context fields behind a feature flag and validate with a dedicated test page before wiring them into production UI.

Rollback/Containment Guidance
- Prefer reverting UI to `useIsolatedIds()` and avoiding any “details” dependency until the provider changes are stabilized and fully tested.
- Avoid changing priorities (`critical` vs `high`) in the same PR as reactivity changes.
- Add a temporary in-provider guard: if a new field is missing, return a stable default rather than letting consumers crash.

Summary
- The attempted reactivity patch introduced an API contract change and a new consumer hook in one step, causing a runtime failure at `useSyncExternalStore`. Future patches must keep provider API additions strictly backward‑compatible, avoid binding new UI to unproven APIs, and keep gating logic inside the provider.

