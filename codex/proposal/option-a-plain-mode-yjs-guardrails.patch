Subject: Option A (Plain Mode) — Remove Yjs import from plain editor path and use cache‑first tooltip

Context
- CLAUDE.md Plain Mode Guardrails: no Yjs imports in plain‑mode files.
- Today, `components/canvas/annotation-decorations.ts` imports `@/lib/yjs-provider` and is used by the plain editor (`tiptap-editor-plain.tsx`). This pulls Yjs into the browser bundle even when `NEXT_PUBLIC_COLLAB_MODE=plain`.
- This patch preview splits the decorations plugin into a Yjs-free variant for Option A and wires the plain editor to use it. It also makes the tooltip cache‑first: reads from `window.canvasDataStore` and `plainProvider.getDocument(noteId, panelId)` before falling back to API.

Files changed
1) components/canvas/tiptap-editor-plain.tsx
   - Import `AnnotationDecorations` from `annotation-decorations-plain` instead of `annotation-decorations`.
   - No other changes.

2) components/canvas/annotation-decorations-plain.ts (new)
   - A Yjs‑free variant of the decorations plugin:
     - No imports from `@/lib/yjs-provider`.
     - Uses `getPlainProvider()` and `window.canvasDataStore`.
     - Normalizes IDs: `uiId = branch-<uuid>`, `dbId = <uuid>`.
     - Tooltip preview is built from provider cache/UI store; API GET `/api/postgres-offline/documents/<noteId>/<uiId>` only as a fallback.

 
--- a/components/canvas/tiptap-editor-plain.tsx
+++ b/components/canvas/tiptap-editor-plain.tsx
@@
-import { AnnotationDecorations } from './annotation-decorations'
+import { AnnotationDecorations } from './annotation-decorations-plain'

--- /dev/null
+++ b/components/canvas/annotation-decorations-plain.ts
@@
 +import { Plugin, PluginKey } from '@tiptap/pm/state'
 +import { Decoration, DecorationSet } from '@tiptap/pm/view'
 +import { getPlainProvider } from '@/lib/provider-switcher'
 +import { trackTooltipShown } from './performance-decorations'
 +
 +export const annotationDecorationsKey = new PluginKey('annotationDecorations')
 +
 +// Local state for hover icon/tooltip
 +let hoverIcon: HTMLDivElement | null = null
 +let isOverIcon = false
 +let isOverTarget = false
 +let isOverTooltip = false
 +let hoverIconHideTimeout: NodeJS.Timeout | null = null
 +let tooltipHideTimeout: NodeJS.Timeout | null = null
 +
 +export const AnnotationDecorations = () => {
 +  return new Plugin({
 +    key: annotationDecorationsKey,
 +    state: {
 +      init() {
 +        return { decorations: DecorationSet.empty }
 +      },
 +      apply(tr, value, _old, newState) {
 +        // Rebuild inline decorations over annotation marks
 +        const decos: Decoration[] = []
 +        tr.doc.descendants((node, pos) => {
 +          if (!node.isText) return
 +          node.marks.forEach(mark => {
 +            if (mark.type.name === 'annotation') {
 +              const from = pos
 +              const to = pos + node.nodeSize
 +              const branchId = mark.attrs.branchId || mark.attrs['data-branch']
 +              decos.push(Decoration.inline(from, to, {
 +                class: 'annotation-hover-target',
 +                'data-branch-id': branchId,
 +                'data-annotation-type': mark.attrs.type,
 +              }))
 +            }
 +          })
 +        })
 +        return { decorations: DecorationSet.create(newState.doc, decos) }
 +      }
 +    },
 +    props: {
 +      decorations(state) {
 +        // @ts-ignore
 +        return this.getState(state)?.decorations
 +      },
 +    },
 +    view(editorView) {
 +      let tooltipElement: HTMLDivElement | null = null
 +      let tooltipTimeout: NodeJS.Timeout | null = null
 +
 +      function ensureHoverIcon() {
 +        if (hoverIcon) return
 +        hoverIcon = document.createElement('div')
 +        hoverIcon.className = 'annotation-hover-icon'
 +        hoverIcon.innerHTML = '🔎'
 +        hoverIcon.style.cssText = 'position:fixed;display:none;z-index:10000;pointer-events:auto;'
 +        document.body.appendChild(hoverIcon)
 +        hoverIcon.addEventListener('mouseenter', () => {
 +          isOverIcon = true
 +          if (hoverIconHideTimeout) { clearTimeout(hoverIconHideTimeout); hoverIconHideTimeout = null }
 +          if (tooltipHideTimeout) { clearTimeout(tooltipHideTimeout); tooltipHideTimeout = null }
 +          const branchId = hoverIcon!.getAttribute('data-branch-id') || ''
 +          const type = hoverIcon!.getAttribute('data-annotation-type') || 'note'
 +          if (branchId) showAnnotationTooltip(hoverIcon!, branchId, type)
 +        })
 +        hoverIcon.addEventListener('mouseleave', () => {
 +          isOverIcon = false
 +          hideHoverIconSoon()
 +          hideAnnotationTooltipSoon()
 +        })
 +      }
 +
 +      function positionHoverIcon(x: number, y: number) {
 +        const OFFSET = 8, W = 22, H = 22
 +        const left = Math.min(x + OFFSET, window.innerWidth - W - 10)
 +        const top = Math.max(y - OFFSET - H/2, 10)
 +        if (hoverIcon) { hoverIcon.style.left = `${left}px`; hoverIcon.style.top = `${top}px` }
 +      }
 +
 +      function showHoverIcon(targetEl: HTMLElement, branchId: string, type: string, evt: MouseEvent) {
 +        ensureHoverIcon()
 +        if (hoverIcon) {
 +          hoverIcon.setAttribute('data-branch-id', branchId)
 +          hoverIcon.setAttribute('data-annotation-type', type)
 +          positionHoverIcon(evt.clientX, evt.clientY)
 +          hoverIcon.style.display = 'block'
 +        }
 +        if (hoverIconHideTimeout) { clearTimeout(hoverIconHideTimeout); hoverIconHideTimeout = null }
 +      }
 +
 +      function hideHoverIconSoon() {
 +        if (hoverIconHideTimeout) clearTimeout(hoverIconHideTimeout)
 +        hoverIconHideTimeout = setTimeout(() => {
 +          if (!isOverIcon && !isOverTarget && hoverIcon) hoverIcon.style.display = 'none'
 +        }, 300)
 +      }
 +
 +      function ensureTooltip() {
 +        if (!tooltipElement) {
 +          tooltipElement = document.createElement('div')
 +          tooltipElement.className = 'annotation-tooltip'
 +          document.body.appendChild(tooltipElement)
 +          tooltipElement.addEventListener('mouseenter', () => { isOverTooltip = true })
 +          tooltipElement.addEventListener('mouseleave', () => { isOverTooltip = false; hideAnnotationTooltipSoon() })
 +        }
 +      }
 +
 +      function hideAnnotationTooltipSoon() {
 +        if (tooltipHideTimeout) clearTimeout(tooltipHideTimeout)
 +        tooltipHideTimeout = setTimeout(() => {
 +          if (!isOverTooltip && !isOverIcon && tooltipElement) tooltipElement.classList.remove('visible')
 +        }, 300)
 +      }
 +
 +      function showAnnotationTooltip(element: HTMLElement, branchId: string, type: string) {
 +        if (!branchId) return
 +        if (tooltipTimeout) clearTimeout(tooltipTimeout)
 +        ensureTooltip()
 +
 +        // Option A cache‑first
 +        const uiId = branchId
 +        const root = element.closest('.tiptap-editor-wrapper') || document.body
 +        const textbox = root.querySelector('[role="textbox"]') as HTMLElement | null
 +        const noteId = textbox?.getAttribute('data-note') || ''
 +
 +        const ds = (window as any).canvasDataStore
 +        const plainProvider = getPlainProvider()
 +        const dsBranch = ds?.get?.(uiId) || null
 +
 +        // Provider cache (document content)
 +        let docContent: any = null
 +        if (plainProvider && noteId) {
 +          try { docContent = plainProvider.getDocument(noteId, uiId) || null } catch {}
 +        }
 +
 +        const titleText = dsBranch?.title || `${capitalize(type)}${dsBranch?.originalText ? ` on "${truncate(dsBranch.originalText, 30)}"` : ''}`
 +        const previewText = extractPreviewFromDoc(docContent)
 +          || (dsBranch?.content ? stripHtml(String(dsBranch.content)) : '')
 +          || (dsBranch?.originalText || '')
 +
 +        if (titleText || previewText) {
 +          const headerType = dsBranch?.type || type
 +          const safe = (previewText || 'No notes added yet').substring(0, 150)
 +          tooltipElement!.innerHTML = `
 +            <div class="tooltip-header">
 +              <span class="tooltip-icon">${getTypeIcon(headerType)}</span>
 +              <span class="tooltip-title">${titleText || `${capitalize(type)} annotation`}</span>
 +            </div>
 +            <div class="tooltip-content">${safe}${(previewText && previewText.length > 150) ? '...' : ''}</div>
 +            <div class="tooltip-footer">Click to open panel</div>
 +          `
 +        } else {
 +          tooltipElement!.innerHTML = `
 +            <div class="tooltip-header">
 +              <span class="tooltip-icon">${getTypeIcon(type)}</span>
 +              <span class="tooltip-title">${capitalize(type)} annotation</span>
 +            </div>
 +            <div class="tooltip-content">Loading notes...</div>
 +            <div class="tooltip-footer">Click to open panel</div>
 +          `
 +        }
 +
 +        // Late fallback to API (when caches are empty)
 +        if (noteId && !previewText) {
 +          fetch(`/api/postgres-offline/documents/${noteId}/${uiId}`)
 +            .then(res => res.ok ? res.json() : null)
 +            .then(doc => {
 +              if (!doc || !tooltipElement || !tooltipElement.classList.contains('visible')) return
 +              const contentText = extractPreviewFromDoc(doc.content) || ''
 +              const headerType = dsBranch?.type || type
 +              const safe = (contentText || 'No notes added yet').substring(0, 150)
 +              tooltipElement.innerHTML = `
 +                <div class="tooltip-header">
 +                  <span class="tooltip-icon">${getTypeIcon(headerType)}</span>
 +                  <span class="tooltip-title">${titleText || `${capitalize(type)} annotation`}</span>
 +                </div>
 +                <div class="tooltip-content">${safe}${(contentText && contentText.length > 150) ? '...' : ''}</div>
 +                <div class="tooltip-footer">Click to open panel</div>
 +              `
 +            })
 +            .catch(() => {})
 +        }
 +
 +        // Position & show
 +        const rect = element.getBoundingClientRect()
 +        const trect = tooltipElement!.getBoundingClientRect()
 +        let top = rect.top - trect.height - 10
 +        let left = rect.left + (rect.width - trect.width) / 2
 +        if (top < 10) top = rect.bottom + 10
 +        if (left < 10) left = 10
 +        if (left + trect.width > window.innerWidth - 10) left = window.innerWidth - trect.width - 10
 +        tooltipElement!.style.top = `${top}px`
 +        tooltipElement!.style.left = `${left}px`
 +        tooltipElement!.classList.add('visible')
 +        trackTooltipShown()
 +      }
 +
 +      function stripHtml(html: string): string {
 +        try { return html.replace(/<[^>]*>/g, '') } catch { return html || '' }
 +      }
 +      function extractTextFromPMJSON(node: any): string {
 +        if (!node) return ''
 +        if (typeof node === 'string') return node
 +        if (node.text) return node.text
 +        if (Array.isArray(node.content)) return node.content.map(extractTextFromPMJSON).join(' ')
 +        return ''
 +      }
 +      function extractPreviewFromDoc(content: any): string | null {
 +        if (!content) return null
 +        if (typeof content === 'string') return stripHtml(content)
 +        if (content && typeof content === 'object') {
 +          try { return extractTextFromPMJSON(content) } catch { return null }
 +        }
 +        return null
 +      }
 +      function truncate(s: string, n: number): string {
 +        if (!s) return ''
 +        return s.length > n ? s.slice(0, n) + '...' : s
 +      }
 +      function capitalize(s: string): string {
 +        if (!s) return ''
 +        return s.charAt(0).toUpperCase() + s.slice(1)
 +      }
 +      function getTypeIcon(type: string) {
 +        const icons = { note: '📝', explore: '🔍', promote: '⭐' }
 +        return icons[type as keyof typeof icons] || '📝'
 +      }
 +
 +      // DOM listeners for hover
 +      const onOver = (event: MouseEvent) => {
 +        const target = event.target as HTMLElement
 +        let el = target.closest('.annotation-hover-target') as HTMLElement
 +        if (!el) el = target.closest('.annotation') as HTMLElement
 +        if (!el) return
 +        if (!el.hasAttribute('data-hover-processed')) {
 +          el.setAttribute('data-hover-processed', 'true')
 +          isOverTarget = true
 +          const branchId = el.getAttribute('data-branch-id') || el.getAttribute('data-branch') || ''
 +          const type = el.getAttribute('data-annotation-type') || el.getAttribute('data-type') || 'note'
 +          showHoverIcon(el, branchId, type, event)
 +          el.classList.add('annotation-hovered')
 +        }
 +      }
 +      const onOut = (event: MouseEvent) => {
 +        const target = event.target as HTMLElement
 +        let el = target.closest('.annotation-hover-target') as HTMLElement
 +        if (!el) el = target.closest('.annotation') as HTMLElement
 +        if (!el) return
 +        if (el.hasAttribute('data-hover-processed')) {
 +          el.removeAttribute('data-hover-processed')
 +          isOverTarget = false
 +          el.classList.remove('annotation-hovered')
 +          hideHoverIconSoon()
 +          hideAnnotationTooltipSoon()
 +        }
 +      }
 +      editorView.dom.addEventListener('mouseover', onOver)
 +      editorView.dom.addEventListener('mouseout', onOut)
 +
 +      return {
 +        destroy() {
 +          editorView.dom.removeEventListener('mouseover', onOver)
 +          editorView.dom.removeEventListener('mouseout', onOut)
 +          if (hoverIcon && hoverIcon.parentNode) hoverIcon.parentNode.removeChild(hoverIcon)
 +          hoverIcon = null
 +          if (tooltipElement && tooltipElement.parentNode) tooltipElement.parentNode.removeChild(tooltipElement)
 +          tooltipElement = null
 +        }
 +      }
 +    }
 +  })
 +}

