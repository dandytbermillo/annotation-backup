Subject: Option A tooltip stability: correct context, ID normalization, stale guards (no Yjs)

Context
- In Option A (plain mode, no Yjs), the tooltip intermittently shows the wrong content because:
  1) The hover icon loses the source editor context (noteId/panel) when it’s moved to document.body.
  2) Branch id varies between raw <uuid> and UI id branch-<uuid>; lookups miss without normalization.
  3) Late async responses overwrite the tooltip after the pointer moves (no stale guard).
  4) JSON vs HTML preview extraction is inconsistent.

What this patch previews (advisory only)
- Make the plain editor import a Yjs‑free decorations plugin.
- In the plain plugin:
  - Preserve editor context by storing noteId/panelId on the hover icon dataset.
  - Normalize branch id into uiId and dbId (using a UUID regex) and use uiId consistently for panel/document keys.
  - Build preview from local caches first: window.canvasDataStore.get(uiId) and plainProvider.getDocument(noteId, uiId).
  - Use a stale guard (tooltipElement.dataset.branchId === uiId) before applying async results.
  - Add a single delayed retry (~900ms) against the provider cache to handle debounced saves.
  - No Yjs imports.

--- a/components/canvas/tiptap-editor-plain.tsx
+++ b/components/canvas/tiptap-editor-plain.tsx
@@
-import { AnnotationDecorations } from './annotation-decorations'
+import { AnnotationDecorations } from './annotation-decorations-plain'

--- /dev/null
+++ b/components/canvas/annotation-decorations-plain.ts
@@
+import { Plugin, PluginKey } from '@tiptap/pm/state'
+import { Decoration, DecorationSet } from '@tiptap/pm/view'
+import { getPlainProvider } from '@/lib/provider-switcher'
+import { trackTooltipShown } from './performance-decorations'
+
+export const annotationDecorationsKey = new PluginKey('annotationDecorations')
+
+let hoverIcon: HTMLDivElement | null = null
+let isOverIcon = false
+let isOverTarget = false
+let isOverTooltip = false
+let hoverIconHideTimeout: NodeJS.Timeout | null = null
+let tooltipHideTimeout: NodeJS.Timeout | null = null
+
+const UUID_RE = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/
+
+function normalizeIds(branchId: string) {
+  if (!branchId) return { uiId: '', dbId: '' }
+  if (branchId.startsWith('branch-')) return { uiId: branchId, dbId: branchId.slice(7) }
+  if (UUID_RE.test(branchId)) return { uiId: `branch-${branchId}`, dbId: branchId }
+  return { uiId: branchId, dbId: branchId }
+}
+
+function resolveContextFrom(el: HTMLElement) {
+  const root = el.closest('.tiptap-editor-wrapper') || document.body
+  const textbox = root.querySelector('[role="textbox"]') as HTMLElement | null
+  const noteId = textbox?.getAttribute('data-note') || ''
+  const panelId = textbox?.getAttribute('data-panel') || ''
+  return { noteId, panelId }
+}
+
+function stripHtml(html: string): string {
+  try { return html.replace(/<[^>]*>/g, '') } catch { return html || '' }
+}
+
+function extractTextFromPMJSON(node: any): string {
+  if (!node) return ''
+  if (typeof node === 'string') return node
+  if (node.text) return node.text
+  if (Array.isArray(node.content)) return node.content.map(extractTextFromPMJSON).join(' ')
+  return ''
+}
+
+function extractPreviewFromDoc(content: any): string | null {
+  if (!content) return null
+  if (typeof content === 'string') {
+    const s = content.trim()
+    if ((s.startsWith('{') || s.startsWith('['))) {
+      try { return extractTextFromPMJSON(JSON.parse(s)) } catch { return stripHtml(s) }
+    }
+    return stripHtml(s)
+  }
+  if (typeof content === 'object') {
+    try { return extractTextFromPMJSON(content) } catch { return null }
+  }
+  return null
+}
+
+function truncate(s: string, n: number): string { return !s ? '' : (s.length > n ? s.slice(0, n) + '...' : s) }
+function capitalize(s: string): string { return !s ? '' : (s.charAt(0).toUpperCase() + s.slice(1)) }
+function getTypeIcon(type: string) { const m = { note: '📝', explore: '🔍', promote: '⭐' } as const; return (m as any)[type] || '📝' }
+
+export const AnnotationDecorations = () => new Plugin({
+  key: annotationDecorationsKey,
+  state: {
+    init() {
+      return { decorations: DecorationSet.empty }
+    },
+    apply(tr, _value, _old, newState) {
+      const decos: Decoration[] = []
+      tr.doc.descendants((node, pos) => {
+        if (!node.isText) return
+        node.marks.forEach(mark => {
+          if (mark.type.name === 'annotation') {
+            const from = pos
+            const to = pos + node.nodeSize
+            const branchId = mark.attrs.branchId || mark.attrs['data-branch']
+            decos.push(Decoration.inline(from, to, {
+              class: 'annotation-hover-target',
+              'data-branch-id': branchId,
+              'data-annotation-type': mark.attrs.type,
+            }))
+          }
+        })
+      })
+      return { decorations: DecorationSet.create(newState.doc, decos) }
+    }
+  },
+  props: {
+    decorations(state) {
+      // @ts-ignore
+      return this.getState(state)?.decorations
+    },
+  },
+  view(editorView) {
+    let tooltipElement: HTMLDivElement | null = null
+    let tooltipTimeout: NodeJS.Timeout | null = null
+
+    function ensureTooltip() {
+      if (!tooltipElement) {
+        tooltipElement = document.createElement('div')
+        tooltipElement.className = 'annotation-tooltip'
+        document.body.appendChild(tooltipElement)
+        tooltipElement.addEventListener('mouseenter', () => { isOverTooltip = true })
+        tooltipElement.addEventListener('mouseleave', () => { isOverTooltip = false; hideAnnotationTooltipSoon() })
+      }
+    }
+
+    function ensureHoverIcon() {
+      if (hoverIcon) return
+      hoverIcon = document.createElement('div')
+      hoverIcon.className = 'annotation-hover-icon'
+      hoverIcon.innerHTML = '🔎'
+      hoverIcon.style.cssText = 'position:fixed;display:none;z-index:10000;pointer-events:auto;'
+      document.body.appendChild(hoverIcon)
+      hoverIcon.addEventListener('mouseenter', () => {
+        isOverIcon = true
+        if (hoverIconHideTimeout) { clearTimeout(hoverIconHideTimeout); hoverIconHideTimeout = null }
+        if (tooltipHideTimeout) { clearTimeout(tooltipHideTimeout); tooltipHideTimeout = null }
+        const branchId = hoverIcon!.getAttribute('data-branch-id') || ''
+        const type = hoverIcon!.getAttribute('data-annotation-type') || 'note'
+        showAnnotationTooltip(hoverIcon!, branchId, type)
+      })
+      hoverIcon.addEventListener('mouseleave', () => { isOverIcon = false; hideHoverIconSoon(); hideAnnotationTooltipSoon() })
+    }
+
+    function positionHoverIcon(x: number, y: number) {
+      const OFFSET = 8, W = 22, H = 22
+      const left = Math.min(x + OFFSET, window.innerWidth - W - 10)
+      const top = Math.max(y - OFFSET - H/2, 10)
+      if (hoverIcon) { hoverIcon.style.left = `${left}px`; hoverIcon.style.top = `${top}px` }
+    }
+
+    function showHoverIcon(targetEl: HTMLElement, branchId: string, type: string, evt: MouseEvent) {
+      ensureHoverIcon()
+      if (hoverIcon) {
+        const ctx = resolveContextFrom(targetEl)
+        hoverIcon.dataset.noteId = ctx.noteId || ''
+        hoverIcon.dataset.panelId = ctx.panelId || ''
+        hoverIcon.setAttribute('data-branch-id', branchId)
+        hoverIcon.setAttribute('data-annotation-type', type)
+        positionHoverIcon(evt.clientX, evt.clientY)
+        hoverIcon.style.display = 'block'
+      }
+      if (hoverIconHideTimeout) { clearTimeout(hoverIconHideTimeout); hoverIconHideTimeout = null }
+    }
+
+    function hideHoverIconSoon() {
+      if (hoverIconHideTimeout) clearTimeout(hoverIconHideTimeout)
+      hoverIconHideTimeout = setTimeout(() => { if (!isOverIcon && !isOverTarget && hoverIcon) hoverIcon.style.display = 'none' }, 300)
+    }
+
+    function hideAnnotationTooltipSoon() {
+      if (tooltipHideTimeout) clearTimeout(tooltipHideTimeout)
+      tooltipHideTimeout = setTimeout(() => { if (!isOverTooltip && !isOverIcon && tooltipElement) tooltipElement.classList.remove('visible') }, 300)
+    }
+
+    function showAnnotationTooltip(el: HTMLElement, rawBranchId: string, type: string) {
+      if (!rawBranchId) return
+      if (tooltipTimeout) clearTimeout(tooltipTimeout)
+      ensureTooltip()
+
+      const noteId = (el as any).dataset?.noteId || resolveContextFrom(el).noteId || ''
+      const { uiId } = normalizeIds(rawBranchId)
+
+      if (tooltipElement) tooltipElement.dataset.branchId = uiId
+
+      const ds = (window as any).canvasDataStore
+      const plainProvider = getPlainProvider()
+      const dsBranch = ds?.get?.(uiId) || null
+
+      let docContent: any = null
+      if (plainProvider && noteId) {
+        try { docContent = plainProvider.getDocument(noteId, uiId) || null } catch {}
+      }
+
+      const titleText = dsBranch?.title || `${capitalize(type)}${dsBranch?.originalText ? ` on "${truncate(dsBranch.originalText, 30)}"` : ''}`
+      const previewText = extractPreviewFromDoc(docContent) || (dsBranch?.content ? stripHtml(String(dsBranch.content)) : '') || (dsBranch?.originalText || '')
+
+      function renderPreview(text: string) {
+        const headerType = dsBranch?.type || type
+        const safe = (text || 'No notes added yet').substring(0, 150)
+        tooltipElement!.innerHTML = `
+          <div class="tooltip-header">
+            <span class="tooltip-icon">${getTypeIcon(headerType)}</span>
+            <span class="tooltip-title">${titleText || `${capitalize(type)} annotation`}</span>
+          </div>
+          <div class="tooltip-content">${safe}${(text && text.length > 150) ? '...' : ''}</div>
+          <div class="tooltip-footer">Click to open panel</div>
+        `
+      }
+
+      if (titleText || previewText) renderPreview(previewText)
+      else tooltipElement!.innerHTML = `
+        <div class="tooltip-header">
+          <span class="tooltip-icon">${getTypeIcon(type)}</span>
+          <span class="tooltip-title">${capitalize(type)} annotation</span>
+        </div>
+        <div class="tooltip-content">Loading notes...</div>
+        <div class="tooltip-footer">Click to open panel</div>
+      `
+
+      const rect = el.getBoundingClientRect()
+      const trect = tooltipElement!.getBoundingClientRect()
+      let top = rect.top - trect.height - 10
+      let left = rect.left + (rect.width - trect.width) / 2
+      if (top < 10) top = rect.bottom + 10
+      if (left < 10) left = 10
+      if (left + trect.width > window.innerWidth - 10) left = window.innerWidth - trect.width - 10
+      tooltipElement!.style.top = `${top}px`
+      tooltipElement!.style.left = `${left}px`
+      tooltipElement!.classList.add('visible')
+      trackTooltipShown()
+
+      if (noteId && !previewText) {
+        const currentKey = uiId
+        fetch(`/api/postgres-offline/documents/${noteId}/${uiId}`)
+          .then(res => res.ok ? res.json() : null)
+          .then(doc => {
+            if (!doc || !tooltipElement) return
+            if (tooltipElement.dataset.branchId !== currentKey || !tooltipElement.classList.contains('visible')) return
+            const txt = extractPreviewFromDoc(doc.content) || ''
+            renderPreview(txt)
+          })
+          .catch(() => {})
+      }
+
+      if (plainProvider && noteId && !previewText) {
+        const currentKey = uiId
+        setTimeout(() => {
+          if (!tooltipElement || tooltipElement.dataset.branchId !== currentKey || !tooltipElement.classList.contains('visible')) return
+          try {
+            const again = plainProvider.getDocument(noteId, uiId)
+            const txt = extractPreviewFromDoc(again) || ''
+            if (txt) renderPreview(txt)
+          } catch {}
+        }, 900)
+      }
+    }
+
+    const onOver = (event: MouseEvent) => {
+      const target = event.target as HTMLElement
+      let el = target.closest('.annotation-hover-target') as HTMLElement
+      if (!el) el = target.closest('.annotation') as HTMLElement
+      if (!el) return
+      if (!el.hasAttribute('data-hover-processed')) {
+        el.setAttribute('data-hover-processed', 'true')
+        isOverTarget = true
+        const branchId = el.getAttribute('data-branch-id') || el.getAttribute('data-branch') || ''
+        const type = el.getAttribute('data-annotation-type') || el.getAttribute('data-type') || 'note'
+        showHoverIcon(el, branchId, type, event)
+        el.classList.add('annotation-hovered')
+      }
+    }
+    const onOut = (event: MouseEvent) => {
+      const target = event.target as HTMLElement
+      let el = target.closest('.annotation-hover-target') as HTMLElement
+      if (!el) el = target.closest('.annotation') as HTMLElement
+      if (!el) return
+      if (el.hasAttribute('data-hover-processed')) {
+        el.removeAttribute('data-hover-processed')
+        isOverTarget = false
+        el.classList.remove('annotation-hovered')
+        hideHoverIconSoon()
+        hideAnnotationTooltipSoon()
+      }
+    }
+
+    editorView.dom.addEventListener('mouseover', onOver)
+    editorView.dom.addEventListener('mouseout', onOut)
+
+    return {
+      destroy() {
+        editorView.dom.removeEventListener('mouseover', onOver)
+        editorView.dom.removeEventListener('mouseout', onOut)
+        if (hoverIcon && hoverIcon.parentNode) hoverIcon.parentNode.removeChild(hoverIcon)
+        hoverIcon = null
+        if (tooltipElement && tooltipElement.parentNode) tooltipElement.parentNode.removeChild(tooltipElement)
+        tooltipElement = null
+      }
+    }
+  }
+})

