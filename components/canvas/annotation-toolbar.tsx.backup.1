"use client"

import { useCanvas } from "./canvas-context"
import { v4 as uuidv4 } from "uuid"
import { UnifiedProvider } from "@/lib/provider-switcher"
import { getPlainProvider } from "@/lib/provider-switcher"
import { createAnnotationBranch } from "@/lib/models/annotation"
import { buildBranchPreview } from "@/lib/utils/branch-preview"

export function AnnotationToolbar() {
  const { dispatch, state, dataStore, noteId } = useCanvas()

  const createAnnotation = (type: 'note' | 'explore' | 'promote') => {
    const text = state.selectedText
    const panel = state.currentPanel
    
    if (!text || !panel) {
      console.warn('No text selected or no panel available')
      return
    }

    // Generate unique IDs
    const annotationId = uuidv4()
    const branchId = `branch-${annotationId}`

    // Check if we're in plain mode
    const plainProvider = getPlainProvider()
    const isPlainMode = !!plainProvider
    
    // Create the branch data with proper quoted content
    const draftBranch = createAnnotationBranch(type, panel, noteId || '', text, { x: 0, y: 0 })
    const initialPreview = buildBranchPreview(draftBranch.content, text)

    const branchData = {
      id: branchId,
      ...draftBranch,
      preview: initialPreview,
      branches: [],
      isEditable: true,
      metadata: {
        ...draftBranch.metadata,
        preview: initialPreview,
      },
    }

    // Add the branch to data store
    dataStore.set(branchId, branchData)
    
    if (isPlainMode && plainProvider && noteId) {
      // Plain mode: Create annotation in database
      // Use raw UUID for database ID, but keep branch-xxx format for UI
      plainProvider.createBranch({
        id: annotationId, // Use raw UUID for database
        noteId: noteId,
        parentId: panel,  // Keep as-is: 'main', 'branch-xxx', or UUID
        type: type,
        originalText: text,
        metadata: {
          annotationType: type,
          annotationId: annotationId,
          displayId: branchId, // Store the UI ID in metadata
          preview: initialPreview,
        },
        anchors: state.selectedRange ? {
          start: state.selectedRange.startOffset,
          end: state.selectedRange.endOffset,
          context: text
        } : undefined
      }).then(() => {
        return plainProvider.saveDocument(noteId, branchId, branchData.content, false, { skipBatching: true })
      }).catch(error => {
        console.error('[AnnotationToolbar] Failed to create branch or persist initial content:', error)
      })
     
     // Update parent's branches list
     const parentPanel = dataStore.get(panel)
     if (parentPanel) {
        const branches = parentPanel.branches || []
        dataStore.update(panel, { branches: [...branches, branchId] })
      }
    } else {
      // Yjs mode: Use UnifiedProvider (collab)
      const provider = UnifiedProvider.getInstance()
      if (noteId) {
        provider.setCurrentNote(noteId)
      }
      
      // Use the new addBranch method that handles YJS native types properly
      provider.addBranch(panel, branchId, branchData)
      
      // Update DataStore for backward compatibility
      const parentPanel = dataStore.get(panel)
      if (parentPanel) {
        // Get current branches using the new YJS method (this will be consistent)
        const currentBranches = provider.getBranches(panel)
        dataStore.update(panel, { branches: currentBranches })
      } else {
        // If parent doesn't exist in dataStore, create minimal entry
        dataStore.set(panel, { 
          branches: provider.getBranches(panel),
          position: { x: 2000, y: 1500 } // Default position
        })
      }
    }

    // Calculate smart position for new panel (similar to branch list positioning)
    const branchesMap = isPlainMode ? new Map() : UnifiedProvider.getInstance().getBranchesMap()
    const parentBranch = branchesMap.get(panel) || dataStore.get(panel)
    
    // Function to calculate smart position relative to parent panel
    const calculateSmartPosition = () => {
      // Try to find the parent panel element
      const parentPanelEl = document.querySelector(`[data-panel-id="${panel}"]`) as HTMLElement
      
      if (!parentPanelEl) {
        console.warn(`Parent panel element ${panel} not found`)
        return { x: 3000, y: 1500 } // Default fallback
      }
      
      // Get the actual panel dimensions
      const rect = parentPanelEl.getBoundingClientRect()
      const panelWidth = rect.width || 800
      const gap = 50
      
      // Get the transform values from the panel's style
      const style = window.getComputedStyle(parentPanelEl)
      const transform = style.transform
      
      if (transform && transform !== 'none') {
        // Extract translation values from the transform matrix
        const matrix = new DOMMatrixReadOnly(transform)
        const currentX = matrix.m41
        const currentY = matrix.m42
        
        // Smart positioning logic (same as branch list)
        // Check for existing panels to avoid collisions
        const allPanels = document.querySelectorAll('[data-panel-id]')
        let rightOccupied = false
        let leftOccupied = false
        
        allPanels.forEach((existingPanel) => {
          if (existingPanel === parentPanelEl) return
          
          const panelStyle = window.getComputedStyle(existingPanel)
          const panelTransform = panelStyle.transform
          
          if (panelTransform && panelTransform !== 'none') {
            const panelMatrix = new DOMMatrixReadOnly(panelTransform)
            const panelX = panelMatrix.m41
            
            // Check if a panel is already on the right
            if (panelX > currentX + panelWidth && 
                panelX < currentX + panelWidth + gap + 100) {
              rightOccupied = true
            }
            
            // Check if a panel is already on the left
            if (panelX < currentX - gap && 
                panelX > currentX - panelWidth - gap - 100) {
              leftOccupied = true
            }
          }
        })
        
        // Determine position based on occupancy and viewport constraints
        const viewportWidth = window.innerWidth
        let targetX = currentX
        
        // Prefer right side, but check constraints
        if (!rightOccupied && currentX + panelWidth * 2 + gap < Math.min(4000, viewportWidth - 100)) {
          targetX = currentX + panelWidth + gap
        } else if (!leftOccupied && currentX - panelWidth - gap > 500) {
          targetX = currentX - panelWidth - gap
        } else {
          // Both sides occupied or constrained, stack vertically
          targetX = currentX + panelWidth + gap
        }
        
        return { x: targetX, y: currentY }
      }
      
      // Fallback if no transform found
      if (parentBranch?.position) {
        return { 
          x: parentBranch.position.x + 900, 
          y: parentBranch.position.y 
        }
      }
      
      return { x: 3000, y: 1500 }
    }
    
    const smartPosition = calculateSmartPosition()
    
    // Update position in both stores
    dataStore.update(branchId, { position: smartPosition })
    const updatedBranchData = branchesMap.get(branchId)
    if (updatedBranchData) {
      updatedBranchData.position = smartPosition
    }

    // Dispatch both panel-specific and global events for annotation insertion
    const eventDetail = {
      type,
      annotationId,
      branchId,
      panelId: panel,
      text,
    }

    // Try panel-specific event first
    const panelElements = document.querySelectorAll('.panel')
    panelElements.forEach(element => {
      // Check if this is the correct panel by looking for the panel ID in the content
      const panelContent = element.querySelector(`[data-panel="${panel}"]`)
      if (panelContent || element.textContent?.includes(panel)) {
        element.dispatchEvent(new CustomEvent('insert-annotation', { 
          detail: eventDetail,
          bubbles: true 
        }))
      }
    })

    // Also dispatch global event as fallback
    window.dispatchEvent(new CustomEvent('insert-annotation-global', { 
      detail: eventDetail 
    }))

    // Create the panel for the new branch with smart position
    window.dispatchEvent(new CustomEvent('create-panel', { 
      detail: { 
        panelId: branchId,
        parentPanelId: panel,
        parentPosition: smartPosition
      } 
    }))

    // Force a re-render by triggering branch updated action
    dispatch({ type: "BRANCH_UPDATED" })

    // Hide the toolbar after creating annotation
    const toolbar = document.getElementById("annotation-toolbar")
    if (toolbar) {
      toolbar.classList.remove("visible")
    }

    // Clear selection
    dispatch({ type: "SET_SELECTION", payload: { text: "", range: null, panel: null } })
    
    // Clear browser text selection
    window.getSelection()?.removeAllRanges()
  }

  return (
    <div
      id="annotation-toolbar"
      className="annotation-toolbar"
      onMouseEnter={() => {
        const toolbar = document.getElementById("annotation-toolbar")
        if (toolbar) {
          toolbar.style.opacity = "1"
          toolbar.style.pointerEvents = "auto"
          toolbar.classList.add("visible")
        }
      }}
      onMouseLeave={() => {
        setTimeout(() => {
          const toolbar = document.getElementById("annotation-toolbar")
          if (toolbar && !toolbar.matches(':hover')) {
            toolbar.style.opacity = "0"
            toolbar.style.pointerEvents = "none"
            toolbar.classList.remove("visible")
          }
        }, 300)
      }}
      style={{
        position: "fixed",
        background: "white",
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "8px",
        boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
        display: "flex",
        gap: "8px",
        zIndex: 1000,
        opacity: 0,
        pointerEvents: "none",
        transform: "translateX(-50%) translateY(0)",
        transition: "opacity 0.2s ease, transform 0.2s ease",
      }}
    >
      <button
        onClick={() => createAnnotation('note')}
        className="annotation-btn note"
        title="Create Note"
        style={{
          background: "linear-gradient(135deg, #3498db 0%, #2980b9 100%)",
          color: "white",
          border: "none",
          borderRadius: "6px",
          padding: "8px 16px",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: 500,
          display: "flex",
          alignItems: "center",
          gap: "6px",
          transition: "transform 0.2s ease",
        }}
        onMouseEnter={(e) => e.currentTarget.style.transform = "scale(1.05)"}
        onMouseLeave={(e) => e.currentTarget.style.transform = "scale(1)"}
      >
        üìù Note
      </button>

      <button
        onClick={() => createAnnotation('explore')}
        className="annotation-btn explore"
        title="Create Exploration"
        style={{
          background: "linear-gradient(135deg, #f39c12 0%, #e67e22 100%)",
          color: "white",
          border: "none",
          borderRadius: "6px",
          padding: "8px 16px",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: 500,
          display: "flex",
          alignItems: "center",
          gap: "6px",
          transition: "transform 0.2s ease",
        }}
        onMouseEnter={(e) => e.currentTarget.style.transform = "scale(1.05)"}
        onMouseLeave={(e) => e.currentTarget.style.transform = "scale(1)"}
      >
        üîç Explore
      </button>

      <button
        onClick={() => createAnnotation('promote')}
        className="annotation-btn promote"
        title="Create Promotion"
        style={{
          background: "linear-gradient(135deg, #27ae60 0%, #229954 100%)",
          color: "white",
          border: "none",
          borderRadius: "6px",
          padding: "8px 16px",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: 500,
          display: "flex",
          alignItems: "center",
          gap: "6px",
          transition: "transform 0.2s ease",
        }}
        onMouseEnter={(e) => e.currentTarget.style.transform = "scale(1.05)"}
        onMouseLeave={(e) => e.currentTarget.style.transform = "scale(1)"}
      >
        ‚≠ê Promote
      </button>

      <style jsx>{`
        .annotation-toolbar.visible {
          opacity: 1 !important;
          pointer-events: auto !important;
          transform: translateX(-50%) translateY(-10px) !important;
        }
      `}</style>
    </div>
  )
}
