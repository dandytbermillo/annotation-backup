"use client"

import { useCanvas } from "./canvas-context"
import { v4 as uuidv4 } from "uuid"
import { UnifiedProvider } from "@/lib/provider-switcher"
import { getPlainProvider } from "@/lib/provider-switcher"
import { createAnnotationBranch } from "@/lib/models/annotation"
import { buildBranchPreview } from "@/lib/utils/branch-preview"

export function AnnotationToolbar() {
  const { dispatch, state, dataStore, noteId } = useCanvas()

  const createAnnotation = (type: 'note' | 'explore' | 'promote') => {
    const text = state.selectedText
    const panel = state.currentPanel
    
    if (!text || !panel) {
      console.warn('No text selected or no panel available')
      return
    }

    // Generate unique IDs
    const annotationId = uuidv4()
    const branchId = `branch-${annotationId}`

    // Check if we're in plain mode
    const plainProvider = getPlainProvider()
    const isPlainMode = !!plainProvider
    
    // Create the branch data with proper quoted content
    const draftBranch = createAnnotationBranch(type, panel, noteId || '', text, { x: 0, y: 0 })
    const initialPreview = buildBranchPreview(draftBranch.content, text)

    const branchData = {
      id: branchId,
      ...draftBranch,
      preview: initialPreview,
      branches: [],
      isEditable: true,
      metadata: {
        ...draftBranch.metadata,
        preview: initialPreview,
      },
    }

    // Add the branch to data store
    dataStore.set(branchId, branchData)
    
    if (isPlainMode && plainProvider && noteId) {
      // Plain mode: Create annotation in database
      // Use raw UUID for database ID, but keep branch-xxx format for UI
      plainProvider.createBranch({
        id: annotationId, // Use raw UUID for database
        noteId: noteId,
        parentId: panel,  // Keep as-is: 'main', 'branch-xxx', or UUID
        type: type,
        originalText: text,
        metadata: {
          annotationType: type,
          annotationId: annotationId,
          displayId: branchId, // Store the UI ID in metadata
          preview: initialPreview,
        },
        anchors: state.selectedRange ? {
          start: state.selectedRange.startOffset,
          end: state.selectedRange.endOffset,
          context: text
        } : undefined
      }).then(() => {
        return plainProvider.saveDocument(noteId, branchId, branchData.content, false, { skipBatching: true })
      }).catch(error => {
        console.error('[AnnotationToolbar] Failed to create branch or persist initial content:', error)
      })
     
     // Update parent's branches list
     const parentPanel = dataStore.get(panel)
     if (parentPanel) {
        const branches = parentPanel.branches || []
        dataStore.update(panel, { branches: [...branches, branchId] })
      }
    } else {
      // Yjs mode: Use UnifiedProvider (collab)
      const provider = UnifiedProvider.getInstance()
      if (noteId) {
        provider.setCurrentNote(noteId)
      }
      
      // Use the new addBranch method that handles YJS native types properly
      provider.addBranch(panel, branchId, branchData)
      
      // Update DataStore for backward compatibility
      const parentPanel = dataStore.get(panel)
      if (parentPanel) {
        // Get current branches using the new YJS method (this will be consistent)
        const currentBranches = provider.getBranches(panel)
        dataStore.update(panel, { branches: currentBranches })
      } else {
        // If parent doesn't exist in dataStore, create minimal entry
        dataStore.set(panel, { 
          branches: provider.getBranches(panel),
          position: { x: 2000, y: 1500 } // Default position
        })
      }
    }

    // Calculate smart position for new panel (similar to branch list positioning)
    const branchesMap = isPlainMode ? new Map() : UnifiedProvider.getInstance().getBranchesMap()
    const parentBranch = branchesMap.get(panel) || dataStore.get(panel)
    
    // Function to calculate smart position relative to parent panel (exact same logic as branch list)
    const calculateSmartPosition = () => {
      // Try to find the parent panel element
      const currentPanel = document.querySelector(`[data-panel-id="${panel}"]`) as HTMLElement
      let parentPosition = { x: 2000, y: 1500 } // Default position
      
      if (currentPanel) {
        // Get the actual panel dimensions
        const rect = currentPanel.getBoundingClientRect()
        const panelWidth = rect.width || 800 // Fallback to 800 if width not available
        const gap = 50 // Gap between panels
        
        // Get the transform values from the panel's style
        const style = window.getComputedStyle(currentPanel)
        const transform = style.transform
        
        if (transform && transform !== 'none') {
          // Extract translation values from the transform matrix
          const matrix = new DOMMatrixReadOnly(transform)
          const currentX = matrix.m41
          const currentY = matrix.m42
          
          // Smart positioning logic:
          // 1. Check if there are already panels on either side
          // 2. Prefer right side by default
          // 3. Use left if right side would go too far (beyond viewport or x > 4000)
          // 4. Alternate sides if multiple branches are opened
          
          // Get all existing panels to check for collisions
          const allPanels = document.querySelectorAll('[data-panel-id]')
          let rightOccupied = false
          let leftOccupied = false
          
          allPanels.forEach((panel) => {
            if (panel === currentPanel) return
            
            const panelStyle = window.getComputedStyle(panel)
            const panelTransform = panelStyle.transform
            
            if (panelTransform && panelTransform !== 'none') {
              const panelMatrix = new DOMMatrixReadOnly(panelTransform)
              const panelX = panelMatrix.m41
              
              // Check if a panel is already on the right
              if (panelX > currentX + panelWidth && 
                  panelX < currentX + panelWidth + gap + 100) {
                rightOccupied = true
              }
              
              // Check if a panel is already on the left
              if (panelX < currentX - gap && 
                  panelX > currentX - panelWidth - gap - 100) {
                leftOccupied = true
              }
            }
          })
          
          // Decide placement based on occupancy and viewport constraints
          let placeOnLeft = false
          
          if (!rightOccupied && !leftOccupied) {
            // Neither side occupied - check viewport constraints
            const viewportWidth = window.innerWidth
            const rightEdgePosition = currentX + panelWidth + gap + panelWidth
            
            // Place on left if right would exceed viewport or go beyond x=4000
            placeOnLeft = rightEdgePosition > viewportWidth || currentX > 2500
          } else if (rightOccupied && !leftOccupied) {
            // Right is occupied, left is free
            placeOnLeft = true
          } else if (!rightOccupied && leftOccupied) {
            // Left is occupied, right is free
            placeOnLeft = false
          } else {
            // Both sides occupied - stack on the right with offset
            placeOnLeft = false
            // Add vertical offset to avoid complete overlap
            parentPosition.y = currentY + 100
          }
          
          // Position the new panel to the left or right of the parent with gap
          parentPosition = {
            x: placeOnLeft 
              ? currentX - panelWidth - gap // Panel width + gap on the left
              : currentX + panelWidth + gap, // Panel width + gap on the right
            y: parentPosition.y || currentY // Use offset Y if set, otherwise same vertical position
          }
        } else {
          // Fallback: try to get position from data stores
          const panelData = parentBranch
          
          if (panelData?.position) {
            // Simple fallback logic when transform not available
            const placeOnLeft = panelData.position.x > 2500
            parentPosition = {
              x: placeOnLeft 
                ? panelData.position.x - 850 - gap 
                : panelData.position.x + 850 + gap,
              y: panelData.position.y
            }
          }
        }
      }
      
      return parentPosition
    }
    
    const smartPosition = calculateSmartPosition()
    
    // Update position in both stores
    dataStore.update(branchId, { position: smartPosition })
    const updatedBranchData = branchesMap.get(branchId)
    if (updatedBranchData) {
      updatedBranchData.position = smartPosition
    }

    // Dispatch both panel-specific and global events for annotation insertion
    const eventDetail = {
      type,
      annotationId,
      branchId,
      panelId: panel,
      text,
    }

    // Try panel-specific event first
    const panelElements = document.querySelectorAll('.panel')
    panelElements.forEach(element => {
      // Check if this is the correct panel by looking for the panel ID in the content
      const panelContent = element.querySelector(`[data-panel="${panel}"]`)
      if (panelContent || element.textContent?.includes(panel)) {
        element.dispatchEvent(new CustomEvent('insert-annotation', { 
          detail: eventDetail,
          bubbles: true 
        }))
      }
    })

    // Also dispatch global event as fallback
    window.dispatchEvent(new CustomEvent('insert-annotation-global', { 
      detail: eventDetail 
    }))

    // Create the panel for the new branch with smart position
    window.dispatchEvent(new CustomEvent('create-panel', { 
      detail: { 
        panelId: branchId,
        parentPanelId: panel,
        parentPosition: smartPosition
      } 
    }))

    // Force a re-render by triggering branch updated action
    dispatch({ type: "BRANCH_UPDATED" })

    // Hide the toolbar after creating annotation
    const toolbar = document.getElementById("annotation-toolbar")
    if (toolbar) {
      toolbar.classList.remove("visible")
    }

    // Clear selection
    dispatch({ type: "SET_SELECTION", payload: { text: "", range: null, panel: null } })
    
    // Clear browser text selection
    window.getSelection()?.removeAllRanges()
  }

  return (
    <div
      id="annotation-toolbar"
      className="annotation-toolbar"
      onMouseEnter={() => {
        const toolbar = document.getElementById("annotation-toolbar")
        if (toolbar) {
          toolbar.style.opacity = "1"
          toolbar.style.pointerEvents = "auto"
          toolbar.classList.add("visible")
        }
      }}
      onMouseLeave={() => {
        setTimeout(() => {
          const toolbar = document.getElementById("annotation-toolbar")
          if (toolbar && !toolbar.matches(':hover')) {
            toolbar.style.opacity = "0"
            toolbar.style.pointerEvents = "none"
            toolbar.classList.remove("visible")
          }
        }, 300)
      }}
      style={{
        position: "fixed",
        background: "white",
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "8px",
        boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
        display: "flex",
        gap: "8px",
        zIndex: 1000,
        opacity: 0,
        pointerEvents: "none",
        transform: "translateX(-50%) translateY(0)",
        transition: "opacity 0.2s ease, transform 0.2s ease",
      }}
    >
      <button
        onClick={() => createAnnotation('note')}
        className="annotation-btn note"
        title="Create Note"
        style={{
          background: "linear-gradient(135deg, #3498db 0%, #2980b9 100%)",
          color: "white",
          border: "none",
          borderRadius: "6px",
          padding: "8px 16px",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: 500,
          display: "flex",
          alignItems: "center",
          gap: "6px",
          transition: "transform 0.2s ease",
        }}
        onMouseEnter={(e) => e.currentTarget.style.transform = "scale(1.05)"}
        onMouseLeave={(e) => e.currentTarget.style.transform = "scale(1)"}
      >
        📝 Note
      </button>

      <button
        onClick={() => createAnnotation('explore')}
        className="annotation-btn explore"
        title="Create Exploration"
        style={{
          background: "linear-gradient(135deg, #f39c12 0%, #e67e22 100%)",
          color: "white",
          border: "none",
          borderRadius: "6px",
          padding: "8px 16px",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: 500,
          display: "flex",
          alignItems: "center",
          gap: "6px",
          transition: "transform 0.2s ease",
        }}
        onMouseEnter={(e) => e.currentTarget.style.transform = "scale(1.05)"}
        onMouseLeave={(e) => e.currentTarget.style.transform = "scale(1)"}
      >
        🔍 Explore
      </button>

      <button
        onClick={() => createAnnotation('promote')}
        className="annotation-btn promote"
        title="Create Promotion"
        style={{
          background: "linear-gradient(135deg, #27ae60 0%, #229954 100%)",
          color: "white",
          border: "none",
          borderRadius: "6px",
          padding: "8px 16px",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: 500,
          display: "flex",
          alignItems: "center",
          gap: "6px",
          transition: "transform 0.2s ease",
        }}
        onMouseEnter={(e) => e.currentTarget.style.transform = "scale(1.05)"}
        onMouseLeave={(e) => e.currentTarget.style.transform = "scale(1)"}
      >
        ⭐ Promote
      </button>

      <style jsx>{`
        .annotation-toolbar.visible {
          opacity: 1 !important;
          pointer-events: auto !important;
          transform: translateX(-50%) translateY(-10px) !important;
        }
      `}</style>
    </div>
  )
}
