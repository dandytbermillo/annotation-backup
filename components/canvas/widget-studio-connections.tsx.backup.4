"use client"

import { useMemo, useEffect, useState } from "react"
import { useCanvas } from "./canvas-context"
import { CanvasItem, isPanel } from "@/types/canvas-items"
import { UnifiedProvider } from "@/lib/provider-switcher"
import { getPlainProvider } from "@/lib/provider-switcher"

interface WidgetStudioConnectionsProps {
  canvasItems: CanvasItem[]
  branchVersion?: number
}

interface ConnectionPoint {
  x: number
  y: number
}

interface Connection {
  id: string
  from: ConnectionPoint
  to: ConnectionPoint
  type: "note" | "explore" | "promote"
  label?: string
}

const PANEL_DEFAULT_WIDTH = 800
const PANEL_DEFAULT_HEIGHT = 600

/**
 * Widget Studio style connections
 * - Always horizontal entry/exit (right to left)
 * - Smooth Bézier S-curves
 * - Clean, minimal styling
 * - Hover effects
 */
export function WidgetStudioConnections({ canvasItems, branchVersion }: WidgetStudioConnectionsProps) {
  const { dataStore } = useCanvas()
  const plainProvider = getPlainProvider()
  const isPlainMode = !!plainProvider

  // Force re-render when dataStore changes
  // This solves the issue where connections don't appear after reload because
  // the branch loader updates dataStore with parentId AFTER this component renders
  const [dataStoreVersion, setDataStoreVersion] = useState(0)

  useEffect(() => {
    if (!isPlainMode) return

    const handleDataStoreChange = () => {
      setDataStoreVersion(prev => prev + 1)
    }

    dataStore.on('set', handleDataStoreChange)
    dataStore.on('update', handleDataStoreChange)
    dataStore.on('delete', handleDataStoreChange)

    return () => {
      dataStore.off('set', handleDataStoreChange)
      dataStore.off('update', handleDataStoreChange)
      dataStore.off('delete', handleDataStoreChange)
    }
  }, [dataStore, isPlainMode])

  const panels = canvasItems.filter(isPanel)
  const panelMap = new Map<string, CanvasItem>()
  panels.forEach((panel) => {
    if (panel.panelId) {
      panelMap.set(panel.panelId, panel)
    }
  })

  const branches = isPlainMode
    ? dataStore
    : UnifiedProvider.getInstance().getBranchesMap()

  const connections: Connection[] = useMemo(() => {
    const result: Connection[] = []

    panels.forEach((panel) => {
      const panelId = panel.panelId
      if (!panelId) return
      const branch = branches.get(panelId)
      if (!branch || !branch.parentId) return

      const parentPanel = panelMap.get(branch.parentId)
      if (!parentPanel) return

      const parentBranch = branches.get(branch.parentId)
      if (!parentBranch) return

      // Calculate connection points (always right edge to left edge)
      const parentPos = parentBranch?.worldPosition || parentBranch?.position || parentPanel.position
      const childPos = branch?.worldPosition || branch?.position || panel.position

      if (!parentPos || !childPos) return

      const parentWidth = parentPanel.dimensions?.width ?? PANEL_DEFAULT_WIDTH
      const parentHeight = parentPanel.dimensions?.height ?? PANEL_DEFAULT_HEIGHT
      const childHeight = panel.dimensions?.height ?? PANEL_DEFAULT_HEIGHT

      // Always connect from right edge of parent to left edge of child
      // Vertically centered on each panel
      const from: ConnectionPoint = {
        x: parentPos.x + parentWidth,
        y: parentPos.y + parentHeight / 2,
      }

      const to: ConnectionPoint = {
        x: childPos.x,
        y: childPos.y + childHeight / 2,
      }

      result.push({
        id: `${branch.parentId}-${panelId}`,
        from,
        to,
        type: normalizeType(branch.type),
        label: undefined, // Can add labels later
      })
    })

    return result
  }, [panels, branches, panelMap, branchVersion, dataStoreVersion])

  return (
    <svg
      className="absolute inset-0 pointer-events-none"
      style={{
        width: "10000px",
        height: "10000px",
        overflow: "visible",
        zIndex: 0,
      }}
    >
      <defs>
        {/* Subtle drop shadow for depth */}
        <filter id="connection-shadow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
          <feOffset dx="0" dy="1" result="offsetblur" />
          <feComponentTransfer>
            <feFuncA type="linear" slope="0.1" />
          </feComponentTransfer>
          <feMerge>
            <feMergeNode />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>

        {/* Arrow marker for connection end points */}
        <marker
          id="widget-arrow"
          markerWidth="8"
          markerHeight="8"
          refX="7"
          refY="4"
          orient="auto"
          markerUnits="strokeWidth"
        >
          <path
            d="M 0 0 L 8 4 L 0 8 z"
            fill="rgba(148, 163, 184, 0.8)"
            stroke="none"
          />
        </marker>
      </defs>

      {connections.map((connection) => {
        const pathData = createWidgetStudioPath(connection.from, connection.to)
        const color = getConnectionColor(connection.type)
        const labelPosition = calculateLabelPosition(connection.from, connection.to)

        return (
          <g key={connection.id} className="connection-group">
            {/* Main path */}
            <path
              d={pathData}
              fill="none"
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              className="transition-all duration-200 hover:stroke-[3px] hover:opacity-100"
              style={{ opacity: 0.6 }}
              filter="url(#connection-shadow)"
              markerEnd="url(#widget-arrow)"
            />

            {/* Connection point dots */}
            <circle
              cx={connection.from.x}
              cy={connection.from.y}
              r="4"
              fill={color}
              className="opacity-0 transition-opacity duration-200 group-hover:opacity-100"
            />
            <circle
              cx={connection.to.x}
              cy={connection.to.y}
              r="4"
              fill={color}
              className="opacity-0 transition-opacity duration-200 group-hover:opacity-100"
            />

            {/* Optional label */}
            {connection.label && (
              <g transform={`translate(${labelPosition.x}, ${labelPosition.y})`}>
                <rect
                  x="-20"
                  y="-10"
                  width="40"
                  height="20"
                  rx="4"
                  fill="white"
                  stroke={color}
                  strokeWidth="1"
                  opacity="0.9"
                />
                <text
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fontSize="11"
                  fill="#666"
                  fontFamily="system-ui, -apple-system, sans-serif"
                >
                  {connection.label}
                </text>
              </g>
            )}
          </g>
        )
      })}
    </svg>
  )
}

/**
 * Create Widget Studio style Bézier path
 * Always creates horizontal S-curve from right to left
 */
function createWidgetStudioPath(from: ConnectionPoint, to: ConnectionPoint): string {
  const dx = to.x - from.x
  const dy = to.y - from.y

  // Control point offset - determines curve smoothness
  // Widget Studio uses about 40% of horizontal distance
  const controlOffset = Math.abs(dx) * 0.4

  // Control points for horizontal S-curve
  const control1 = {
    x: from.x + controlOffset,
    y: from.y,
  }

  const control2 = {
    x: to.x - controlOffset,
    y: to.y,
  }

  return `M ${from.x},${from.y} C ${control1.x},${control1.y} ${control2.x},${control2.y} ${to.x},${to.y}`
}

/**
 * Calculate position for optional label on path
 */
function calculateLabelPosition(from: ConnectionPoint, to: ConnectionPoint): ConnectionPoint {
  return {
    x: (from.x + to.x) / 2,
    y: (from.y + to.y) / 2,
  }
}

/**
 * Get Widget Studio style colors (subtle, pastel)
 */
function getConnectionColor(type: "note" | "explore" | "promote"): string {
  switch (type) {
    case "note":
      return "#94a3b8" // Slate-400 - subtle blue-gray
    case "explore":
      return "#fbbf24" // Amber-400 - warm yellow
    case "promote":
      return "#34d399" // Emerald-400 - fresh green
    default:
      return "#94a3b8"
  }
}

function normalizeType(type?: string): "note" | "explore" | "promote" {
  if (type === "note" || type === "explore" || type === "promote") {
    return type
  }
  return "note"
}
