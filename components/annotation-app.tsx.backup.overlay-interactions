"use client"

import { useState, useRef, useEffect, useCallback, useMemo, useReducer } from "react"
import { CanvasAwareFloatingToolbar } from "./canvas-aware-floating-toolbar"
import type { OverlayPopup } from "./floating-toolbar"
import { CoordinateBridge } from "@/lib/utils/coordinate-bridge"
import { trackNoteAccess, createNote } from "@/lib/utils/note-creator"
import { LayerProvider, useLayer } from "@/components/canvas/layer-provider"
import {
  OverlayLayoutAdapter,
  OverlayLayoutConflictError,
  type OverlayLayoutPayload,
  isOverlayPersistenceEnabled,
} from "@/lib/adapters/overlay-layout-adapter"
import { debugLog, isDebugEnabled } from "@/lib/utils/debug-logger"
import { toast } from "@/hooks/use-toast"
import { CanvasWorkspaceProvider, useCanvasWorkspace, SHARED_WORKSPACE_ID } from "./canvas/canvas-workspace-context"
import { ensurePanelKey } from "@/lib/canvas/composite-id"
import { isDefaultMainPosition } from "@/lib/canvas/position-utils"
import { computeVisuallyCenteredWorldPosition } from "@/lib/canvas/visual-centering"
import {
  useCanvasCentering,
  CENTER_RETRY_ATTEMPTS,
  CENTER_EXISTING_NOTES_ENABLED,
} from "@/lib/hooks/annotation/use-canvas-centering"
import { ConstellationProvider } from "@/components/constellation/constellation-context"
import type { CanvasSidebarTab } from "@/components/sidebar/canvas-sidebar"
import { SidebarPreviewPopups } from "@/components/sidebar/sidebar-preview-popups"
import { WorkspaceToggleMenu } from "@/components/workspace/workspace-toggle-menu"
import { AnnotationWorkspaceCanvas } from "@/components/workspace/annotation-workspace-canvas"
import { WorkspaceCanvasContent } from "@/components/workspace/workspace-canvas-content"
import { WorkspaceCanvasArea } from "@/components/workspace/workspace-canvas-area"
import { WorkspaceOverlay } from "@/components/workspace/workspace-overlay"
import { WorkspaceToolbarStrip } from "@/components/workspace/workspace-toolbar-strip"
import { WorkspacePreviewPortal } from "@/components/workspace/workspace-preview-portal"
import { WorkspaceFloatingToolbar } from "@/components/workspace/workspace-floating-toolbar"
import { WorkspaceConstellationLayer } from "@/components/workspace/workspace-constellation-layer"
import { WorkspaceSidebar } from "@/components/workspace/workspace-sidebar"
import type { OverlayCameraState } from "@/lib/types/overlay-layout"
import { Z_INDEX } from "@/lib/constants/z-index"
import { useNotePreviewHover } from "@/hooks/useNotePreviewHover"
import { useKnowledgeBaseWorkspace } from "@/lib/hooks/annotation/use-knowledge-base-workspace"
import { useFolderCache } from "@/lib/hooks/annotation/use-folder-cache"
import { usePopupOverlayState } from "@/lib/hooks/annotation/use-popup-overlay-state"
import { useOverlayPopupLayout } from "@/lib/hooks/annotation/use-overlay-popup-layout"
import { useOverlayLayoutPersistence } from "@/lib/hooks/annotation/use-overlay-layout-persistence"
import { useOverlayLayoutSaveQueue } from "@/lib/hooks/annotation/use-overlay-layout-save-queue"
import { useOverlayWorkspaces } from "@/lib/hooks/annotation/use-overlay-workspaces"
import { useSidebarFolderPopups, type SidebarNotePreviewContext } from "@/lib/hooks/annotation/use-sidebar-folder-popups"
import { useWorkspaceNotesWidget } from "@/lib/hooks/annotation/use-workspace-notes-widget"
import { useConstellationViewState } from "@/lib/hooks/annotation/use-constellation-view-state"
import { useOrganizationSidebarActions } from "@/lib/hooks/annotation/use-organization-sidebar-actions"
import { usePopupBulkActions } from "@/lib/hooks/annotation/use-popup-bulk-actions"
import { useKnowledgeBaseSidebar } from "@/lib/hooks/annotation/use-knowledge-base-sidebar"
import { useWorkspaceNoteTitleSync } from "@/lib/hooks/annotation/use-workspace-note-title-sync"
import { useWorkspacePanelPositions } from "@/lib/hooks/annotation/use-workspace-panel-positions"
import { useWorkspaceMainOnlyNotes } from "@/lib/hooks/annotation/use-workspace-main-only-notes"
import { useWorkspaceCanvasState } from "@/lib/hooks/annotation/use-workspace-canvas-state"
import { useOverlayDragHandlers } from "@/lib/hooks/annotation/use-overlay-drag-handlers"
import { useWorkspaceOverlayPersistence } from "@/lib/hooks/annotation/use-workspace-overlay-persistence"
import { useWorkspaceOverlayInteractions } from "@/lib/hooks/annotation/use-workspace-overlay-interactions"
import { useWorkspaceSidebarState } from "@/lib/hooks/annotation/use-workspace-sidebar-state"
import { AnnotationWorkspaceView } from "@/components/annotation-workspace-view"

const ANNOTATION_APP_REFACTOR_PHASE = process.env.NEXT_PUBLIC_ANNOTATION_APP_REFACTOR_PHASE || 'off'
const FOLDER_CACHE_MAX_AGE_MS = 30000

// Helper to derive display name from path when folder.name is empty
function deriveFromPath(path: string | undefined | null): string | null {
  if (!path || typeof path !== 'string') return null
  const trimmed = path.trim()
  if (!trimmed) return null

  // Remove trailing slashes
  const normalized = trimmed.replace(/\/+$/, '')
  if (!normalized) return null

  // Get last segment
  const segments = normalized.split('/')
  const lastSegment = segments[segments.length - 1]
  return lastSegment && lastSegment.trim() ? lastSegment.trim() : null
}

const DEFAULT_CAMERA: OverlayCameraState = { x: 0, y: 0, scale: 1 }

const camerasEqual = (a: OverlayCameraState, b: OverlayCameraState) =>
  a.x === b.x && a.y === b.y && a.scale === b.scale

const DEFAULT_POPUP_WIDTH = 300
const DEFAULT_POPUP_HEIGHT = 400
const MIN_POPUP_WIDTH = 200
const MIN_POPUP_HEIGHT = 200
const MAX_POPUP_WIDTH = 900
const MAX_POPUP_HEIGHT = 900

type AnnotationAppContentProps = {
  useShellView?: boolean
}

function AnnotationAppContent({ useShellView = false }: AnnotationAppContentProps) {
  const {
    openNotes,
    openNote: openWorkspaceNote,
    closeNote: closeWorkspaceNote,
    isWorkspaceReady,
    isWorkspaceLoading,
    isHydrating,
    workspaceError,
    refreshWorkspace,
    getPendingPosition,
    getCachedPosition,
    getWorkspace
  } = useCanvasWorkspace()
  const sharedWorkspace = useMemo(() => getWorkspace(SHARED_WORKSPACE_ID), [getWorkspace])

  // Initialize activeNoteId from localStorage (persist which note canvas is focused)
  const [activeNoteId, setActiveNoteId] = useState<string | null>(() => {
    if (typeof window !== 'undefined') {
      try {
        const stored =
          localStorage.getItem('annotation_activeNoteId') ??
          localStorage.getItem('annotation_focusedNoteId') ??
          localStorage.getItem('annotation_selectedNoteId')
        return stored || null
      } catch (err) {
        debugLog({
          component: 'AnnotationApp',
          action: 'localStorage_focus_load_failed',
          metadata: { error: err instanceof Error ? err.message : 'Unknown error' }
        })
        return null
      }
    }
    return null
  })
  const [skipSnapshotForNote, setSkipSnapshotForNote] = useState<string | null>(null)
  const layerContext = useLayer()
  const {
    activeSidebarTab,
    showConstellationPanel,
    canvasMode,
    setCanvasMode,
    handleSidebarTabChange,
    toggleConstellationView,
  } = useConstellationViewState({ layerContext })
  const multiLayerEnabled = true
  const [shouldLoadOverlay, setShouldLoadOverlay] = useState(false)
  const overlayHydrationTriggerRef = useRef<string | null>(null)

  const ensureOverlayHydrated = useCallback((reason: string) => {
    setShouldLoadOverlay(prev => {
      if (prev) return prev
      overlayHydrationTriggerRef.current = reason
      return true
    })
  }, [])

  useEffect(() => {
    if (!shouldLoadOverlay) return
    const trigger = overlayHydrationTriggerRef.current ?? 'unknown'
    if (isDebugEnabled()) {
      debugLog({
        component: 'AnnotationApp',
        action: 'overlay_hydration_enabled',
        metadata: { trigger },
      })
    } else {
      console.log(`[AnnotationApp] Overlay hydration enabled (${trigger})`)
    }
    overlayHydrationTriggerRef.current = null
  }, [shouldLoadOverlay])

  useEffect(() => {
    if (layerContext?.activeLayer === 'popups') {
      ensureOverlayHydrated('layer-active')
    }
  }, [layerContext?.activeLayer, ensureOverlayHydrated])

  const activeNoteIdRef = useRef<string | null>(activeNoteId)
  useEffect(() => {
    activeNoteIdRef.current = activeNoteId
  }, [activeNoteId])

  const {
    canvasRef,
    freshNoteSeeds,
    freshNoteIds,
    registerFreshNote,
    consumeFreshNoteSeed,
    storeFreshNoteSeed,
    handleFreshNoteHydrated,
    handleSnapshotLoadComplete,
    centerNoteOnCanvas,
  } = useCanvasCentering({
    activeNoteIdRef,
    debugLog,
    sharedWorkspace,
  })


  const {
    canvasState,
    setCanvasState,
    handleCanvasStateChange,
    lastCanvasInteractionRef,
    reopenSequenceRef,
    newNoteSequenceRef,
  } = useWorkspaceCanvasState()
  const { mainOnlyNotes, requestMainOnlyNote, handleMainOnlyLayoutHandled } = useWorkspaceMainOnlyNotes()

  // Display settings state (backdrop style preference)
  const [backdropStyle, setBackdropStyle] = useState<string>('opaque')

  // Overlay popups state - persists independently of toolbar (like activeNoteId)
  const latestCameraRef = useRef<OverlayCameraState>(DEFAULT_CAMERA)
  const prevCameraForSaveRef = useRef<OverlayCameraState>(DEFAULT_CAMERA)
  const knowledgeBaseWorkspace = useKnowledgeBaseWorkspace()
  const {
    workspaceId: knowledgeBaseWorkspaceId,
    appendWorkspaceParam: appendKnowledgeBaseWorkspaceParam,
    withWorkspaceHeaders: withKnowledgeBaseHeaders,
    withWorkspacePayload: withKnowledgeBasePayload,
    fetchWithWorkspace: fetchWithKnowledgeBase,
    resolveWorkspaceId: resolveKnowledgeBaseWorkspaceId,
  } = knowledgeBaseWorkspace
  const applyWorkspacePayload = useCallback(
    (payload: Record<string, unknown>, workspaceId: string | null) =>
      withKnowledgeBasePayload(payload, workspaceId ?? undefined),
    [withKnowledgeBasePayload],
  )

  const [currentWorkspaceId, setCurrentWorkspaceId] = useState<string | null>(null)
  const [isWorkspaceLayoutLoading, setIsWorkspaceLayoutLoading] = useState(false)
  const workspacesLoadedRef = useRef(false)
  const lastDiagnosticsHashRef = useRef<string | null>(null)
  const fetchNotePreview = useCallback(
    async (noteId: string) => {
      const response = await fetchWithKnowledgeBase(`/api/items/${noteId}`)
      if (!response.ok) throw new Error('Failed to fetch note')
      const data = await response.json()
      return {
        content: data?.item?.content,
        contentText: data?.item?.contentText,
      }
    },
    [fetchWithKnowledgeBase]
  )

  const {
    preview: notePreview,
    isLoading: isLoadingNotePreview,
    handleHover: triggerNotePreviewHover,
    handleLeave: triggerNotePreviewLeave,
    handleTooltipEnter: triggerNotePreviewTooltipEnter,
    handleTooltipLeave: triggerNotePreviewTooltipLeave,
    cancelPreview: cancelNotePreview,
  } = useNotePreviewHover<SidebarNotePreviewContext>({
    fetchNote: fetchNotePreview,
  })

  const folderCacheApi = useFolderCache({
    workspaceId: knowledgeBaseWorkspaceId,
    cacheMaxAgeMs: FOLDER_CACHE_MAX_AGE_MS,
  })
  const {
    getEntry: getFolderCacheEntry,
    updateFolderSnapshot: updateFolderCacheEntry,
    updateChildrenSnapshot: updateFolderCacheChildren,
    invalidate: invalidateFolderCache,
    fetchFolder: fetchGlobalFolder,
    fetchChildren: fetchGlobalChildren,
  } = folderCacheApi

  const sidebarLoaderDeps = useMemo(
    () => ({
      appendWorkspaceParam: appendKnowledgeBaseWorkspaceParam,
      fetchWithWorkspace: fetchWithKnowledgeBase,
      knowledgeBaseWorkspaceId,
      resolveWorkspaceId: resolveKnowledgeBaseWorkspaceId,
      updateFolderCacheEntry,
      updateFolderCacheChildren,
    }),
    [
      appendKnowledgeBaseWorkspaceParam,
      fetchWithKnowledgeBase,
      knowledgeBaseWorkspaceId,
      resolveKnowledgeBaseWorkspaceId,
      updateFolderCacheEntry,
      updateFolderCacheChildren,
    ],
  )

  const noteTitleDeps = useMemo(
    () => ({
      fetchWithKnowledgeBase,
    }),
    [fetchWithKnowledgeBase],
  )

  const {
    organizationSidebarData: sidebarState,
    knowledgeBaseId,
    noteTitleMapRef,
    forceNoteTitleUpdate,
    setTitleForNote,
    ensureTitleFromServer,
  } = useKnowledgeBaseSidebar({
    loader: sidebarLoaderDeps,
    noteTitles: noteTitleDeps,
    sharedWorkspace,
    enabled: shouldLoadOverlay,
  })

  const sortedOpenNotes = useMemo(() => {
    return [...openNotes].sort((a, b) => {
      if (a.noteId === b.noteId) return 0
      if (!a.updatedAt && b.updatedAt) return 1
      if (a.updatedAt && !b.updatedAt) return -1
      if (a.updatedAt && b.updatedAt) {
        return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      }
      return a.noteId.localeCompare(b.noteId)
    })
  }, [openNotes])

  useWorkspaceNoteTitleSync({
    sharedWorkspace,
    sortedOpenNotes,
    noteTitleMapRef,
    setTitleForNote,
    ensureTitleFromServer,
    forceNoteTitleUpdate,
  })

  const {
    logWorkspaceNotePositions,
    resolveMainPanelPosition,
    hasRenderedMainPanel,
  } = useWorkspacePanelPositions({
    sharedWorkspace,
    sortedOpenNotes,
    openNotes,
    activeNoteId,
    getPendingPosition,
    getCachedPosition,
    debugLog,
  })

  const {
    popups: overlayPopups,
    setPopups: setOverlayPopups,
    draggingPopup,
    setDraggingPopup,
    overlayPanning,
    setOverlayPanning,
    moveCascadeState,
    hoverTimeouts,
    closeTimeouts,
    setHoverTimeout,
    clearHoverTimeout,
    setCloseTimeout,
    clearCloseTimeout,
    clearAllTimeouts,
    handlePopupDragStart: startPopupDrag,
    handlePopupDragMove,
    handlePopupDragEnd,
    getAllDescendants,
    toggleMoveCascade,
    clearMoveCascadeState,
    closePopupCascade,
    initiateCloseMode,
    confirmCloseMode,
    cancelCloseMode,
    togglePinCascade,
    handleFolderHover,
    handleFolderHoverLeave,
  } = usePopupOverlayState({
    layerContext,
    knowledgeBaseWorkspace,
    folderCache: folderCacheApi,
    fetchChildren: fetchGlobalChildren,
    ensureOverlayHydrated,
    popupWidth: DEFAULT_POPUP_WIDTH,
  })
  const {
    createOverlayPopup: handleCreateOverlayPopup,
    updatePopupPosition: handlePopupPositionChange,
    resizePopup: handleResizePopup,
  } = useOverlayPopupLayout({
    setPopups: setOverlayPopups,
    ensureOverlayHydrated,
    defaultWidth: DEFAULT_POPUP_WIDTH,
    defaultHeight: DEFAULT_POPUP_HEIGHT,
    minWidth: MIN_POPUP_WIDTH,
    maxWidth: MAX_POPUP_WIDTH,
    minHeight: MIN_POPUP_HEIGHT,
    maxHeight: MAX_POPUP_HEIGHT,
  })
  const { handleDeleteSelected, handleBulkMove } = usePopupBulkActions({
    fetchWithKnowledgeBase,
    withKnowledgeBasePayload: applyWorkspacePayload,
    knowledgeBaseWorkspaceId,
    setOverlayPopups,
    folderCacheApi: {
      updateFolderCacheChildren,
      invalidateFolderCache,
    },
  })

  const {
    showNotesWidget,
    setShowNotesWidget,
    notesWidgetPosition,
    setNotesWidgetPosition,
    activeEditorRef,
    activePanelId,
    setActivePanelId,
    toolbarActivePanel,
    setToolbarActivePanel,
    recentNotesRefreshTrigger,
    bumpRecentNotesRefresh,
    showAddComponentMenu,
    setShowAddComponentMenu,
    handleContextMenu,
  } = useWorkspaceNotesWidget({
    layerContext,
    multiLayerEnabled,
    clearAllTimeouts,
    canvasState,
    debugLog,
  })

  const organizationFolders = sidebarState.organizationFolders

  const { handleOrganizationSidebarSelect } = useOrganizationSidebarActions({
    knowledgeBaseId,
    organizationFolders,
    overlayPopups,
    setOverlayPopups,
    layerContext,
    setCanvasMode,
    ensureOverlayHydrated,
    appendKnowledgeBaseWorkspaceParam,
    knowledgeBaseWorkspaceId,
    fetchWithKnowledgeBase,
    fetchGlobalChildren,
    defaultPopupWidth: DEFAULT_POPUP_WIDTH,
    defaultPopupHeight: DEFAULT_POPUP_HEIGHT,
    folderCacheApi: {
      updateFolderCacheEntry,
      updateFolderCacheChildren,
      invalidateFolderCache,
    },
  })

  const organizationSidebarData = useMemo(() => {
    const pinnedIds = new Set(
      overlayPopups.filter(popup => popup.isPinned).map(popup => popup.folderId || popup.id)
    )

    const items = organizationFolders.map(item => ({
      ...item,
      pinned: pinnedIds.has(item.id),
    }))

    const totalItems = items.reduce((sum, item) => sum + (item.count ?? 0), 0)

    return {
      items,
      stats: {
        openPopups: overlayPopups.length,
        totalItems,
        pinnedPopups: pinnedIds.size,
      },
    }
  }, [organizationFolders, overlayPopups])


  const isPopupLayerActive = multiLayerEnabled && layerContext?.activeLayer === 'popups'
  const canRenderOverlay =
    shouldLoadOverlay &&
    !showConstellationPanel &&
    (!multiLayerEnabled || !layerContext || layerContext.activeLayer === 'popups')
  const shouldShowSidebar = showConstellationPanel || isPopupLayerActive

  // Persistence state for overlay layout
  const overlayPersistenceEnabled = isOverlayPersistenceEnabled()
  const overlayPersistenceActive = overlayPersistenceEnabled && shouldLoadOverlay
  const shouldShowWorkspaceToggle = overlayPersistenceActive && shouldShowSidebar

  const overlayAdapterRef = useRef<OverlayLayoutAdapter | null>(null)
  const layoutLoadedRef = useRef(false)
  const layoutRevisionRef = useRef<string | null>(null)
  const lastSavedLayoutHashRef = useRef<string | null>(null)
  const pendingLayoutRef = useRef<{ payload: OverlayLayoutPayload; hash: string } | null>(null)
  const saveInFlightRef = useRef(false)
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const isInitialLoadRef = useRef(false) // Track if we're in initial database load

  const { applyOverlayLayout } = useOverlayLayoutPersistence({
    overlayPersistenceActive,
    currentWorkspaceId,
    overlayPopups,
    overlayPopupsLength: overlayPopups.length,
    setOverlayPopups,
    fetchGlobalFolder,
    fetchGlobalChildren,
    fetchWithKnowledgeBase,
    toast,
    layerContext,
    debugLog,
    isDebugEnabled,
    overlayAdapterRef,
    layoutLoadedRef,
    layoutRevisionRef,
    lastSavedLayoutHashRef,
    pendingLayoutRef,
    saveInFlightRef,
    saveTimeoutRef,
    isInitialLoadRef,
    latestCameraRef,
    prevCameraForSaveRef,
    setIsWorkspaceLayoutLoading,
    defaultCamera: DEFAULT_CAMERA,
  })

  // Debug: Log persistence state on mount
  useEffect(() => {
    console.log('[AnnotationApp] overlayPersistenceEnabled =', overlayPersistenceEnabled)
  }, [overlayPersistenceEnabled])

  useEffect(() => {
    if (!isWorkspaceReady && !isWorkspaceLoading) {
      refreshWorkspace().catch(error => {
        console.error('[AnnotationApp] Workspace refresh failed:', error)
      })
    }
  }, [isWorkspaceReady, isWorkspaceLoading, refreshWorkspace])

  useEffect(() => {
    if (workspaceError) {
      console.error('[AnnotationApp] Workspace error:', workspaceError)
    }
  }, [workspaceError])

  useEffect(() => {
    if (!isWorkspaceReady) return

    const isFocusedOpen = activeNoteId ? openNotes.some(note => note.noteId === activeNoteId) : false

    if (!initialWorkspaceSyncRef.current) {
      initialWorkspaceSyncRef.current = true

      if (activeNoteId && !isFocusedOpen) {
        const pendingPosition = getPendingPosition(activeNoteId)
        const cachedPosition = getCachedPosition(activeNoteId)
        const resolvedPosition = resolveMainPanelPosition(activeNoteId)
        console.log(`[DEBUG AnnotationApp] Hydration position for ${activeNoteId}:`, {
          pendingPosition,
          cachedPosition,
          resolvedPosition
        })
        void openWorkspaceNote(activeNoteId, {
          persist: true,
          mainPosition: resolvedPosition ?? undefined,
        }).catch(error => {
          console.error('[AnnotationApp] Failed to ensure focused note is open:', error)
        })
      } else if (!activeNoteId && openNotes.length > 0) {
        setActiveNoteId(openNotes[0].noteId)
      }
    } else if (activeNoteId && !isFocusedOpen) {
      const fallback = openNotes[0]?.noteId ?? null
      setActiveNoteId(fallback ?? null)
    }
  }, [isWorkspaceReady, openNotes, activeNoteId, openWorkspaceNote, getPendingPosition, getCachedPosition, resolveMainPanelPosition])

  // Persist activeNoteId to localStorage when it changes
  useEffect(() => {
    if (typeof window !== 'undefined') {
      try {
        if (activeNoteId) {
          localStorage.setItem('annotation_activeNoteId', activeNoteId)
          localStorage.setItem('annotation_focusedNoteId', activeNoteId)
        } else {
          localStorage.removeItem('annotation_activeNoteId')
          localStorage.removeItem('annotation_focusedNoteId')
        }
      } catch (err) {
        debugLog({
          component: 'AnnotationApp',
          action: 'localStorage_focus_save_failed',
          metadata: {
            error: err instanceof Error ? err.message : 'Unknown error',
            operation: activeNoteId ? 'setItem' : 'removeItem'
          }
        })
      }
    }
  }, [activeNoteId, logWorkspaceNotePositions])

const initialWorkspaceSyncRef = useRef(false)

  // Determine collaboration mode from environment
  const collabMode = process.env.NEXT_PUBLIC_COLLAB_MODE || 'plain'
  const isPlainMode = collabMode === 'plain'
  // Adapt overlay popups for PopupOverlay component
  // Only show popups when popups layer is active, otherwise pass empty Map
  const adaptedPopups = useMemo(() => {
    const adapt = () => {
      const adapted = new Map()
      overlayPopups.forEach((popup) => {
        const adaptedPopup = {
          ...popup,
          width: popup.width ?? DEFAULT_POPUP_WIDTH,
          height: popup.height,
          sizeMode: popup.sizeMode ?? 'default',
          folder: popup.folder || {
            id: popup.folderId,
            name: popup.folderName,
            type: 'folder' as const,
            children: popup.children
          },
          canvasPosition: popup.canvasPosition,
          parentId: popup.parentPopupId // Map parentPopupId to parentId for PopupOverlay
        }
        adapted.set(popup.id, adaptedPopup)
      })
      return adapted
    }

    if (!multiLayerEnabled) {
      return adapt()
    }

    // When no layer context is available, still render popups using raw state
    if (!layerContext) {
      return adapt()
    }

    return adapt()
  }, [overlayPopups, multiLayerEnabled, layerContext, layerContext?.activeLayer])

  // Track previous popup count to detect when NEW popups are added
  const prevPopupCountRef = useRef(0)

  // Auto-switch to popups layer ONLY when NEW popups are created
  useEffect(() => {
    if (!multiLayerEnabled || !layerContext) return

    const currentCount = overlayPopups.length
    const previousCount = prevPopupCountRef.current

    // Skip auto-switch while layout is still loading from database (initial hydration)
    // This prevents auto-switch when restoring saved popups on app load
    if (!layoutLoadedRef.current) {
      prevPopupCountRef.current = currentCount
      return
    }

    // Only auto-switch when a new popup is ADDED (count increases) AFTER layout loaded
    if (currentCount > previousCount && currentCount > 0) {
      if (layerContext.activeLayer !== 'popups') {
        console.log('[AnnotationApp] New popup created, auto-switching to popups layer')
        layerContext.setActiveLayer('popups')
      }
    }

    // Update the ref for next comparison
    prevPopupCountRef.current = currentCount
  }, [overlayPopups.length, multiLayerEnabled, layerContext])

  // Clear pending hover timeouts when switching TO notes layer (prevent new popups)
  // But keep existing popups in state so they can be restored when switching back
  useEffect(() => {
    if (!multiLayerEnabled || !layerContext) return

    // When user switches to notes layer, clear pending timeouts but keep popup state
    if (layerContext.activeLayer === 'notes') {
      console.log('[AnnotationApp] Switched to notes layer, clearing pending hover timeouts')

      // Clear all pending timeouts to prevent new popups from appearing
      clearAllTimeouts()
    }
  }, [layerContext?.activeLayer, multiLayerEnabled, layerContext])

  // Cleanup all timeouts on unmount
  useEffect(() => {
    return () => {
      // Clear all hover timeouts
      clearAllTimeouts()
    }
  }, [])

  // Handle global mouse events for dragging popup
  const draggingActive = useOverlayDragHandlers({
    draggingPopup,
    onDragMove: handlePopupDragMove,
    onDragEnd: handlePopupDragEnd,
    layerContext,
  })


  const {
    buildLayoutPayload,
    flushLayoutSave,
    scheduleLayoutSave,
  } = useOverlayLayoutSaveQueue({
    overlayPopups,
    layerTransform: layerContext?.transforms.popups || DEFAULT_CAMERA,
    overlayPersistenceActive,
    overlayAdapterRef,
    layoutRevisionRef,
    lastSavedLayoutHashRef,
    pendingLayoutRef,
    saveTimeoutRef,
    saveInFlightRef,
    applyOverlayLayout,
    draggingPopup,
    defaultCamera: DEFAULT_CAMERA,
    defaultWidth: DEFAULT_POPUP_WIDTH,
    defaultHeight: DEFAULT_POPUP_HEIGHT,
    debugLog,
    isDebugEnabled,
  })

  useWorkspaceOverlayPersistence({
    overlayPopups,
    overlayPersistenceActive,
    overlayPersistenceEnabled,
    overlayPanning,
    draggingActive,
    layerTransform: layerContext?.transforms.popups || DEFAULT_CAMERA,
    latestCameraRef,
    prevCameraForSaveRef,
    layoutLoadedRef,
    scheduleLayoutSave,
    saveTimeoutRef,
    pendingLayoutRef,
  })

  const {
    workspaces,
    isWorkspaceListLoading,
    isWorkspaceSaving,
    workspaceDeletionId,
    workspaceMenuOpen,
    workspaceToggleRef,
    setWorkspaceMenuOpen,
    handleWorkspaceSelect,
    handleCreateWorkspace,
    handleDeleteWorkspace,
  } = useOverlayWorkspaces({
    overlayPersistenceActive,
    shouldShowWorkspaceToggle,
    currentWorkspaceId,
    setCurrentWorkspaceId,
    setCanvasMode,
    ensureOverlayHydrated,
    buildLayoutPayload,
    flushLayoutSave,
    lastSavedLayoutHashRef,
    pendingLayoutRef,
    saveTimeoutRef,
    overlayAdapterRef,
    layoutRevisionRef,
    layoutLoadedRef,
    setOverlayPopups,
    toast,
    workspacesLoadedRef,
    defaultCamera: DEFAULT_CAMERA,
  })

  const currentWorkspace = useMemo(
    () => workspaces.find(ws => ws.id === currentWorkspaceId) ?? null,
    [workspaces, currentWorkspaceId]
  )
  const currentWorkspaceName = currentWorkspace?.name ?? 'Workspace'
  const workspaceStatusLabel = workspaceDeletionId
    ? 'Deleting...'
    : isWorkspaceSaving
    ? 'Saving...'
    : isWorkspaceLayoutLoading
    ? 'Hydrating...'
    : isWorkspaceListLoading
    ? 'Loading...'
    : currentWorkspaceName

  useEffect(() => {
    if (!overlayPersistenceActive) {
      prevCameraForSaveRef.current = latestCameraRef.current
      return
    }
    if (!layoutLoadedRef.current) {
      prevCameraForSaveRef.current = latestCameraRef.current
      return
    }
    const prev = prevCameraForSaveRef.current
    const current = latestCameraRef.current
    if (!camerasEqual(prev, current)) {
      prevCameraForSaveRef.current = current
      scheduleLayoutSave(false)
    }
  }, [overlayPersistenceActive, scheduleLayoutSave, layerContext?.transforms.popups])

  // Load layout from database on mount
  // Save layout when overlayPopups changes
  // Use a ref to track if we need to save, to avoid infinite loops

  // Handle note selection with force re-center support
  const formatNoteLabel = useCallback((noteId: string) => {
    if (!noteId) return "Untitled"
    const stored = noteTitleMapRef.current.get(noteId)
    if (stored && stored.trim()) {
      return stored.trim()
    }
    if (noteId.length <= 8) return noteId
    return `${noteId.slice(0, 4)}…${noteId.slice(-3)}`
  }, [])

  const handleNoteSelect = useCallback((noteId: string, options?: { initialPosition?: { x: number; y: number } | null; source?: 'toolbar-create' | 'toolbar-open' | 'popup' | 'recent' }) => {
    debugLog({
      component: 'AnnotationApp',
      action: 'note_select',
      metadata: {
        noteId,
        activeNoteId,
        isReselect: noteId === activeNoteId,
        source: options?.source,
        hasOptions: !!options
      }
    })

    // Track note access in recent notes and refresh toolbar's recent notes list
    // Only refresh if tracking succeeds (promise resolves)
    const isReselect = noteId === activeNoteId
    const isToolbarCreation = options?.source === 'toolbar-create'

    if (isToolbarCreation) {
      registerFreshNote(noteId)
    }

    trackNoteAccess(noteId)
      .then(() => {
        bumpRecentNotesRefresh()
      })
      .catch(() => {
        // Error already logged by trackNoteAccess, silently skip refresh
        // Note will still open, just won't appear in recent notes
      })

    const emitHighlight = () => {
      // Skip highlight during workspace hydration (TDD §4.1)
      if (isHydrating) {
        debugLog({
          component: 'AnnotationApp',
          action: 'highlight_event_skipped',
          metadata: { noteId, reason: 'workspace_hydrating' }
        })
        return
      }

      const events = sharedWorkspace?.events
      if (!events) {
        debugLog({
          component: 'AnnotationApp',
          action: 'highlight_event_skipped',
          metadata: { noteId, reason: 'no_workspace_events' }
        })
        return
      }
      try {
        events.emit('workspace:highlight-note', { noteId })
      } catch (error) {
        console.warn('[AnnotationApp] Failed to emit highlight event:', error)
      }
    }

    if (isReselect) {
      logWorkspaceNotePositions('tab_click_reselect')
      debugLog({
        component: 'AnnotationApp',
        action: 'highlight_note',
        metadata: { noteId }
      })
      if (!isToolbarCreation) {
        emitHighlight()
      }
      return
    }

    // Different note - ensure it's marked open and marked as focused
    setSkipSnapshotForNote(noteId)
    const alreadyOpen = openNotes.some(open => open.noteId === noteId)

    debugLog({
      component: 'AnnotationApp',
      action: 'toolbar_click_debug',
      metadata: {
        noteId,
        alreadyOpen,
        openNotesCount: openNotes.length,
        openNoteIds: openNotes.map(n => n.noteId),
        isThisNoteInList: openNotes.some(n => n.noteId === noteId)
      }
    })

    // CRITICAL FIX (infinite-canvas approach): Separate new note creation from reopening
    // NEW NOTES: Always compute fresh viewport-centered position (NO CACHING)
    // EXISTING NOTES: Look up persisted position from database
    const hasExplicitPosition = Boolean(options?.initialPosition)
    let resolvedPosition = options?.initialPosition ?? null

    // CRITICAL FIX: Fetch persisted position early to use in centering guard
    // This prevents recentering notes that already have a saved position
    const persistedPosition = !alreadyOpen && !hasExplicitPosition
      ? resolveMainPanelPosition(noteId)
      : null

    // HYDRATION GAP FIX: Check if panel already rendered on canvas
    // During early hydration, openNotes is empty so resolveMainPanelPosition returns null,
    // but the canvas has already rendered panels from database. Treat rendered panels
    // as "having a persisted position" to prevent recentering during hydration gap.
    const panelAlreadyRendered = hasRenderedMainPanel(noteId)

    const hasPersistedPosition = Boolean(
      (persistedPosition && !isDefaultMainPosition(persistedPosition)) ||
      panelAlreadyRendered  // Treat rendered panels as persisted
    )

    debugLog({
      component: 'AnnotationApp',
      action: 'position_guard_check',
      metadata: {
        noteId,
        alreadyOpen,
        hasExplicitPosition,
        hasPersisted: !!persistedPosition,
        panelAlreadyRendered,
        hasPersistedPosition,
        persistedPosition
      }
    })

    if (isToolbarCreation && !hasExplicitPosition) {
      // NEW NOTE: Compute viewport-centered position using simple, direct formula
      // This is the infinite-canvas approach - no caching, no async lookups
      const currentCamera = canvasRef.current?.getCameraState?.() ?? canvasState

      debugLog({
        component: 'AnnotationApp',
        action: 'new_note_camera_state',
        metadata: {
          noteId,
          currentCamera,
          canvasState,
          hasGetCameraState: !!canvasRef.current?.getCameraState
        }
      })

      // Get viewport center in screen coordinates
      const viewportCenterX = typeof window !== 'undefined' ? window.innerWidth / 2 : 960
      const viewportCenterY = typeof window !== 'undefined' ? window.innerHeight / 2 : 540

      // Convert to world coordinates accounting for camera transform
      // Formula: worldX = (screenX - cameraX) / zoom
      const PANEL_WIDTH = 500
      const PANEL_HEIGHT = 400
      const worldX = (viewportCenterX - (currentCamera.translateX ?? 0)) / (currentCamera.zoom ?? 1) - PANEL_WIDTH / 2
      const worldY = (viewportCenterY - (currentCamera.translateY ?? 0)) / (currentCamera.zoom ?? 1) - PANEL_HEIGHT / 2

      resolvedPosition = { x: worldX, y: worldY }

      debugLog({
        component: 'AnnotationApp',
        action: 'new_note_viewport_centered',
        metadata: {
          noteId,
          viewportCenter: { x: viewportCenterX, y: viewportCenterY },
          camera: currentCamera,
          worldPosition: resolvedPosition,
          formula: `x = (${viewportCenterX} - ${currentCamera.translateX ?? 0}) / ${currentCamera.zoom ?? 1} - ${PANEL_WIDTH / 2}`,
          formulaY: `y = (${viewportCenterY} - ${currentCamera.translateY ?? 0}) / ${currentCamera.zoom ?? 1} - ${PANEL_HEIGHT / 2}`
        }
      })

      // DO NOT cache this position - use it immediately
    } else if (!hasExplicitPosition && !alreadyOpen) {
      // EXISTING NOTE: Use persisted position fetched earlier
      resolvedPosition = persistedPosition ?? null

      debugLog({
        component: 'AnnotationApp',
        action: 'existing_note_persisted_position',
        metadata: {
          noteId,
          persistedPosition: resolvedPosition,
          hasPersistedPosition
        }
      })
    }

    if (!alreadyOpen) {

      const shouldCenterExisting =
        CENTER_EXISTING_NOTES_ENABLED &&
        !isToolbarCreation &&
        !hasExplicitPosition &&
        !hasPersistedPosition  // CRITICAL FIX: Only center if no saved position exists

      debugLog({
        component: 'AnnotationApp',
        action: 'centering_guard_evaluated',
        metadata: {
          noteId,
          CENTER_EXISTING_NOTES_ENABLED,
          isToolbarCreation,
          hasExplicitPosition,
          hasPersistedPosition,
          panelAlreadyRendered,
          shouldCenterExisting,
          fixBlocked: !shouldCenterExisting && panelAlreadyRendered  // NEW: Show when hydration gap fix blocks centering
        }
      })

      let usedCenteredOverride = false
      if (shouldCenterExisting) {
        debugLog({
          component: 'AnnotationApp',
          action: 'centering_override_applying',
          metadata: { noteId, reason: 'shouldCenterExisting=true' }
        })
        // Get current camera state directly from canvas ref to avoid stale React state
        const currentCamera = canvasRef.current?.getCameraState?.() ?? canvasState

        debugLog({
          component: 'AnnotationApp',
          action: 'existing_note_centering_camera_state',
          metadata: {
            noteId,
            currentCamera,
            canvasState,
            hasGetCameraState: !!canvasRef.current?.getCameraState
          }
        })

        // EXISTING NOTES: Always use viewport center (null = use viewport center)
        // Don't use lastCanvasInteractionRef because we want screen center, not last click position
        const centeredCandidate = computeVisuallyCenteredWorldPosition(
          {
            translateX: currentCamera.translateX,
            translateY: currentCamera.translateY,
            zoom: currentCamera.zoom,
          },
          reopenSequenceRef.current,
          null,  // Force viewport center, ignore last interaction
        )

        debugLog({
          component: 'AnnotationApp',
          action: 'existing_note_centered_candidate',
          metadata: {
            noteId,
            centeredCandidate,
            lastInteraction: lastCanvasInteractionRef.current,
            sequenceCount: reopenSequenceRef.current.count
          }
        })

        // Use pure centered position (100%) - same behavior as new notes
        if (centeredCandidate) {
          resolvedPosition = centeredCandidate
          usedCenteredOverride = true

          // CRITICAL: Store in freshNoteSeeds so canvas gets position BEFORE first paint
          // This prevents the panel from appearing elsewhere and then moving
          storeFreshNoteSeed(noteId, centeredCandidate)
        }

        if (usedCenteredOverride) {
          const persistedPosition = resolveMainPanelPosition(noteId)
          debugLog({
            component: "AnnotationApp",
            action: "open_note_centered_override",
            metadata: {
              noteId,
              persistedPosition,
              centeredPosition: resolvedPosition,
              storedInFreshNoteSeeds: true
            },
          })
        }
      } else if (panelAlreadyRendered) {
        // HYDRATION GAP FIX: Centering blocked because panel already rendered
        debugLog({
          component: 'AnnotationApp',
          action: 'centering_blocked_by_hydration_gap_fix',
          metadata: {
            noteId,
            reason: 'Panel already rendered on canvas',
            panelAlreadyRendered,
            hasPersistedPosition
          }
        })
      }

      if (shouldCenterExisting) {
        requestMainOnlyNote(noteId)
      }

      const skipPersistPosition = false

      debugLog({
        component: 'AnnotationApp',
        action: 'calling_openWorkspaceNote',
        metadata: {
          noteId,
          resolvedPosition,
          isToolbarCreation,
          hasExplicitPosition
        }
      })

      void openWorkspaceNote(noteId, {
        persist: true,
        mainPosition: resolvedPosition ?? undefined,
        persistPosition: !skipPersistPosition,
      }).catch(error => {
        console.error('[AnnotationApp] Failed to open note in workspace:', error)
      })
    }
    setActiveNoteId(noteId)
    if (!isToolbarCreation) {
      emitHighlight()
    }
  }, [activeNoteId, logWorkspaceNotePositions, isHydrating, sharedWorkspace, openNotes, openWorkspaceNote, resolveMainPanelPosition, setSkipSnapshotForNote, registerFreshNote, bumpRecentNotesRefresh, canvasState, requestMainOnlyNote, storeFreshNoteSeed])

  const handleCloseNote = useCallback(
    (noteId: string) => {
      if (!noteId) return

      void closeWorkspaceNote(noteId).catch(error => {
        console.error('[AnnotationApp] Failed to close workspace note:', error)
      })
    },
    [closeWorkspaceNote],
  )

const handleCenterNote = useCallback(
    (noteId: string) => {
      if (!noteId) return

      debugLog({
        component: 'AnnotationApp',
        action: 'manual_center_request',
        metadata: {
          noteId,
          activeNoteId,
        },
      })

      if (noteId !== activeNoteId) {
        setActiveNoteId(noteId)
      }

      const events = sharedWorkspace?.events
      if (events) {
        try {
          events.emit('workspace:highlight-note', { noteId })
        } catch (error) {
          console.warn('[AnnotationApp] Failed to emit manual highlight event:', error)
        }
      }

      centerNoteOnCanvas(noteId, { attempts: CENTER_RETRY_ATTEMPTS + 1 })
    },
    [activeNoteId, setActiveNoteId, sharedWorkspace, centerNoteOnCanvas],
  )

  const handleSnapshotSettled = useCallback((noteId: string) => {
    setSkipSnapshotForNote(current => (current === noteId ? null : current))
  }, [])
  
  // Center panel when note selection changes

  // Handle right-click to show notes widget
  const handleCloseNotesWidget = useCallback(() => {
    setShowNotesWidget(false)
  }, [])

  // Handle registering active editor (called by panels when they gain focus)
  const handleRegisterActiveEditor = useCallback((editorRef: any, panelId: string) => {
    console.log('[AnnotationApp] Registering active editor for panel:', panelId)
    activeEditorRef.current = editorRef
    setActivePanelId(panelId)
  }, [])

  // Handle adding component (callback from FloatingToolbar)
  const handleAddComponentFromToolbar = useCallback((type: string, position?: { x: number; y: number }) => {
    // Call the canvas's addComponent method directly
    if (canvasRef.current?.addComponent) {
      canvasRef.current.addComponent(type, position)
    }
  }, [])

  // Handle backdrop style change (callback from FloatingToolbar)
  const handleBackdropStyleChange = useCallback((style: string) => {
    setBackdropStyle(style)
  }, [])

  const openNoteFromSidebar = useCallback(
    (noteId: string) => {
      layerContext?.setActiveLayer('notes')
      handleNoteSelect(noteId, { source: 'popup' })
    },
    [handleNoteSelect, layerContext]
  )

  const getPreviewSourceFolderId = useCallback(() => notePreview?.context?.sourceFolderId, [notePreview])

  const sidebarHoverHandlers = useSidebarFolderPopups({
    ensureOverlayHydrated,
    fetchChildren: fetchGlobalChildren,
    onSelectFolder: handleOrganizationSidebarSelect,
    onOpenNote: openNoteFromSidebar,
    triggerNotePreviewHover,
    triggerNotePreviewLeave,
    triggerNotePreviewTooltipEnter,
    triggerNotePreviewTooltipLeave,
    cancelNotePreview,
    getPreviewSourceFolderId,
  })

  const {
    sidebarFolderPopups,
    dismissSidebarPopup,
    handleSidebarPopupHover,
    handleSidebarEyeHoverLeave,
    handleSidebarOrgEyeHover,
    handleSidebarNotePreviewHover,
    handleSidebarNotePreviewLeave,
    handleSidebarPreviewTooltipEnter,
    handleSidebarPreviewTooltipLeave,
    handleSidebarPopupFolderClick,
    handleSidebarNoteOpen,
  } = sidebarHoverHandlers

  const handleToggleMoveCascade = toggleMoveCascade

  // Handle closing overlay popup with cascade (closes all children recursively)
  // Used for immediate close without interactive mode
  const handleCloseOverlayPopup = closePopupCascade

  // Handle toggle pin (prevent cascade-close)
  // Cascades pin state to all descendants automatically
  const handleTogglePin = togglePinCascade

  // Handle initiate close (enter interactive close mode)
  const handleInitiateClose = initiateCloseMode

  // Handle confirm close (user clicked Done - close parent and unpinned children)
  const handleConfirmClose = confirmCloseMode

  // Handle cancel close (user cancelled - revert to normal mode)
  const handleCancelClose = cancelCloseMode

  // Handle bulk move of items to target folder (drag-drop)
  // Navigation control functions
  const handleZoomIn = () => {
    setCanvasState(prev => ({ ...prev, zoom: Math.min(prev.zoom * 1.1, 2) }))
    if (canvasRef.current?.zoomIn) {
      canvasRef.current.zoomIn()
    }
  }

  const handleZoomOut = () => {
    setCanvasState(prev => ({ ...prev, zoom: Math.max(prev.zoom * 0.9, 0.3) }))
    if (canvasRef.current?.zoomOut) {
      canvasRef.current.zoomOut()
    }
  }

  const handleResetView = () => {
    setCanvasState(prev => ({ ...prev, zoom: 1 }))
    if (canvasRef.current?.resetView) {
      canvasRef.current.resetView()
    }
  }

  const handleToggleConnections = () => {
    setCanvasState(prev => ({ ...prev, showConnections: !prev.showConnections }))
    if (canvasRef.current?.toggleConnections) {
      canvasRef.current.toggleConnections()
    }
  }

  // Track note creation state to prevent double-clicks
  const [isCreatingNoteFromToolbar, setIsCreatingNoteFromToolbar] = useState(false)

  // Handler for creating new note from workspace toolbar
  // Reuses the same logic as floating toolbar's "+ Note" button
  const handleNewNoteFromToolbar = useCallback(async () => {
    if (isCreatingNoteFromToolbar) return // Prevent double-clicks

    setIsCreatingNoteFromToolbar(true)
    try {
      const result = await createNote({
        workspaceId: currentWorkspaceId ?? undefined
      })

      if (result.success && result.noteId) {
        // Open the newly created note
        handleNoteSelect(result.noteId, {
          source: 'toolbar-create'
        })
      } else {
        console.error('[AnnotationApp] Failed to create note:', result.error)
      }
    } catch (error) {
      console.error('[AnnotationApp] Error creating note:', error)
    } finally {
      setIsCreatingNoteFromToolbar(false)
    }
  }, [isCreatingNoteFromToolbar, handleNoteSelect, currentWorkspaceId])

  // Handler for opening settings from workspace toolbar
  const handleSettingsFromToolbar = useCallback(() => {
    // TODO: Implement settings panel
    console.log('[AnnotationApp] Settings clicked')
  }, [])

  const {
    handleFolderCreated,
    handlePopupDragStart,
    handlePopupHover,
    handleFolderRenamed,
  } = useWorkspaceOverlayInteractions({
    setOverlayPopups,
    updateFolderCacheChildren,
    invalidateFolderCache,
    startPopupDrag,
    layerContext,
    closeTimeouts,
    clearCloseTimeout,
  })

  const { workspaceSidebarProps } = useWorkspaceSidebarState({
    shouldShowSidebar,
    showConstellationPanel,
    activeSidebarTab,
    handleSidebarTabChange,
    sidebarState: {
      organizationFolders: sidebarState.organizationFolders,
      items: organizationSidebarData.items,
      stats: organizationSidebarData.stats,
    },
    overlayPopups,
    setOverlayPopups,
    layerContext,
    setCanvasMode,
    ensureOverlayHydrated,
    appendWorkspaceParam: appendKnowledgeBaseWorkspaceParam,
    knowledgeBaseWorkspaceId,
    fetchWithKnowledgeBase,
    fetchGlobalChildren,
    folderCacheApi: {
      updateFolderCacheEntry,
      updateFolderCacheChildren,
      invalidateFolderCache,
    },
    knowledgeBaseId,
    hoverHandlers: {
      handleSidebarOrgEyeHover,
      handleSidebarEyeHoverLeave,
      handleSidebarNotePreviewHover,
      handleSidebarNotePreviewLeave,
    },
  })

  const sidebarNode = <WorkspaceSidebar {...workspaceSidebarProps} />

  const workspaceToolbarProps = useMemo(
    () => ({
      notes: sortedOpenNotes,
      activeNoteId,
      isLoading: isWorkspaceLoading || isCreatingNoteFromToolbar,
      formatNoteLabel,
      onActivateNote: handleNoteSelect,
      onCenterNote: handleCenterNote,
      onCloseNote: handleCloseNote,
      onNewNote: handleNewNoteFromToolbar,
      onSettings: handleSettingsFromToolbar,
    }), [
      sortedOpenNotes,
      activeNoteId,
      isWorkspaceLoading,
      isCreatingNoteFromToolbar,
      formatNoteLabel,
      handleNoteSelect,
      handleCenterNote,
      handleCloseNote,
      handleNewNoteFromToolbar,
      handleSettingsFromToolbar,
    ],
  )

  const toolbarNode = (
    <WorkspaceToolbarStrip
      isVisible={!showConstellationPanel && !isPopupLayerActive}
      {...workspaceToolbarProps}
    />
  )

  const workspaceToggleNode = shouldShowWorkspaceToggle ? (
    <div
      className="absolute inset-x-0 top-4 flex justify-center"
      style={{ zIndex: Z_INDEX.DROPDOWN + 10, pointerEvents: 'none' }}
    >
      <WorkspaceToggleMenu
        ref={workspaceToggleRef}
        className="pointer-events-auto"
        statusLabel={workspaceStatusLabel}
        isOpen={workspaceMenuOpen}
        onToggleMenu={() => setWorkspaceMenuOpen(prev => !prev)}
        onCreateWorkspace={handleCreateWorkspace}
        disableCreate={isWorkspaceSaving || isWorkspaceLayoutLoading}
        isListLoading={isWorkspaceListLoading}
        workspaces={workspaces}
        currentWorkspaceId={currentWorkspaceId}
        deletingWorkspaceId={workspaceDeletionId}
        onSelectWorkspace={handleWorkspaceSelect}
        onDeleteWorkspace={handleDeleteWorkspace}
      />
    </div>
  ) : null

  const canvasAreaNode = (
    <WorkspaceCanvasArea
      showConstellationPanel={showConstellationPanel}
      isPopupLayerActive={isPopupLayerActive}
    >
      <WorkspaceCanvasContent
        hasOpenNotes={openNotes.length > 0}
        canvas={
          openNotes.length > 0 ? (
            <AnnotationWorkspaceCanvas
              key="workspace"
              ref={canvasRef}
              noteIds={openNotes.map(note => note.noteId)}
              primaryNoteId={activeNoteId ?? openNotes[0].noteId}
              freshNoteSeeds={freshNoteSeeds}
              onConsumeFreshNoteSeed={consumeFreshNoteSeed}
              isNotesExplorerOpen={false}
              freshNoteIds={freshNoteIds}
              onFreshNoteHydrated={handleFreshNoteHydrated}
              onCanvasStateChange={handleCanvasStateChange}
              mainOnlyNoteIds={mainOnlyNotes}
              onMainOnlyLayoutHandled={handleMainOnlyLayoutHandled}
              showAddComponentMenu={showAddComponentMenu}
              onToggleAddComponentMenu={() => setShowAddComponentMenu(!showAddComponentMenu)}
              onRegisterActiveEditor={handleRegisterActiveEditor}
              onSnapshotLoadComplete={handleSnapshotLoadComplete}
              skipSnapshotForNote={skipSnapshotForNote}
              onSnapshotSettled={handleSnapshotSettled}
            >
              {showNotesWidget && (
                <CanvasAwareFloatingToolbar
                  x={notesWidgetPosition.x}
                  y={notesWidgetPosition.y}
                  onClose={handleCloseNotesWidget}
                  onSelectNote={handleNoteSelect}
                  onCreateOverlayPopup={handleCreateOverlayPopup}
                  onAddComponent={handleAddComponentFromToolbar}
                  editorRef={activeEditorRef}
                  activePanelId={activePanelId}
                  onBackdropStyleChange={handleBackdropStyleChange}
                  onFolderRenamed={handleFolderRenamed}
                  activePanel={toolbarActivePanel}
                  onActivePanelChange={setToolbarActivePanel}
                  refreshRecentNotes={recentNotesRefreshTrigger}
                  onToggleConstellationPanel={toggleConstellationView}
                  showConstellationPanel={showConstellationPanel}
                  knowledgeBaseWorkspace={knowledgeBaseWorkspace}
                />
              )}
            </AnnotationWorkspaceCanvas>
          ) : null
        }
      />
    </WorkspaceCanvasArea>
  )

  const workspaceOverlayProps = useMemo(
    () => ({
      shouldRender: canRenderOverlay,
      popups: adaptedPopups,
      draggingPopup,
      onClosePopup: handleCloseOverlayPopup,
      onInitiateClose: handleInitiateClose,
      onConfirmClose: handleConfirmClose,
      onCancelClose: handleCancelClose,
      onTogglePin: handleTogglePin,
      onDragStart: handlePopupDragStart,
      onHoverFolder: handleFolderHover,
      onLeaveFolder: handleFolderHoverLeave,
      onPopupHover: handlePopupHover,
      onSelectNote: handleNoteSelect,
      onDeleteSelected: handleDeleteSelected,
      onBulkMove: handleBulkMove,
      onFolderCreated: handleFolderCreated,
      onFolderRenamed: handleFolderRenamed,
      onPopupCardClick: handleCloseNotesWidget,
      onContextMenu: handleContextMenu,
      onPopupPositionChange: handlePopupPositionChange,
      onResizePopup: handleResizePopup,
      isLocked: isWorkspaceLayoutLoading,
      sidebarOpen: isPopupLayerActive,
      backdropStyle,
      workspaceId: currentWorkspaceId,
      knowledgeBaseWorkspace,
      activeMoveCascadeParentId: moveCascadeState.parentId,
      moveCascadeChildIds: moveCascadeState.childIds,
      onToggleMoveCascade: handleToggleMoveCascade,
      moveCascadeState,
      onClearMoveCascadeState: clearMoveCascadeState,
    }),
    [
      adaptedPopups,
      backdropStyle,
      canRenderOverlay,
      clearMoveCascadeState,
      currentWorkspaceId,
      draggingPopup,
      handleBulkMove,
      handleCancelClose,
      handleCloseNotesWidget,
      handleCloseOverlayPopup,
      handleConfirmClose,
      handleContextMenu,
      handleFolderCreated,
      handleFolderHover,
      handleFolderHoverLeave,
      handleInitiateClose,
      handlePopupDragStart,
      handlePopupPositionChange,
      handleResizePopup,
      handleToggleMoveCascade,
      handleTogglePin,
      handleDeleteSelected,
      handlePopupHover,
      handleNoteSelect,
      handleFolderRenamed,
      isPopupLayerActive,
      isWorkspaceLayoutLoading,
      knowledgeBaseWorkspace,
      moveCascadeState,
    ],
  )

  const workspaceLayersNode = <WorkspaceOverlay {...workspaceOverlayProps} />

  const workspaceFloatingToolbarProps = useMemo(
    () => ({
      x: notesWidgetPosition.x,
      y: notesWidgetPosition.y,
      onClose: handleCloseNotesWidget,
      onSelectNote: handleNoteSelect,
      onCreateOverlayPopup: handleCreateOverlayPopup,
      onAddComponent: handleAddComponentFromToolbar,
      editorRef: activeEditorRef,
      activePanelId,
      onBackdropStyleChange: handleBackdropStyleChange,
      onFolderRenamed: handleFolderRenamed,
      activePanel: toolbarActivePanel,
      onActivePanelChange: setToolbarActivePanel,
      refreshRecentNotes: recentNotesRefreshTrigger,
      onToggleConstellationPanel: toggleConstellationView,
      showConstellationPanel,
      knowledgeBaseWorkspace,
    }), [
      activePanelId,
      activeEditorRef,
      handleAddComponentFromToolbar,
      handleBackdropStyleChange,
      handleCloseNotesWidget,
      handleCreateOverlayPopup,
      handleFolderRenamed,
      handleNoteSelect,
      knowledgeBaseWorkspace,
      notesWidgetPosition.x,
      notesWidgetPosition.y,
      recentNotesRefreshTrigger,
      setToolbarActivePanel,
      showConstellationPanel,
      toggleConstellationView,
      toolbarActivePanel,
    ],
  )

  const floatingToolbarNode = (
    <WorkspaceFloatingToolbar
      visible={showNotesWidget && !activeNoteId && !showConstellationPanel}
      {...workspaceFloatingToolbarProps}
    />
  )

  const previewPortalNode = (
    <WorkspacePreviewPortal
      preview={notePreview}
      isLoading={isLoadingNotePreview}
      onOpenNote={handleSidebarNoteOpen}
      onDismiss={cancelNotePreview}
      onMouseEnter={handleSidebarPreviewTooltipEnter}
      onMouseLeave={handleSidebarPreviewTooltipLeave}
    />
  )

  const sidebarPreviewPopupsNode = shouldLoadOverlay ? (
    <SidebarPreviewPopups
      popups={sidebarFolderPopups}
      onPopupHover={handleSidebarPopupHover}
      onPopupLeave={handleSidebarEyeHoverLeave}
      onDismiss={dismissSidebarPopup}
      onFolderHover={handleSidebarOrgEyeHover}
      onFolderClick={handleSidebarPopupFolderClick}
      onNotePreviewHover={handleSidebarNotePreviewHover}
      onNotePreviewLeave={handleSidebarNotePreviewLeave}
      onNoteOpen={handleSidebarNoteOpen}
    />
  ) : null


  const constellationPanelNode = (
    <WorkspaceConstellationLayer visible={showConstellationPanel} />
  )

  const workspaceView = (
    <AnnotationWorkspaceView
      sidebar={sidebarNode}
      toolbar={toolbarNode}
      workspaceToggle={workspaceToggleNode}
      canvasArea={canvasAreaNode}
      workspaceLayers={workspaceLayersNode}
      sidebarPreviewPopups={sidebarPreviewPopupsNode}
      floatingToolbar={floatingToolbarNode}
      previewPortal={previewPortalNode}
      constellationPanel={constellationPanelNode}
      onMainAreaContextMenu={handleContextMenu}
    />
  )

  if (useShellView) {
    return (
      <ConstellationProvider>
        {workspaceView}
      </ConstellationProvider>
    )
  }

  return (
    <ConstellationProvider>
      {workspaceView}
    </ConstellationProvider>
  )
}

export function AnnotationApp() {
  const phase = ANNOTATION_APP_REFACTOR_PHASE
  const useShell = phase === 'shell' || phase === 'shell_test' || phase === 'all'

  if (useShell) {
    return <AnnotationAppShell />
  }

  return (
    <LayerProvider initialPopupCount={0}>
      <CanvasWorkspaceProvider>
        <AnnotationAppContent />
      </CanvasWorkspaceProvider>
    </LayerProvider>
  )
}

function AnnotationAppShell() {
  return (
    <LayerProvider initialPopupCount={0}>
      <CanvasWorkspaceProvider>
        <AnnotationAppContent useShellView />
      </CanvasWorkspaceProvider>
    </LayerProvider>
  )
}
