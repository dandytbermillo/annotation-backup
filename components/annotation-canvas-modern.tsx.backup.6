"use client"

import { useEffect, useState, forwardRef, useImperativeHandle, useRef, useCallback, useMemo } from "react"
import { createPortal } from "react-dom"
import { CanvasProvider, useCanvas } from "./canvas/canvas-context"
import { IsolationProvider } from "@/lib/isolation/context"
import { CanvasPanel } from "./canvas/canvas-panel"
import { AnnotationToolbar } from "./canvas/annotation-toolbar"
import { UnifiedProvider } from "@/lib/provider-switcher"
import { isPlainModeActive } from "@/lib/collab-mode"
// import { CanvasControls } from "./canvas/canvas-controls" // Removed per user request
import { EnhancedControlPanelV2 } from "./canvas/enhanced-control-panel-v2"
import { EnhancedMinimap } from "./canvas/enhanced-minimap"
import { ConnectionLines } from "./canvas/connection-lines"
import { panToPanel } from "@/lib/canvas/pan-animations"
import { Settings } from "lucide-react"
import { AddComponentMenu } from "./canvas/add-component-menu"
import { ComponentPanel } from "./canvas/component-panel"
import { StickyNoteOverlayPanel } from "./canvas/sticky-note-overlay-panel"
import { CanvasItem, createPanelItem, createComponentItem, isPanel, isComponent } from "@/types/canvas-items"
// IsolationDebugPanel now integrated into EnhancedControlPanelV2
import { 
  loadStateFromStorage, 
  saveStateToStorage, 
  CANVAS_STORAGE_DEBOUNCE 
} from "@/lib/canvas/canvas-storage"
import { getPlainProvider } from "@/lib/provider-switcher"
import { getWheelZoomMultiplier } from "@/lib/canvas/zoom-utils"

const PENDING_SAVE_MAX_AGE_MS = 5 * 60 * 1000

interface ModernAnnotationCanvasProps {
  noteId: string
  isNotesExplorerOpen?: boolean
  onCanvasStateChange?: (state: { zoom: number; showConnections: boolean }) => void
  showAddComponentMenu?: boolean
  onToggleAddComponentMenu?: () => void
}

interface CanvasImperativeHandle {
  zoomIn: () => void
  zoomOut: () => void
  resetView: () => void
  toggleConnections: () => void
  centerOnPanel: (panelId: string) => void
}

// Default viewport settings
const defaultViewport = {
  zoom: 1,
  translateX: -1000,
  translateY: -1200,
  showConnections: true,
}

// Create default canvas state
const createDefaultCanvasState = () => ({
  ...defaultViewport,
  isDragging: false,
  lastMouseX: 0,
  lastMouseY: 0,
})

// Create default canvas items with main panel
const createDefaultCanvasItems = (): CanvasItem[] => [
  createPanelItem("main", { x: 2000, y: 1500 }, "main"),
]

// Ensure main panel always exists in items array
const ensureMainPanel = (items: CanvasItem[]): CanvasItem[] => {
  const hasMain = items.some((item) => item.itemType === "panel" && item.panelId === "main")
  return hasMain ? items : [...items, createPanelItem("main", { x: 2000, y: 1500 }, "main")]
}

const ModernAnnotationCanvas = forwardRef<CanvasImperativeHandle, ModernAnnotationCanvasProps>(({ 
  noteId, 
  isNotesExplorerOpen = false,
  onCanvasStateChange,
  showAddComponentMenu: externalShowAddComponentMenu,
  onToggleAddComponentMenu
}, ref) => {
  const [canvasState, setCanvasState] = useState(createDefaultCanvasState)

  // Unified canvas items state
  const [canvasItems, setCanvasItems] = useState<CanvasItem[]>(createDefaultCanvasItems)
  const [isStateLoaded, setIsStateLoaded] = useState(false)
  const autoSaveTimerRef = useRef<number | null>(null)
  const [showControlPanel, setShowControlPanel] = useState(false)
  const [internalShowAddComponentMenu, setInternalShowAddComponentMenu] = useState(false)
  
  // Use external control if provided, otherwise use internal state
  const showAddComponentMenu = externalShowAddComponentMenu !== undefined ? externalShowAddComponentMenu : internalShowAddComponentMenu
  const toggleAddComponentMenu = onToggleAddComponentMenu || (() => setInternalShowAddComponentMenu(!internalShowAddComponentMenu))
  const [stickyOverlayEl, setStickyOverlayEl] = useState<HTMLElement | null>(null)
  // Selection guards to prevent text highlighting during canvas drag
  const selectionGuardsRef = useRef<{
    onSelectStart: (e: Event) => void;
    onDragStart: (e: Event) => void;
    prevUserSelect: string;
  } | null>(null)

  const enableSelectionGuards = useCallback(() => {
    if (typeof document === 'undefined') return
    if (selectionGuardsRef.current) return
    const onSelectStart = (e: Event) => { e.preventDefault() }
    const onDragStart = (e: Event) => { e.preventDefault() }
    selectionGuardsRef.current = { onSelectStart, onDragStart, prevUserSelect: document.body.style.userSelect }
    document.documentElement.classList.add('dragging-no-select')
    document.body.style.userSelect = 'none'
    document.addEventListener('selectstart', onSelectStart, true)
    document.addEventListener('dragstart', onDragStart, true)
    try { window.getSelection()?.removeAllRanges?.() } catch {}
  }, [])

  const disableSelectionGuards = useCallback(() => {
    if (typeof document === 'undefined') return
    const g = selectionGuardsRef.current
    if (!g) return
    document.removeEventListener('selectstart', g.onSelectStart, true)
    document.removeEventListener('dragstart', g.onDragStart, true)
    document.documentElement.classList.remove('dragging-no-select')
    document.body.style.userSelect = g.prevUserSelect || ''
    selectionGuardsRef.current = null
  }, [])

  useEffect(() => {
    // Note: We no longer clear editor docs when switching notes
    // The composite key system (noteId-panelId) already isolates docs between notes
    // This allows content to load immediately when switching back to a previously viewed note
    
    // Check if we're in plain mode (explicit flag; avoids provider init race)
    const isPlainMode = isPlainModeActive()
    
    if (!isPlainMode) {
      // Initialize collaboration provider with YJS persistence
      const provider = UnifiedProvider.getInstance()
      
      // Set the current note context
      provider.setCurrentNote(noteId)
      
      // Check if this is a new note (check localStorage for existing data)
      const existingData = localStorage.getItem(`note-data-${noteId}`)
      const isNewNote = !existingData
      
      console.log('[AnnotationCanvas] Initializing note:', {
        noteId,
        hasExistingData: !!existingData,
        isNewNote
      })
      
      // Define default data for new notes
      const defaultData = {
        'main': {
          title: 'New Document',
          type: 'main',
          content: '', // Empty content for new documents
          branches: [],
          position: { x: 2000, y: 1500 },
          isEditable: true,
          // Mark as new to force edit mode
          isNew: isNewNote
        }
      }
      
      console.log('[AnnotationCanvas] Default data for main panel:', defaultData.main)
      
      // Initialize with defaults - the provider will merge with existing data if any
      // For new notes, this sets empty content
      // For existing notes, this preserves their content
      provider.initializeDefaultData(noteId, defaultData)
    }

    return () => {
      // Don't destroy note when switching - only cleanup when truly unmounting
      // The provider's smart cache management will handle memory efficiently
      // This allows content to persist when switching between notes
    }
  }, [noteId])

  // Load canvas state when note changes
  useEffect(() => {
    setIsStateLoaded(false)
    setCanvasState(createDefaultCanvasState())
    setCanvasItems(createDefaultCanvasItems())

    // Clear any pending auto-save timer
    if (autoSaveTimerRef.current) {
      window.clearTimeout(autoSaveTimerRef.current)
      autoSaveTimerRef.current = null
    }

    // Attempt to load saved state
    const snapshot = loadStateFromStorage(noteId)
    if (!snapshot) {
      console.table([
        {
          Action: 'No Saved State',
          NoteId: noteId,
          Time: new Date().toLocaleTimeString(),
        },
      ])
      setIsStateLoaded(true)
      return
    }

    const plainProvider = getPlainProvider()
    let providerVersion = 0
    let providerHasContent = false
    if (plainProvider) {
      try {
        providerVersion = plainProvider.getDocumentVersion(noteId, 'main')
        const existing = plainProvider.getDocument(noteId, 'main')
        providerHasContent = existing ? !plainProvider.isEmptyContent(existing) : false
      } catch (err) {
        console.warn('[AnnotationCanvas] Failed to inspect provider cache during snapshot load:', err)
      }
    }

    let pendingSnapshotBlocked = false
    if (plainProvider && typeof window !== 'undefined') {
      try {
        const pendingKey = `pending_save_${noteId}_main`
        const pendingData = window.localStorage.getItem(pendingKey)
        if (pendingData) {
          const parsed = JSON.parse(pendingData) as { timestamp?: number; version?: number }
          const timestamp = typeof parsed.timestamp === 'number' ? parsed.timestamp : 0
          if (timestamp) {
            const age = Date.now() - timestamp
            if (age < PENDING_SAVE_MAX_AGE_MS) {
              const pendingVersion = typeof parsed.version === 'number' ? parsed.version : 0
              if (pendingVersion > providerVersion) {
                pendingSnapshotBlocked = true
              } else {
                window.localStorage.removeItem(pendingKey)
              }
            } else {
              window.localStorage.removeItem(pendingKey)
            }
          } else {
            window.localStorage.removeItem(pendingKey)
          }
        }
      } catch (error) {
        console.warn('[AnnotationCanvas] Failed to inspect pending backup for snapshot guard:', error)
      }
    }

    if (pendingSnapshotBlocked) {
      console.log('[AnnotationCanvas] Deferring snapshot restore; pending save has newer content', {
        noteId,
        providerVersion,
      })
      setIsStateLoaded(true)
      return
    }

    if (plainProvider && providerVersion > 0 && providerHasContent) {
      console.log('[AnnotationCanvas] Skipping snapshot restore: provider already has fresh content', {
        providerVersion,
        savedAt: snapshot.savedAt,
        items: snapshot.items.length,
      })
      setIsStateLoaded(true)
      return
    }

    console.table([
      {
        Action: 'State Loaded',
        NoteId: noteId,
        Items: snapshot.items.length,
        SavedAt: new Date(snapshot.savedAt).toLocaleTimeString(),
        ProviderVersion: providerVersion,
        ProviderHasContent: providerHasContent,
      },
    ])

    // Apply viewport settings
    const viewport = snapshot.viewport
    setCanvasState((prev) => ({
      ...prev,
      zoom: viewport.zoom ?? prev.zoom,
      translateX: viewport.translateX ?? prev.translateX,
      translateY: viewport.translateY ?? prev.translateY,
      showConnections: viewport.showConnections ?? prev.showConnections,
    }))

    // Restore canvas items (ensuring main panel exists)
    const restored = ensureMainPanel(
      snapshot.items.map((item) => ({
        ...item,
        itemType: item.itemType,
      })) as CanvasItem[]
    )
    setCanvasItems(restored)
    setIsStateLoaded(true)
  }, [noteId])

  // Cleanup auto-save timer on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimerRef.current) {
        window.clearTimeout(autoSaveTimerRef.current)
        autoSaveTimerRef.current = null
      }
    }
  }, [])

  const handleCanvasMouseDown = (e: React.MouseEvent) => {
    // Only start dragging if clicking on canvas background
    // Don't drag if clicking on a panel or component
    const target = e.target instanceof Element ? e.target : null
    if (target && (target.closest('.panel') || target.closest('[data-component-panel]'))) return
    
    setCanvasState(prev => ({
      ...prev,
      isDragging: true,
      lastMouseX: e.clientX,
      lastMouseY: e.clientY
    }))
    
    enableSelectionGuards()
    document.body.style.userSelect = 'none'
    try { window.getSelection()?.removeAllRanges?.() } catch {}
    e.preventDefault()
  }

  const handleCanvasMouseMove = (e: MouseEvent) => {
    if (!canvasState.isDragging) return
    
    const deltaX = e.clientX - canvasState.lastMouseX
    const deltaY = e.clientY - canvasState.lastMouseY

    setCanvasState(prev => ({
      ...prev,
      translateX: prev.translateX + deltaX,
      translateY: prev.translateY + deltaY,
      lastMouseX: e.clientX,
      lastMouseY: e.clientY
    }))
  }

  const handleCanvasMouseUp = () => {
    setCanvasState(prev => ({ ...prev, isDragging: false }))
    document.body.style.userSelect = ''
    disableSelectionGuards()
  }

  const handleWheel = (e: React.WheelEvent) => {
    // Only zoom if Shift key is held down
    if (!e.shiftKey) {
      // Allow normal scrolling when Shift is not pressed
      return
    }
    
    e.preventDefault()

    const multiplier = getWheelZoomMultiplier(e.nativeEvent)
    const newZoom = Math.max(0.3, Math.min(2, canvasState.zoom * multiplier))
    
    const rect = e.currentTarget.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top
    
    const zoomChange = newZoom / canvasState.zoom
    
    setCanvasState(prev => ({
      ...prev,
      zoom: newZoom,
      translateX: mouseX - (mouseX - prev.translateX) * zoomChange,
      translateY: mouseY - (mouseY - prev.translateY) * zoomChange
    }))
  }

  useEffect(() => {
    document.addEventListener('mousemove', handleCanvasMouseMove)
    document.addEventListener('mouseup', handleCanvasMouseUp)
    
    return () => {
      document.removeEventListener('mousemove', handleCanvasMouseMove)
      document.removeEventListener('mouseup', handleCanvasMouseUp)
    }
  }, [canvasState.isDragging, canvasState.lastMouseX, canvasState.lastMouseY])

  useEffect(() => {
    if (typeof document === 'undefined') return

    const overlay = document.createElement('div')
    overlay.id = 'sticky-note-overlay-root'
    overlay.style.position = 'fixed'
    overlay.style.inset = '0'
    overlay.style.pointerEvents = 'none'
    overlay.style.zIndex = '12000'
    overlay.style.display = 'block'

    document.body.appendChild(overlay)
    setStickyOverlayEl(overlay)

    return () => {
      document.body.removeChild(overlay)
      setStickyOverlayEl(null)
    }
  }, [])

  const handlePanelClose = (panelId: string) => {
    setCanvasItems(prev => prev.filter(item => !(isPanel(item) && item.panelId === panelId)))
  }

  const handleCreatePanel = (panelId: string, parentPanelId?: string, parentPosition?: { x: number, y: number }) => {
    console.log('[AnnotationCanvas] Creating panel:', panelId, 'with parent:', parentPanelId, 'at position:', parentPosition)
    
    // Check if we're in plain mode
    const isPlainMode = isPlainModeActive()
    
    setCanvasItems(prev => {
      // Only add if not already present
      if (prev.some(item => isPanel(item) && item.panelId === panelId)) {
        return prev
      }
      
      if (isPlainMode) {
        // Plain mode: Check if panel data exists
        // Note: We'll need to get dataStore from context provider
        console.log('[Plain mode] Creating panel:', panelId)
        
        // If parent position is provided, update the dataStore
        if (parentPosition && (window as any).canvasDataStore) {
          const dataStore = (window as any).canvasDataStore
          const panelData = dataStore.get(panelId)
          if (panelData) {
            // Update position to be beside parent
            panelData.position = parentPosition
            dataStore.set(panelId, panelData)
          }
        }
      } else {
        // Ensure the provider knows about the current note
        const provider = UnifiedProvider.getInstance()
        provider.setCurrentNote(noteId)
        
        // Get the panel data from YJS
        const branchesMap = provider.getBranchesMap()
        const panelData = branchesMap.get(panelId)
        
        if (!panelData) {
          console.warn(`No data found for panel ${panelId}`)
          return prev
        }
        
        // If parent position is provided, update the position
        if (parentPosition && panelData) {
          panelData.position = parentPosition
          branchesMap.set(panelId, panelData)
        }
      }
      
      // After adding panel, smoothly pan to it
      setTimeout(() => {
        const getPanelPosition = (id: string) => {
          if (isPlainMode) {
            // In plain mode, use dataStore position
            const dataStore = (window as any).canvasDataStore
            const panel = dataStore?.get(id)
            return panel?.position || { x: 2000, y: 1500 }
          } else {
            const panel = UnifiedProvider.getInstance().getBranchesMap().get(id)
            return panel?.position || null
          }
        }
        
        panToPanel(
          panelId,
          getPanelPosition,
          canvasState,
          (updates) => setCanvasState(prev => ({ ...prev, ...updates })),
          {
            duration: 600,
            callback: () => {
              console.log('[AnnotationCanvas] Finished panning to panel:', panelId)
            }
          }
        )
      }, 100) // Small delay to ensure panel is rendered
      
      // Determine panel type based on panelId
      const panelType = panelId === 'main' ? 'main' : 
                       panelId.includes('explore') ? 'explore' : 
                       panelId.includes('promote') ? 'promote' : 'note'
      
      return [...prev, createPanelItem(panelId, { x: 2000, y: 1500 }, panelType)]
    })
  }
  
  // Handle adding components
  const handleAddComponent = (type: string, position?: { x: number; y: number }) => {
    // Calculate position - center of viewport in world coordinates
    // The canvas translate is the offset, so we need to negate it to get world position
    const viewportCenterX = window.innerWidth / 2
    const viewportCenterY = window.innerHeight / 2
    
    // Convert from screen space to world space
    // World position = (Screen position - Canvas translate) / zoom
    const worldX = (-canvasState.translateX + viewportCenterX) / canvasState.zoom
    const worldY = (-canvasState.translateY + viewportCenterY) / canvasState.zoom
    
    // Center the component (component is ~350px wide, ~300px tall)
    const finalPosition = position || {
      x: worldX - 175,
      y: worldY - 150
    }

    const stickyScreenPosition = position || {
      x: viewportCenterX - 175,
      y: viewportCenterY - 150
    }

    const newComponent = createComponentItem(
      type as 'calculator' | 'timer' | 'sticky-note' | 'dragtest' | 'perftest',
      type === 'sticky-note' ? stickyScreenPosition : finalPosition
    )
    
    setCanvasItems(prev => [...prev, newComponent])
  }
  
  const handleComponentClose = (id: string) => {
    setCanvasItems(prev => prev.filter(item => item.id !== id))
  }
  
  const handleComponentPositionChange = (id: string, position: { x: number; y: number }) => {
    setCanvasItems(prev => prev.map(item => 
      item.id === id ? { ...item, position } : item
    ))
  }

  const componentItems = useMemo(() => canvasItems.filter(isComponent), [canvasItems])
  const stickyNoteItems = useMemo(
    () => componentItems.filter(item => item.componentType === 'sticky-note'),
    [componentItems]
  )
  const floatingComponents = useMemo(
    () => componentItems.filter(item => item.componentType !== 'sticky-note'),
    [componentItems]
  )

  // Subscribe to panel creation events
  useEffect(() => {
    const handlePanelEvent = (event: CustomEvent) => {
      if (event.detail?.panelId) {
        handleCreatePanel(
          event.detail.panelId, 
          event.detail.parentPanelId, 
          event.detail.parentPosition
        )
      }
    }
    
    const handlePreviewPanelEvent = (event: CustomEvent) => {
      if (event.detail?.panelId) {
        // Create a temporary preview panel
        // For now, just create a regular panel - you can enhance this later
        // to show it in a special preview mode (e.g., semi-transparent, different position)
        handleCreatePanel(
          event.detail.panelId, 
          event.detail.parentPanelId, 
          event.detail.parentPosition
        )
      }
    }
    
    const handleRemovePreviewPanelEvent = (event: CustomEvent) => {
      if (event.detail?.panelId) {
        // Remove the preview panel
        handlePanelClose(event.detail.panelId)
      }
    }

    window.addEventListener('create-panel' as any, handlePanelEvent)
    window.addEventListener('preview-panel' as any, handlePreviewPanelEvent)
    window.addEventListener('remove-preview-panel' as any, handleRemovePreviewPanelEvent)
    
    return () => {
      window.removeEventListener('create-panel' as any, handlePanelEvent)
      window.removeEventListener('preview-panel' as any, handlePreviewPanelEvent)
      window.removeEventListener('remove-preview-panel' as any, handleRemovePreviewPanelEvent)
    }
  }, [noteId]) // Add noteId dependency to ensure we're using the correct note

  // Create viewport snapshot for auto-save
  const viewportSnapshot = useMemo(
    () => ({
      zoom: canvasState.zoom,
      translateX: canvasState.translateX,
      translateY: canvasState.translateY,
      showConnections: canvasState.showConnections,
    }),
    [canvasState.zoom, canvasState.translateX, canvasState.translateY, canvasState.showConnections]
  )

  // Auto-save canvas state with debouncing
  useEffect(() => {
    if (!isStateLoaded) return

    // Clear existing timer
    if (autoSaveTimerRef.current) {
      window.clearTimeout(autoSaveTimerRef.current)
    }

    // Set new timer with proper debounce
    autoSaveTimerRef.current = window.setTimeout(() => {
      const success = saveStateToStorage(noteId, { 
        viewport: viewportSnapshot, 
        items: canvasItems 
      })
      
      if (!success) {
        console.warn('[AnnotationCanvas] Failed to save canvas state')
      }
      
      autoSaveTimerRef.current = null
    }, CANVAS_STORAGE_DEBOUNCE)

    // Cleanup on unmount or dependency change
    return () => {
      if (autoSaveTimerRef.current) {
        window.clearTimeout(autoSaveTimerRef.current)
        autoSaveTimerRef.current = null
      }
    }
  }, [noteId, viewportSnapshot, canvasItems, isStateLoaded])

  // Expose methods via ref
  useImperativeHandle(ref, () => ({
    zoomIn: () => {
      setCanvasState(prev => {
        const newZoom = Math.min(prev.zoom * 1.1, 2)
        const newState = { ...prev, zoom: newZoom }
        onCanvasStateChange?.({ zoom: newZoom, showConnections: prev.showConnections })
        return newState
      })
    },
    zoomOut: () => {
      setCanvasState(prev => {
        const newZoom = Math.max(prev.zoom * 0.9, 0.3)
        const newState = { ...prev, zoom: newZoom }
        onCanvasStateChange?.({ zoom: newZoom, showConnections: prev.showConnections })
        return newState
      })
    },
    resetView: () => {
      setCanvasState(prev => {
        const newState = { ...prev, zoom: 1, translateX: -1000, translateY: -1200 }
        onCanvasStateChange?.({ zoom: 1, showConnections: prev.showConnections })
        return newState
      })
    },
    toggleConnections: () => {
      setCanvasState(prev => {
        const newShowConnections = !prev.showConnections
        const newState = { ...prev, showConnections: newShowConnections }
        onCanvasStateChange?.({ zoom: prev.zoom, showConnections: newShowConnections })
        return newState
      })
    },
    centerOnPanel: (panelId: string) => {
      const getPanelPosition = (id: string): { x: number; y: number } | null => {
        // 1) Try collaboration map if not in plain mode
        const provider = UnifiedProvider.getInstance()
        if (!isPlainModeActive()) {
          const branchesMap = provider.getBranchesMap()
          const branch = branchesMap?.get(id)
          if (branch?.position) return branch.position
        }
        
        // 2) DOM lookup (plain mode)
        const el = document.querySelector(`[data-panel-id="${id}"]`) as HTMLElement | null
        if (el) {
          const rect = el.getBoundingClientRect()
          const container = document.getElementById('canvas-container')
          const containerRect = container?.getBoundingClientRect()
          
          // Get the center of the panel relative to the container
          const screenX = (rect.left + rect.width / 2) - (containerRect?.left ?? 0)
          const screenY = (rect.top + rect.height / 2) - (containerRect?.top ?? 0)
          
          // Convert screen coordinates to world coordinates
          // The panel's world position when canvas has translate(tx, ty) scale(zoom):
          // screenPos = (worldPos + translate) * zoom
          // Therefore: worldPos = screenPos / zoom - translate
          const worldX = (screenX / canvasState.zoom) - canvasState.translateX
          const worldY = (screenY / canvasState.zoom) - canvasState.translateY
          
          return { x: worldX, y: worldY }
        }
        
        // 3) Don't use fallback immediately - return null to trigger retry
        return null
      }

      console.log(`[Canvas] Attempting to center on panel '${panelId}'`)
      
      // Retry mechanism: wait for panel to be in DOM
      let retryCount = 0
      const maxRetries = 10
      const retryDelay = 100 // ms
      
      const attemptCenter = () => {
        const position = getPanelPosition(panelId)
        
        if (position) {
          console.log(`[Canvas] Panel '${panelId}' found, centering...`)
          panToPanel(
            panelId,
            () => position, // Direct position since we already have it
            { x: canvasState.translateX, y: canvasState.translateY, zoom: canvasState.zoom },
            (viewportState) => setCanvasState(prev => ({
              ...prev,
              translateX: viewportState.x ?? prev.translateX,
              translateY: viewportState.y ?? prev.translateY,
              zoom: viewportState.zoom ?? prev.zoom,
            })),
            { duration: 400 }
          )
        } else if (retryCount < maxRetries) {
          retryCount++
          console.log(`[Canvas] Panel '${panelId}' not found, retry ${retryCount}/${maxRetries}`)
          setTimeout(attemptCenter, retryDelay)
        } else {
          // Final fallback: calculate viewport-centered position
          console.warn(`[Canvas] Panel '${panelId}' not found after ${maxRetries} retries, using viewport center`)
          
          // Calculate position to place panel at viewport center
          const viewportWidth = window.innerWidth
          const viewportHeight = window.innerHeight
          const panelWidth = 800
          const panelHeight = 600
          
          // Calculate world position that would appear centered
          const centerWorldX = (viewportWidth / 2 - panelWidth / 2) / canvasState.zoom - canvasState.translateX
          const centerWorldY = (viewportHeight / 2 - panelHeight / 2) / canvasState.zoom - canvasState.translateY
          
          // For new panels, we actually want them to appear centered
          // So we don't pan, we just note where they should be created
          console.log(`[Canvas] Panel should be created at world position (${centerWorldX}, ${centerWorldY}) to appear centered`)
        }
      }
      
      attemptCenter()
    }
  }), [onCanvasStateChange, canvasState])

  return (
    <IsolationProvider config={{ enabled: false }}>
    <CanvasProvider noteId={noteId}>
      <div className="w-screen h-screen overflow-hidden bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500">
        {/* Demo Header */}
        <div className="fixed top-0 left-0 right-0 bg-black/90 text-white p-3 text-xs font-medium z-[1000] border-b border-white/10 flex items-center justify-between">
          <span>ðŸš€ Yjs-Ready Unified Knowledge Canvas â€¢ Collaborative-Ready Architecture with Tiptap Editor</span>
          <span className="text-gray-300 flex items-center gap-2">
            <span className="text-yellow-400">ðŸ’¡</span>
            Hold <kbd className="px-2 py-0.5 bg-gray-700 rounded text-xs font-bold">Shift</kbd> + Scroll to zoom
          </span>
        </div>

        {/* Canvas Controls - Removed per user request */}
        {/* {!isNotesExplorerOpen && (
          <CanvasControls 
            zoom={canvasState.zoom}
            onZoomIn={() => setCanvasState(prev => ({ ...prev, zoom: Math.min(prev.zoom * 1.1, 2) }))}
            onZoomOut={() => setCanvasState(prev => ({ ...prev, zoom: Math.max(prev.zoom * 0.9, 0.3) }))}
            onResetView={() => setCanvasState(prev => ({ ...prev, zoom: 1, translateX: -1000, translateY: -1200 }))}
            onToggleConnections={() => setCanvasState(prev => ({ ...prev, showConnections: !prev.showConnections }))}
            showConnections={canvasState.showConnections}
          />
        )} */}
        
        {/* Control Panel Toggle Button - Always visible */}
        <button
          onClick={() => setShowControlPanel(!showControlPanel)}
          className="fixed top-16 right-4 z-[900] p-3 bg-gray-900 hover:bg-gray-800 text-white rounded-lg shadow-lg transition-all duration-200 hover:scale-110"
          title="Toggle Control Panel"
        >
          <Settings size={20} />
        </button>
        
        {/* Add Components Button - Moved to sidebar */}

        {/* Enhanced Control Panel V2 - Wider with always-visible metrics */}
        <EnhancedControlPanelV2 
          visible={showControlPanel}
          onClose={() => setShowControlPanel(false)}
          canvasItems={canvasItems}
          onAddComponent={handleAddComponent}
        />
        
        {/* Isolation Debug Panel - Only in development */}
        {/* Isolation Debug now integrated into Control Panel */}

        {/* Enhanced Minimap */}
        <EnhancedMinimap 
          canvasItems={canvasItems}
          canvasState={canvasState}
          onNavigate={(x, y) => setCanvasState(prev => ({ ...prev, translateX: x, translateY: y }))}
        />
        
        {/* Add Components Menu */}
        <AddComponentMenu 
          visible={showAddComponentMenu}
          onClose={() => {
            if (onToggleAddComponentMenu && externalShowAddComponentMenu) {
              onToggleAddComponentMenu()
            } else {
              setInternalShowAddComponentMenu(false)
            }
          }}
          onAddComponent={handleAddComponent}
        />

        {/* Canvas Container */}
        <div 
          id="canvas-container"
          className={`relative w-full h-full cursor-grab overflow-hidden ${canvasState.isDragging ? 'cursor-grabbing' : ''}`}
          style={{
            // Isolate canvas painting to avoid cross-layer re-rasterization while dragging
            contain: 'layout paint',
            isolation: 'isolate',
            // Stabilize font rendering during transforms
            WebkitFontSmoothing: 'antialiased',
            textRendering: 'optimizeLegibility',
          }}
          onMouseDown={handleCanvasMouseDown}
          onWheel={handleWheel}
          onContextMenu={(e) => e.preventDefault()}
        >
          {/* Infinite Canvas */}
          <div 
            id="infinite-canvas"
            style={{
              position: 'absolute',
              // Use translate3d without rounding for smooth motion (infinite-canvas approach)
              transform: `translate3d(${canvasState.translateX}px, ${canvasState.translateY}px, 0) scale(${canvasState.zoom})`,
              transformOrigin: '0 0',
              // Critical: NO transition during drag to prevent text blinking
              transition: canvasState.isDragging ? 'none' : 'transform 0.3s ease',
              // Optimize GPU layers only during active drag
              willChange: canvasState.isDragging ? 'transform' : 'auto',
              // Force stable GPU layer composition
              backfaceVisibility: 'hidden' as const,
              transformStyle: 'preserve-3d' as const,
            }}
          >
            {/* Connection Lines */}
            {canvasState.showConnections && (
              <ConnectionLines canvasItems={canvasItems} />
            )}

            {/* Panels */}
            <PanelsRenderer
              noteId={noteId}
              canvasItems={canvasItems}
              onClose={handlePanelClose}
            />
            
            {/* Component Panels */}
            {floatingComponents.map(component => (
              <ComponentPanel
                key={component.id}
                id={component.id}
                type={component.componentType!}
                position={component.position}
                onClose={handleComponentClose}
                onPositionChange={handleComponentPositionChange}
              />
            ))}
          </div>
        </div>

        {stickyOverlayEl && stickyNoteItems.length > 0 && createPortal(
          stickyNoteItems.map(component => (
            <StickyNoteOverlayPanel
              key={component.id}
              id={component.id}
              position={component.position}
              onClose={handleComponentClose}
              onPositionChange={handleComponentPositionChange}
            />
          )),
          stickyOverlayEl
        )}

        {/* Annotation Toolbar - controlled by Actions button */}
        <AnnotationToolbar />

      </div>
    </CanvasProvider>
    </IsolationProvider>
  )
})

ModernAnnotationCanvas.displayName = 'ModernAnnotationCanvas'

// Renders panels using plain dataStore in plain mode, Yjs map otherwise
function PanelsRenderer({
  noteId,
  canvasItems,
  onClose,
}: {
  noteId: string
  canvasItems: CanvasItem[]
  onClose: (id: string) => void
}) {
  const { dataStore } = useCanvas()
  const isPlainMode = isPlainModeActive()
  
  // Yjs access only when not in plain mode
  const provider = UnifiedProvider.getInstance()
  if (!isPlainMode) {
    provider.setCurrentNote(noteId)
  }
  const branchesMap = !isPlainMode ? provider.getBranchesMap() : null
  
  const panels = canvasItems.filter(isPanel)
  
  return (
    <>
      {panels.map((panel) => {
        const panelId = panel.panelId!
        const branch = isPlainMode ? dataStore.get(panelId) : branchesMap?.get(panelId)
        if (!branch) {
          console.warn(`[PanelsRenderer] Branch ${panelId} not found in ${isPlainMode ? 'plain' : 'yjs'} store`)
          return null
        }
        
        console.log(`[PanelsRenderer] Rendering panel ${panelId}:`, {
          hasContent: !!branch.content,
          contentLength: typeof branch.content === 'string' ? branch.content.length : 'N/A',
          isNew: branch.isNew,
          isEditable: branch.isEditable
        })
        
        const position = branch.position || { x: 2000, y: 1500 }
        return (
          <CanvasPanel
            key={panelId}
            panelId={panelId}
            branch={branch}
            position={position}
            noteId={noteId}
            onClose={() => onClose(panelId)}
          />
        )
      })}
    </>
  )
}

export default ModernAnnotationCanvas 
