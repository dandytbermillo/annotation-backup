"use client"

import { useEffect, useState, forwardRef, useImperativeHandle, useRef, useCallback, useMemo } from "react"
import { createPortal } from "react-dom"
import { flushSync } from "react-dom"
import { CanvasProvider, useCanvas } from "./canvas/canvas-context"
import type { DataStore } from "@/lib/data-store"
import { IsolationProvider } from "@/lib/isolation/context"
import { CanvasPanel } from "./canvas/canvas-panel"
import { AnnotationToolbar } from "./canvas/annotation-toolbar"
import { UnifiedProvider } from "@/lib/provider-switcher"
import { isPlainModeActive } from "@/lib/collab-mode"
import { useLayer } from "./canvas/layer-provider"
import { PopupStateAdapter } from "@/lib/adapters/popup-state-adapter"
// import { CanvasControls } from "./canvas/canvas-controls" // Removed per user request
import { EnhancedControlPanelV2 } from "./canvas/enhanced-control-panel-v2"
import { EnhancedMinimap } from "./canvas/enhanced-minimap"
import { WidgetStudioConnections } from "./canvas/widget-studio-connections"
import { Settings } from "lucide-react"
import { AddComponentMenu } from "./canvas/add-component-menu"
import { ComponentPanel } from "./canvas/component-panel"
import { StickyNoteOverlayPanel } from "./canvas/sticky-note-overlay-panel"
import { CanvasItem, createPanelItem, createComponentItem, isPanel, isComponent, PanelType } from "@/types/canvas-items"
import { ensurePanelKey, parsePanelKey } from "@/lib/canvas/composite-id"
// IsolationDebugPanel now integrated into EnhancedControlPanelV2
import { loadStateFromStorage } from "@/lib/canvas/canvas-storage"
import { getPlainProvider } from "@/lib/provider-switcher"
import { getWheelZoomMultiplier } from "@/lib/canvas/zoom-utils"
import { worldToScreen, screenToWorld } from "@/lib/canvas/coordinate-utils"
import { debugLog, isDebugEnabled } from "@/lib/utils/debug-logger"
import { useCanvasHydration } from "@/lib/hooks/use-canvas-hydration"
import { useCameraPersistence } from "@/lib/hooks/use-camera-persistence"
import { usePanelPersistence } from "@/lib/hooks/use-panel-persistence"
import { useCanvasTransform } from "@/lib/hooks/annotation/use-canvas-transform"
import { useCanvasItems } from "@/lib/hooks/annotation/use-canvas-items"
import { useCanvasNoteSync } from "@/lib/hooks/annotation/use-canvas-note-sync"
import { useCanvasAutosave } from "@/lib/hooks/annotation/use-canvas-autosave"
import { useCanvasSnapshot } from "@/lib/hooks/annotation/use-canvas-snapshot"
import { useHydrationPanelBuilder, useHydrationPanelMerge, useHydrationDispatcher, useHydrationNoteTracker } from "@/lib/hooks/annotation/use-hydration-panel-builder"
import { LayerManagerProvider, useLayerManager } from "@/lib/hooks/use-layer-manager"
import { useCanvasWorkspace, SHARED_WORKSPACE_ID, type OpenWorkspaceNote } from "./canvas/canvas-workspace-context"
import { useCameraUserId } from "@/lib/hooks/use-camera-scope"
import { dedupeCanvasItems } from "@/lib/canvas/dedupe-canvas-items"
import { scheduleCanvasSnapshotDedupeMigration } from "@/lib/migrations/dedupe-snapshots-v1"
import { Z_INDEX } from "@/lib/constants/z-index"
import {
  createDefaultCanvasState,
  createDefaultCanvasItems,
  defaultViewport,
  ensureMainPanel,
  getDefaultMainPosition,
  isDefaultMainPosition,
  LEGACY_DEFAULT_MAIN_POSITION,
} from "@/lib/canvas/canvas-defaults"
const PENDING_SAVE_MAX_AGE_MS = 5 * 60 * 1000

// Type alias for hydration hook result
type HydrationResult = ReturnType<typeof useCanvasHydration>

interface ModernAnnotationCanvasProps {
  noteIds: string[]
  primaryNoteId: string | null
  freshNoteSeeds?: Record<string, { x: number; y: number }>
  onConsumeFreshNoteSeed?: (noteId: string) => void
  isNotesExplorerOpen?: boolean
  onCanvasStateChange?: (state: {
    zoom: number
    showConnections: boolean
    translateX: number
    translateY: number
    lastInteraction?: { x: number; y: number } | null
  }) => void
  mainOnlyNoteIds?: string[]
  onMainOnlyLayoutHandled?: (noteId: string) => void
  showAddComponentMenu?: boolean
  onToggleAddComponentMenu?: () => void
  onRegisterActiveEditor?: (editorRef: any, panelId: string) => void
  onSnapshotLoadComplete?: () => void  // Called after snapshot load + centering completes
  skipSnapshotForNote?: string | null
  onSnapshotSettled?: (noteId: string) => void
  children?: React.ReactNode  // Toolbar and other components rendered inside CanvasProvider
  freshNoteIds?: string[]
  onFreshNoteHydrated?: (noteId: string) => void
}

interface CanvasImperativeHandle {
  zoomIn: () => void
  zoomOut: () => void
  resetView: () => void
  panBy: (deltaX: number, deltaY: number) => void
  toggleConnections: () => void
  centerOnPanel: (panelId: string) => void
  addComponent: (type: string, position?: { x: number; y: number }) => void
}

interface NoteHydratorProps {
  noteId: string
  userId?: string
  dataStore: DataStore
  branchesMap: Map<string, any>
  layerManager: ReturnType<typeof useLayerManager>['manager']
  onHydration: (noteId: string, status: HydrationResult) => void
  enabled?: boolean
  workspaceVersion?: number | null
}

function NoteHydrator({
  noteId,
  userId,
  dataStore,
  branchesMap,
  layerManager,
  onHydration,
  enabled = true,
  workspaceVersion,
}: NoteHydratorProps) {
  const status = useCanvasHydration({
    noteId,
    userId,
    dataStore,
    branchesMap,
    layerManager,
    enabled,
    workspaceVersion: workspaceVersion ?? undefined,
  })

  useEffect(() => {
    onHydration(noteId, status)
  }, [noteId, status, onHydration])

  return null
}


// helper functions moved to lib/canvas/canvas-defaults.ts

const ModernAnnotationCanvasInner = forwardRef<CanvasImperativeHandle, ModernAnnotationCanvasProps>(({ 
  noteIds,
  primaryNoteId,
  freshNoteSeeds = {},
  onConsumeFreshNoteSeed,
  isNotesExplorerOpen = false,
  onCanvasStateChange,
  mainOnlyNoteIds = [],
  onMainOnlyLayoutHandled,
  showAddComponentMenu: externalShowAddComponentMenu,
  onToggleAddComponentMenu,
  onSnapshotLoadComplete,
  skipSnapshotForNote,
  onSnapshotSettled,
  freshNoteIds = [],
  onFreshNoteHydrated
}, ref) => {
  const noteId = primaryNoteId ?? noteIds[0] ?? ""
  const hasNotes = noteIds.length > 0 && noteId.length > 0

  if (!hasNotes) {
    return null
  }
  const { state: canvasContextState, dispatch, dataStore } = useCanvas()
  const {
    openNotes,
    updateMainPosition,
    getPendingPosition,
    getCachedPosition,
    closeNote
  } = useCanvasWorkspace()
  const workspaceNoteMap = useMemo(() => {
    const map = new Map<string, OpenWorkspaceNote>()
    openNotes.forEach(note => map.set(note.noteId, note))
    return map
  }, [openNotes])
  const activeWorkspaceVersion = workspaceNoteMap.get(noteId)?.version ?? null
  const freshNoteSet = useMemo(() => new Set(freshNoteIds), [freshNoteIds])
  const mainOnlyNoteSet = useMemo(() => new Set(mainOnlyNoteIds), [mainOnlyNoteIds])
  const isDefaultOffscreenPosition = useCallback((position: { x: number; y: number } | null | undefined) => {
    return isDefaultMainPosition(position)
  }, [])

  const resolveWorkspacePosition = useCallback((targetNoteId: string): { x: number; y: number } | null => {
    // CRITICAL FIX: Check workspace mainPosition FIRST (set by openWorkspaceNote)
    // This ensures that newly computed viewport-centered positions override any stale cached positions
    const workspaceEntry = workspaceNoteMap.get(targetNoteId)
    if (workspaceEntry?.mainPosition && !isDefaultOffscreenPosition(workspaceEntry.mainPosition)) {
      debugLog({
        component: 'AnnotationCanvas',
        action: 'resolve_workspace_position_from_entry',
        metadata: {
          targetNoteId,
          position: workspaceEntry.mainPosition,
          source: 'workspaceEntry.mainPosition'
        }
      })
      return workspaceEntry.mainPosition
    }

    const pending = getPendingPosition(targetNoteId)
    if (pending && !isDefaultOffscreenPosition(pending)) {
      debugLog({
        component: 'AnnotationCanvas',
        action: 'resolve_workspace_position_from_pending',
        metadata: {
          targetNoteId,
          position: pending,
          source: 'pendingPosition'
        }
      })
      return pending
    }

    const cached = getCachedPosition(targetNoteId)
    if (cached && !isDefaultOffscreenPosition(cached)) {
      debugLog({
        component: 'AnnotationCanvas',
        action: 'resolve_workspace_position_from_cache',
        metadata: {
          targetNoteId,
          position: cached,
          source: 'cachedPosition'
        }
      })
      return cached
    }

    debugLog({
      component: 'AnnotationCanvas',
      action: 'resolve_workspace_position_null',
      metadata: {
        targetNoteId,
        source: 'none_found'
      }
    })

    return null
  }, [workspaceNoteMap, getPendingPosition, getCachedPosition, isDefaultOffscreenPosition])

  const workspaceMainPosition = useMemo(() => resolveWorkspacePosition(noteId), [noteId, resolveWorkspacePosition])
  const getItemNoteId = useCallback((item: CanvasItem): string | null => {
    if (item.noteId) return item.noteId
    if (item.storeKey) {
      const parsed = parsePanelKey(item.storeKey)
      if (parsed.noteId) return parsed.noteId
    }
    return null
  }, [])

  // Layer system for multi-layer canvas
  const layerContext = useLayer()
  const canvasOpacity = layerContext ? PopupStateAdapter.getLayerOpacity('notes', layerContext.activeLayer) : 1

  const getInitialCanvasState = useCallback(() => {
    const snapshot = activeWorkspaceVersion !== null
      ? loadStateFromStorage(noteId, activeWorkspaceVersion)
      : loadStateFromStorage(noteId)
    console.log('[AnnotationCanvas] useState initializer:', {
      noteId,
      hasSnapshot: !!snapshot,
      snapshotViewport: snapshot?.viewport
    })

    if (snapshot && snapshot.viewport) {
      const initialState = {
        ...createDefaultCanvasState(),
        translateX: snapshot.viewport.translateX ?? defaultViewport.translateX,
        translateY: snapshot.viewport.translateY ?? defaultViewport.translateY,
        zoom: snapshot.viewport.zoom ?? 1,
        showConnections: snapshot.viewport.showConnections ?? true
      }
      console.log('[AnnotationCanvas] Initializing state from snapshot:', initialState)
      return initialState
    }

    console.log('[AnnotationCanvas] Initializing state to default (no snapshot)')
    return createDefaultCanvasState()
  }, [noteId, activeWorkspaceVersion])

  const {
    canvasState,
    setCanvasState,
    canvasStateRef,
    updateCanvasTransform,
    panBy,
    lastCanvasEventRef,
  } = useCanvasTransform({
    noteId,
    layerContext,
    onCanvasStateChange,
    initialStateFactory: getInitialCanvasState,
  })

  // Track viewport changes for debugging
  const previousViewportRef = useRef({ x: canvasState.translateX, y: canvasState.translateY })

  useEffect(() => {
    const prev = previousViewportRef.current
    const changed = prev.x !== canvasState.translateX || prev.y !== canvasState.translateY

    if (changed) {
      const stack = new Error().stack
      const caller = stack?.split('\n')[3] || 'unknown'

      debugLog({
        component: 'AnnotationCanvas',
        action: 'viewport_changed',
        metadata: {
          noteId,
          from: { x: prev.x, y: prev.y },
          to: { x: canvasState.translateX, y: canvasState.translateY },
          delta: { x: canvasState.translateX - prev.x, y: canvasState.translateY - prev.y },
          zoom: canvasState.zoom,
          caller: caller.trim(),
          isDragging: canvasState.isDragging
        }
      })

      previousViewportRef.current = { x: canvasState.translateX, y: canvasState.translateY }
    }
  }, [canvasState.translateX, canvasState.translateY, canvasState.isDragging, noteId])

  // Unified canvas items state
  const workspaceSeededNotesRef = useRef<Set<string>>(new Set())
  const {
    canvasItems,
    setCanvasItems,
    canvasItemsRef,
    dedupeWarnings,
    updateDedupeWarnings,
  } = useCanvasItems({ noteId })
  const [isStateLoaded, setIsStateLoaded] = useState(false)
  const autoSaveTimerRef = useRef<number | null>(null)
  const [showControlPanel, setShowControlPanel] = useState(false)
  const [internalShowAddComponentMenu, setInternalShowAddComponentMenu] = useState(false)
  const mainPanelSeededRef = useRef(false)

  useCanvasNoteSync({
    hasNotes,
    noteIds,
    noteId,
    canvasItemsLength: canvasItems.length,
    mainOnlyNoteSet,
    freshNoteSeeds,
    onConsumeFreshNoteSeed,
    setCanvasItems,
    getItemNoteId,
    resolveWorkspacePosition,
  })

  // Reset per-note refs when noteId changes
  const initialNoteRef = useRef<string | null>(null)

  useEffect(() => {
    const isFirstNote = initialNoteRef.current === null
    if (isFirstNote) {
      initialNoteRef.current = noteId
    }

    const wasSeeded = workspaceSeededNotesRef.current.has(noteId)
    debugLog({
      component: 'AnnotationCanvas',
      action: 'noteId_changed_resetting_refs',
      metadata: {
        noteId,
        prevMainPanelSeeded: mainPanelSeededRef.current,
        prevWorkspaceSeedApplied: wasSeeded,
        isFirstNote,
      }
    })

    mainPanelSeededRef.current = false
    if (isFirstNote) {
      workspaceSeededNotesRef.current.clear()
      debugLog({
        component: 'AnnotationCanvas',
        action: 'workspace_seed_reset_all',
        metadata: { reason: 'first_note', noteId },
      })
    }
    debugLog({
      component: 'AnnotationCanvas',
      action: 'workspace_seed_note_cleared',
      metadata: {
        noteId,
        seededNotes: Array.from(workspaceSeededNotesRef.current),
      },
    })
  }, [noteId])
  const isRestoringSnapshotRef = useRef(false)
  const skipNextContextSyncRef = useRef(false)

  useEffect(() => {
    if (!mainOnlyNoteIds || mainOnlyNoteIds.length === 0) {
      return
    }

    setCanvasItems(prev => {
      let changed = false
      const filtered = prev.filter(item => {
        if (item.itemType !== 'panel' || item.panelId === 'main') {
          return true
        }
        const itemNoteId = getItemNoteId(item)
        if (itemNoteId && mainOnlyNoteSet.has(itemNoteId)) {
          changed = true
          return false
        }
        return true
      })
      return changed ? filtered : prev
    })
  }, [mainOnlyNoteIds, mainOnlyNoteSet, setCanvasItems, getItemNoteId])
  
  // Use external control if provided, otherwise use internal state
  const showAddComponentMenu = externalShowAddComponentMenu !== undefined ? externalShowAddComponentMenu : internalShowAddComponentMenu
  const toggleAddComponentMenu = onToggleAddComponentMenu || (() => setInternalShowAddComponentMenu(!internalShowAddComponentMenu))
  const [stickyOverlayEl, setStickyOverlayEl] = useState<HTMLElement | null>(null)

  // Canvas state persistence - Get provider instances for hydration
  const provider = useMemo(() => UnifiedProvider.getInstance(), [])
  const branchesMap = useMemo(() => provider.getBranchesMap(), [provider])
  const layerManagerApi = useLayerManager()
  const cameraUserId = useCameraUserId()

  // Hydrate canvas state on mount (panels + camera)
  // Skip camera restore for centered existing notes (main-only mode)
  const skipCameraRestore = mainOnlyNoteSet.has(noteId)

  const primaryHydrationStatus = useCanvasHydration({
    noteId,
    userId: cameraUserId ?? undefined,
    dataStore,
    branchesMap,
    layerManager: layerManagerApi.manager,
    enabled: Boolean(noteId),
    skipCameraRestore
  })

  const initialCanvasSetupRef = useRef(false)

  // CRITICAL: This effect updates main panel positions from workspace
  // It should ONLY run for BRAND NEW notes (first time opening), NOT when switching between already-open notes!
  useEffect(() => {
    // Check if main panel for this note already exists in canvasItems
    const mainPanelExists = canvasItems.some(item => {
      if (item.itemType === "panel" && item.panelId === "main") {
        const itemNoteId = getItemNoteId(item)
        return itemNoteId === noteId
      }
      return false
    })

    const alreadySeeded = workspaceSeededNotesRef.current.has(noteId)
    debugLog({
      component: 'AnnotationCanvas',
      action: 'workspaceSeedAppliedRef_effect_triggered',
      metadata: {
        noteId,
        mainPanelExists,
        workspaceSeedApplied: alreadySeeded,
        hasWorkspacePosition: !!workspaceMainPosition,
        workspacePosition: workspaceMainPosition,
        hydrationSuccess: primaryHydrationStatus.success,
        willUpdatePosition: !alreadySeeded && !!workspaceMainPosition && !primaryHydrationStatus.success,
        seededNotes: Array.from(workspaceSeededNotesRef.current),
      }
    })

    if (alreadySeeded) return
    if (!workspaceMainPosition) return
    if (primaryHydrationStatus.success) return
    debugLog({
      component: 'AnnotationCanvas',
      action: 'WORKSPACE_SEED_UPDATING_POSITIONS',
      metadata: {
        noteId,
        workspaceMainPosition,
        reason: 'workspace_seed_applied_new_note'
      }
    })

    let applied = false
    setCanvasItems(prev => {
      let changed = false
      const next = prev.map(item => {
        if (item.itemType === "panel" && item.panelId === "main") {
          const itemNoteId = getItemNoteId(item)
          if (itemNoteId === noteId) {
            const samePosition =
              item.position?.x === workspaceMainPosition.x &&
              item.position?.y === workspaceMainPosition.y
            if (samePosition) {
              applied = true
              return item
            }
            changed = true
            applied = true
            return { ...item, position: workspaceMainPosition }
          }
        }
        return item
      })
      if (changed) {
        applied = true
        return next
      }
      return prev
    })
    if (applied) {
      workspaceSeededNotesRef.current.add(noteId)
      debugLog({
        component: 'AnnotationCanvas',
        action: 'workspace_seed_applied_from_workspace_effect',
        metadata: {
          noteId,
          seedPosition: workspaceMainPosition,
          seededNotes: Array.from(workspaceSeededNotesRef.current),
        },
      })
    }
  }, [noteId, workspaceMainPosition, primaryHydrationStatus.success, getItemNoteId, canvasItems])

  // Enable camera persistence (debounced)
  useCameraPersistence({
    noteId,
    userId: cameraUserId ?? undefined,
    debounceMs: 500,
    enabled: true
  })

  // Enable panel persistence
  const { persistPanelCreate, persistPanelUpdate, getPanelDimensions } = usePanelPersistence({
    dataStore,
    branchesMap,
    layerManager: layerManagerApi.manager,
    noteId,
    canvasItems,
    userId: cameraUserId ?? undefined
  })

  const buildHydratedPanels = useHydrationPanelBuilder({
    mainOnlyNoteSet,
    canvasStateRef,
  })
  const mergeHydratedPanels = useHydrationPanelMerge({
    getItemNoteId,
  })
  const dispatchHydratedPanels = useHydrationDispatcher({
    dispatch,
    workspaceSeededNotesRef,
    getItemNoteId,
  })
  const { evaluateHydration, markHydrated, markNoPanels } = useHydrationNoteTracker()

  const handleNoteHydration = useCallback((targetNoteId: string, hydrationStatus: HydrationResult | null) => {
    const workspaceMainForTarget = resolveWorkspacePosition(targetNoteId)
    const mainPanelExists = canvasItems.some(item => item.itemType === 'panel' && item.panelId === 'main' && getItemNoteId(item) === targetNoteId)
    const { shouldHydrate, isInitialHydration, isSameNote, skipHydration } = evaluateHydration({
      targetNoteId,
      hydrationStatus,
      mainPanelExists,
    })

    if (!shouldHydrate) {
      return
    }

    if (!hydrationStatus) {
      return
    }

    const buildResult = buildHydratedPanels({
      targetNoteId,
      hydrationStatus,
      skipHydration,
      isInitialHydration,
      isSameNote,
      mainPanelExists,
    })

    if (!buildResult) {
      markNoPanels(targetNoteId, skipHydration)
      return
    }

    const { newItems } = buildResult

    setCanvasItems(prev => {
      const { itemsToAdd, nextItems } = mergeHydratedPanels({
        prevItems: prev,
        newItems,
        targetNoteId,
      })

      if (itemsToAdd.length > 0) {
        debugLog({
          component: 'AnnotationCanvas',
          action: 'HYDRATION_ADDING_PANELS',
          metadata: {
            noteId: targetNoteId,
            addedCount: itemsToAdd.length,
            totalItems: nextItems.length,
            addedPanels: itemsToAdd.map(p => ({
              panelId: p.panelId,
              position: p.position,
              noteId: p.noteId
            }))
          }
        })
        return nextItems
      }

      return prev
    })

    dispatchHydratedPanels({
      itemsToAdd: newItems,
      workspaceMainPosition: workspaceMainForTarget,
      mainPanelExists,
      targetNoteId,
      initialCanvasSetupRef,
      setCanvasItems,
    })

    markHydrated(targetNoteId)

  }, [buildHydratedPanels, canvasItems, dispatchHydratedPanels, evaluateHydration, freshNoteSet, mergeHydratedPanels, onFreshNoteHydrated, resolveWorkspacePosition, setCanvasItems, markHydrated, markNoPanels])

  useEffect(() => {
    if (!noteId) return
    handleNoteHydration(noteId, primaryHydrationStatus)
  }, [noteId, primaryHydrationStatus, handleNoteHydration])

  const persistCameraSnapshot = useCallback(
    async (camera: { x: number; y: number; zoom: number }) => {
      if (typeof window === 'undefined') return
      try {
        await fetch(`/api/canvas/camera/${noteId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ camera, userId: cameraUserId ?? null })
        })
      } catch (error) {
        console.warn('[AnnotationCanvas] Failed to persist restored camera snapshot', error)
      }
    },
    [noteId, cameraUserId]
  )

  // Persist main panel if it doesn't exist in database (first-time note open)
  useEffect(() => {
    if (primaryHydrationStatus.success) {
      const hasMainPanel = primaryHydrationStatus.panels.some(p => p.id === 'main')

      if (!hasMainPanel && !mainPanelSeededRef.current) {
        // Main panel doesn't exist in database - persist it with CENTERED position
        debugLog({
          component: 'AnnotationCanvas',
          action: 'persisting_default_main_panel',
          metadata: { noteId }
        })

        // Calculate a centered position instead of using offscreen default
        const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1920
        const viewportHeight = typeof window !== 'undefined' ? window.innerHeight : 1080

        // CRITICAL FIX: Find the main panel for THIS note, not just any main panel
        const mainPanelItem = canvasItems.find(item => {
          if (item.itemType === 'panel' && item.panelId === 'main') {
            const itemNoteId = getItemNoteId(item)
            return itemNoteId === noteId
          }
          return false
        })

        const screenDimensions = getPanelDimensions('main')
        const worldPanelWidth = screenDimensions.width / canvasState.zoom
        const worldPanelHeight = screenDimensions.height / canvasState.zoom

        // Calculate world position that will appear centered with current viewport
        // Screen center position (where we want panel center to appear)
        const screenCenterX = viewportWidth / 2
        const screenCenterY = viewportHeight / 2

        // Convert screen position to world position
        // screenPos = (worldPos + viewportTranslate) * zoom
        // worldPos = (screenPos / zoom) - viewportTranslate
        const worldCenterX = (screenCenterX / canvasState.zoom) - canvasState.translateX
        const worldCenterY = (screenCenterY / canvasState.zoom) - canvasState.translateY

        // Offset by half panel size to center the panel (not just top-left corner)
        const centeredPosition = {
          x: worldCenterX - (worldPanelWidth / 2),
          y: worldCenterY - (worldPanelHeight / 2)
        }

        // Get current main panel position from canvas items (if already set)
        const existingMainPanelPosition = mainPanelItem?.position && !isDefaultOffscreenPosition(mainPanelItem.position)
          ? mainPanelItem.position
          : null
        const workspacePosition = workspaceMainPosition && !isDefaultOffscreenPosition(workspaceMainPosition)
          ? workspaceMainPosition
          : null

        // Priority: 1) existing main panel position (if not default), 2) workspace position (if not default), 3) calculated centered position
        const mainPosition = existingMainPanelPosition || workspacePosition || centeredPosition

        const defaultMainPosition = getDefaultMainPosition()

        debugLog({
          component: 'AnnotationCanvas',
          action: 'NEW_NOTE_MAIN_POSITION_DETERMINED',
          metadata: {
            noteId,
            mainPanelItem_position: mainPanelItem?.position,
            workspaceMainPosition,
            defaultMainPosition,
            centeredPosition,
            currentViewport: { x: canvasState.translateX, y: canvasState.translateY, zoom: canvasState.zoom },
            finalMainPosition: mainPosition
          }
        })

        console.log('[NEW NOTE] Main panel position determined:', {
          'from canvasItems': mainPanelItem?.position,
          'from workspace': workspaceMainPosition,
          'default (offscreen)': defaultMainPosition,
          'calculated centered': centeredPosition,
          'current viewport': { x: canvasState.translateX, y: canvasState.translateY },
          'FINAL POSITION USED': mainPosition
        })

        // Update canvas items to use the final position (especially if we calculated a centered position)
        if (!mainPanelItem?.position || isDefaultOffscreenPosition(mainPanelItem.position)) {
          // Main panel is using default offscreen position or doesn't exist - update it to centered position
          const currentPosition = mainPanelItem?.position
          if (!currentPosition || currentPosition.x !== mainPosition.x || currentPosition.y !== mainPosition.y) {
            setCanvasItems(prev =>
              prev.map(item => {
                // CRITICAL FIX: Only update the main panel for THIS noteId, not all main panels!
                const itemNoteId = getItemNoteId(item)
                if (item.itemType === 'panel' && item.panelId === 'main' && itemNoteId === noteId) {
                  return { ...item, position: mainPosition }
                }
                return item
              })
            )
            debugLog({
              component: 'AnnotationCanvas',
              action: 'NEW_NOTE_CANVAS_POSITION_UPDATED',
              metadata: { noteId, mainPosition },
            })
          }
        }

        const cameraForConversion = {
          x: canvasState.translateX,
          y: canvasState.translateY
        }
        const screenPosition = worldToScreen(mainPosition, cameraForConversion, canvasState.zoom)

        const mainStoreKey = ensurePanelKey(noteId, 'main')
        const mainBranch = dataStore.get(mainStoreKey)
        const resolvedTitle =
          (mainBranch && typeof mainBranch.title === 'string' && mainBranch.title.trim().length > 0
            ? mainBranch.title
            : mainPanelItem?.title) ?? undefined

        const seedReason = existingMainPanelPosition
          ? 'existing_position'
          : workspacePosition
            ? 'workspace_position'
            : 'centered_position'

        debugLog({
          component: 'AnnotationCanvas',
          action: 'workspace_main_panel_seeded',
          metadata: {
            noteId,
            seedReason,
            screenDimensions,
            worldPanelSize: { width: worldPanelWidth, height: worldPanelHeight },
            mainPosition,
            viewport: {
              translateX: canvasState.translateX,
              translateY: canvasState.translateY,
              zoom: canvasState.zoom
            }
          }
        })

        persistPanelCreate({
          panelId: 'main',
          storeKey: ensurePanelKey(noteId, 'main'),  // Composite key for multi-note support
          type: 'editor',
          position: screenPosition,
          size: { width: screenDimensions.width, height: screenDimensions.height },
          zIndex: 0,
          title: resolvedTitle,
          metadata: { annotationType: 'main' }
        }).catch(err => {
          debugLog({
            component: 'AnnotationCanvas',
            action: 'main_panel_persist_failed',
            metadata: { error: err instanceof Error ? err.message : 'Unknown error' }
          })
        })

        void updateMainPosition(noteId, mainPosition).catch(err => {
          debugLog({
            component: 'AnnotationCanvas',
            action: 'workspace_main_position_update_failed',
            metadata: {
              error: err instanceof Error ? err.message : 'Unknown error',
              noteId
            }
          })
        })

        mainPanelSeededRef.current = true
      }
    }
  }, [
    primaryHydrationStatus.success,
    primaryHydrationStatus.panels,
    noteId,
    canvasItems,
    persistPanelCreate,
    workspaceMainPosition,
    updateMainPosition,
    // CRITICAL FIX: DO NOT include canvasState.zoom/translateX/translateY
    // Including viewport state causes this effect to re-run on every camera pan,
    // which recalculates positions and causes panels to jump when switching tabs!
    // This effect should ONLY run when hydration completes or note changes.
    dataStore
  ])

  // Selection guards to prevent text highlighting during canvas drag
  const selectionGuardsRef = useRef<{
    onSelectStart: (e: Event) => void;
    onDragStart: (e: Event) => void;
    prevUserSelect: string;
  } | null>(null)

  const enableSelectionGuards = useCallback(() => {
    if (typeof document === 'undefined') return
    if (selectionGuardsRef.current) return
    const onSelectStart = (e: Event) => { e.preventDefault() }
    const onDragStart = (e: Event) => { e.preventDefault() }
    selectionGuardsRef.current = { onSelectStart, onDragStart, prevUserSelect: document.body.style.userSelect }
    document.documentElement.classList.add('dragging-no-select')
    document.body.style.userSelect = 'none'
    document.addEventListener('selectstart', onSelectStart, true)
    document.addEventListener('dragstart', onDragStart, true)
    try { window.getSelection()?.removeAllRanges?.() } catch {}
  }, [])

  // CRITICAL FIX: Memoize minimap navigation callback to prevent infinite loop
  // The inline callback was being recreated on every render, causing minimap's
  // useCallback to recreate whenever onNavigate changed, leading to infinite loop
  const handleMinimapNavigate = useCallback(
    (x: number, y: number) => {
      updateCanvasTransform(prev => ({
        ...prev,
        translateX: x,
        translateY: y,
      }))
    },
    [updateCanvasTransform]
  )

  useEffect(() => {
    // Skip syncing if we're currently restoring from snapshot
    // This prevents the visible "jump" from default viewport to restored viewport
    if (isRestoringSnapshotRef.current) {
      debugLog({
        component: 'AnnotationCanvas',
        action: 'skip_context_sync_during_snapshot_restore',
        metadata: { noteId, reason: 'snapshot_restoration_in_progress' }
      })
      return
    }

    if (skipNextContextSyncRef.current) {
      skipNextContextSyncRef.current = false
      debugLog({
        component: 'AnnotationCanvas',
        action: 'skip_context_sync_after_snapshot_skip',
        metadata: { noteId }
      })
      return
    }

    const { translateX, translateY, zoom } = canvasContextState.canvasState
    setCanvasState(prev => {
      if (
        prev.translateX === translateX &&
        prev.translateY === translateY &&
        prev.zoom === zoom
      ) {
        return prev
      }
      return {
        ...prev,
        translateX,
        translateY,
        zoom,
      }
    })
  }, [
    canvasContextState.canvasState.translateX,
    canvasContextState.canvasState.translateY,
    canvasContextState.canvasState.zoom,
    noteId
  ])

  const disableSelectionGuards = useCallback(() => {
    if (typeof document === 'undefined') return
    const g = selectionGuardsRef.current
    if (!g) return
    document.removeEventListener('selectstart', g.onSelectStart, true)
    document.removeEventListener('dragstart', g.onDragStart, true)
    document.documentElement.classList.remove('dragging-no-select')
    document.body.style.userSelect = g.prevUserSelect || ''
    selectionGuardsRef.current = null
  }, [])

  useEffect(() => {
    // Note: We no longer clear editor docs when switching notes
    // The composite key system (noteId-panelId) already isolates docs between notes
    // This allows content to load immediately when switching back to a previously viewed note
    
    // Check if we're in plain mode (explicit flag; avoids provider init race)
    const isPlainMode = isPlainModeActive()
    
    if (!isPlainMode) {
      // Initialize collaboration provider with YJS persistence
      const provider = UnifiedProvider.getInstance()
      
      // Set the current note context
      provider.setCurrentNote(noteId)
      
      // Check if this is a new note (check localStorage for existing data)
      const existingData = localStorage.getItem(`note-data-${noteId}`)
      const isNewNote = !existingData
      
      console.log('[AnnotationCanvas] Initializing note:', {
        noteId,
        hasExistingData: !!existingData,
        isNewNote
      })
      
      // CRITICAL FIX: Use workspaceMainPosition instead of legacy {2000, 1500}
      // This ensures provider initialization uses the computed viewport-centered position
      const initialPosition = workspaceMainPosition ?? getDefaultMainPosition()

      debugLog({
        component: 'AnnotationCanvas',
        action: 'provider_init_position',
        metadata: {
          noteId,
          workspaceMainPosition,
          initialPosition,
          isNewNote
        }
      })

      // Define default data for new notes
      const defaultData = {
        'main': {
          title: 'New Document',
          type: 'main',
          content: '', // Empty content for new documents
          branches: [],
          position: initialPosition,  // Use computed position, not hardcoded legacy
          isEditable: true,
          // Mark as new to force edit mode
          isNew: isNewNote
        }
      }

      console.log('[AnnotationCanvas] Default data for main panel:', defaultData.main)

      // Initialize with defaults - the provider will merge with existing data if any
      // For new notes, this sets empty content
      // For existing notes, this preserves their content
      provider.initializeDefaultData(noteId, defaultData)
    }

    return () => {
      // Don't destroy note when switching - only cleanup when truly unmounting
      // The provider's smart cache management will handle memory efficiently
      // This allows content to persist when switching between notes
    }
  }, [noteId])

  useCanvasSnapshot({
    noteId,
    activeWorkspaceVersion,
    skipSnapshotForNote: skipSnapshotForNote ?? null,
    workspaceMainPosition,
    canvasState,
    canvasStateRef,
    canvasItems,
    getItemNoteId,
    isDefaultOffscreenPosition,
    setCanvasState,
    setCanvasItems,
    setIsStateLoaded,
    autoSaveTimerRef,
    initialCanvasSetupRef,
    skipNextContextSyncRef,
    isRestoringSnapshotRef,
    getPendingPosition,
    getCachedPosition,
    freshNoteSet,
    freshNoteSeeds,
    onSnapshotLoadComplete,
    onSnapshotSettled,
    pendingSaveMaxAgeMs: PENDING_SAVE_MAX_AGE_MS,
    dispatch,
    updateDedupeWarnings,
    primaryHydrationStatus,
    dataStore,
  })

  // Cleanup auto-save timer on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimerRef.current) {
        window.clearTimeout(autoSaveTimerRef.current)
        autoSaveTimerRef.current = null
      }
    }
  }, [])

  const captureInteractionPoint = useCallback((event: { clientX: number; clientY: number }, source: 'canvas' | 'keyboard' | 'toolbar' = 'canvas') => {
    const point = { x: event.clientX, y: event.clientY }
    lastCanvasEventRef.current = point
    if (typeof window !== 'undefined') {
      ;(window as any).__canvasLastInteraction = point
      ;(window as any).__canvasLastInteractionSource = source
    }
  }, [])

  const handleCanvasMouseMoveCapture = useCallback((event: React.MouseEvent) => {
    captureInteractionPoint(event)
  }, [captureInteractionPoint])

  const handleCanvasWheelCapture = useCallback((event: React.WheelEvent) => {
    captureInteractionPoint(event)
  }, [captureInteractionPoint])

  const handleCanvasMouseDown = (e: React.MouseEvent) => {
    captureInteractionPoint(e)
    // Only respond to primary button (left-click)
    // Ignore right-click (button 2), middle-click (button 1), etc.
    if (e.button !== 0) return

    // Only start dragging if clicking on canvas background
    // Don't drag if clicking on a panel or component
    const target = e.target instanceof Element ? e.target : null
    if (target && (target.closest('.panel') || target.closest('[data-component-panel]'))) return

    setCanvasState(prev => ({
      ...prev,
      isDragging: true,
      lastMouseX: e.clientX,
      lastMouseY: e.clientY
    }))

    enableSelectionGuards()
    document.body.style.userSelect = 'none'
    try { window.getSelection()?.removeAllRanges?.() } catch {}
    e.preventDefault()
  }

  const handleCanvasMouseMove = (e: MouseEvent) => {
    captureInteractionPoint(e)
    // CRITICAL FIX: Use ref to avoid infinite loop
    // Reading from canvasStateRef prevents useEffect from re-running
    // when lastMouseX/lastMouseY change during dragging
    if (!canvasStateRef.current.isDragging) return

    const deltaX = e.clientX - canvasStateRef.current.lastMouseX
    const deltaY = e.clientY - canvasStateRef.current.lastMouseY

    updateCanvasTransform(prev => ({
      ...prev,
      translateX: prev.translateX + deltaX,
      translateY: prev.translateY + deltaY,
      lastMouseX: e.clientX,
      lastMouseY: e.clientY,
    }))
  }

  const handleCanvasMouseUp = () => {
    setCanvasState(prev => ({ ...prev, isDragging: false }))
    document.body.style.userSelect = ''
    disableSelectionGuards()
  }

  const handleWheel = (e: React.WheelEvent) => {
    // Only zoom if Shift key is held down
    if (!e.shiftKey) {
      // Allow normal scrolling when Shift is not pressed
      return
    }
    
    e.preventDefault()

    const multiplier = getWheelZoomMultiplier(e.nativeEvent)
    const newZoom = Math.max(0.3, Math.min(2, canvasState.zoom * multiplier))
    
    const rect = e.currentTarget.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top
    
    const zoomChange = newZoom / canvasState.zoom
    
    updateCanvasTransform(prev => ({
      ...prev,
      zoom: newZoom,
      translateX: mouseX - (mouseX - prev.translateX) * zoomChange,
      translateY: mouseY - (mouseY - prev.translateY) * zoomChange,
    }))
  }

  useEffect(() => {
    document.addEventListener('mousemove', handleCanvasMouseMove)
    document.addEventListener('mouseup', handleCanvasMouseUp)

    return () => {
      document.removeEventListener('mousemove', handleCanvasMouseMove)
      document.removeEventListener('mouseup', handleCanvasMouseUp)
    }
  }, [canvasState.isDragging])
  // NOTE: lastMouseX/lastMouseY deliberately excluded from dependencies
  // We read them via canvasStateRef to avoid infinite loop when dragging updates mouse position

  useEffect(() => {
    if (typeof document === 'undefined') return

    const overlay = document.createElement('div')
    overlay.id = 'sticky-note-overlay-root'
    overlay.style.position = 'fixed'
    overlay.style.inset = '0'
    overlay.style.pointerEvents = 'none'
    overlay.style.zIndex = '12000'
    overlay.style.display = 'block'

    document.body.appendChild(overlay)
    setStickyOverlayEl(overlay)

    return () => {
      document.body.removeChild(overlay)
      setStickyOverlayEl(null)
    }
  }, [])

  const handlePanelClose = (panelId: string, panelNoteId?: string) => {
    let storeKeyToDelete: string | undefined
    const closedAt = new Date().toISOString()

    debugLog({
      component: 'AnnotationCanvas',
      action: 'panel_close_start',
      metadata: {
        panelId,
        panelNoteId,
        currentNoteId: noteId,
        canvasItemsCount: canvasItems.length
      },
      content_preview: `Closing panel ${panelId} (note: ${panelNoteId || noteId})`
    })

    setCanvasItems(prev => {
      const filtered = prev.filter(item => {
        if (isPanel(item) && item.panelId === panelId) {
          const itemNoteId = getItemNoteId(item) || panelNoteId
          if (!panelNoteId || itemNoteId === panelNoteId) {
            storeKeyToDelete = item.storeKey ?? (itemNoteId ? ensurePanelKey(itemNoteId, panelId) : undefined)

            debugLog({
              component: 'AnnotationCanvas',
              action: 'panel_removed_from_items',
              metadata: {
                panelId,
                itemNoteId,
                storeKey: item.storeKey,
                storeKeyToDelete,
                position: item.position
              },
              content_preview: `Removed panel ${panelId} from canvasItems`
            })

            return false
          }
        }
        return true
      })

      debugLog({
        component: 'AnnotationCanvas',
        action: 'panel_close_items_updated',
        metadata: {
          panelId,
          beforeCount: prev.length,
          afterCount: filtered.length,
          removedCount: prev.length - filtered.length
        },
        content_preview: `canvasItems: ${prev.length} â†’ ${filtered.length}`
      })

      return filtered
    })

    const targetNoteId = panelNoteId || noteId
    if (!targetNoteId) {
      console.warn('[AnnotationCanvas] Cannot close panel without note id', panelId)
      return
    }

    const storeKey = storeKeyToDelete ?? ensurePanelKey(targetNoteId, panelId)
    const existingPanelData = dataStore.get(storeKey)
    const existingRevision = existingPanelData?.revisionToken
    const parentId = existingPanelData?.parentId

    if (existingPanelData) {
      dataStore.update(storeKey, { state: 'closed', closedAt })
      debugLog({
        component: 'AnnotationCanvas',
        action: 'panel_state_marked_closed',
        metadata: {
          panelId,
          noteId: targetNoteId,
          storeKey,
          parentId,
          revisionToken: existingRevision
        }
      })
    }

    if (branchesMap?.has(storeKey)) {
      const branchData = branchesMap.get(storeKey)
      branchesMap.set(storeKey, { ...branchData, state: 'closed', closedAt })
    }

    const removeBranchReference = (ownerNoteId: string, ownerPanelId: string) => {
      const ownerKey = ensurePanelKey(ownerNoteId, ownerPanelId)
      const ownerData = dataStore.get(ownerKey)
      if (ownerData?.branches?.length) {
        const filtered = ownerData.branches.filter((childId: string) => childId !== panelId)
        if (filtered.length !== ownerData.branches.length) {
          dataStore.update(ownerKey, { branches: filtered })
        }
      }

      if (branchesMap?.has(ownerKey)) {
        const ownerBranch = branchesMap.get(ownerKey)
        const ownerBranches = ownerBranch?.branches
        if (Array.isArray(ownerBranches)) {
          const filtered = ownerBranches.filter((childId: string) => childId !== panelId)
          if (filtered.length !== ownerBranches.length) {
            branchesMap.set(ownerKey, { ...ownerBranch, branches: filtered })
          }
        }
      }
    }

    if (panelId !== 'main') {
      removeBranchReference(targetNoteId, 'main')
      if (parentId && parentId !== 'main') {
        removeBranchReference(targetNoteId, parentId)
      }
    }

    if (layerManagerApi.manager.getNode(storeKey)) {
      layerManagerApi.manager.removeNode(storeKey)
    }

    // CRITICAL: Also remove panel from state.panels Map so it can be reopened later
    // CRITICAL FIX: Use composite key (storeKey) not just panelId
    dispatch({
      type: 'REMOVE_PANEL',
      payload: { id: storeKey }  // Use composite key "noteId::panelId" not just "panelId"
    })

    if (typeof window !== 'undefined') {
      try {
        window.localStorage.setItem(`note-data-${targetNoteId}:invalidated`, Date.now().toString())
      } catch (error) {
        console.warn('[AnnotationCanvas] Failed to mark snapshot tombstone', error)
      }
    }

    if (panelId === 'main') {
      closeNote(targetNoteId, { persist: true }).catch(error => {
        console.warn('[AnnotationCanvas] Failed to persist workspace close', error)
      })
    }

    persistPanelUpdate({
      panelId,
      storeKey,
      state: 'closed',
      expectedRevision: existingRevision
    }).catch(err => {
      debugLog({
        component: 'AnnotationCanvas',
        action: 'panel_close_state_persist_failed',
        metadata: {
          panelId,
          noteId: targetNoteId,
          error: err instanceof Error ? err.message : 'Unknown error'
        }
      })
    })
  }

  const handleCreatePanel = (panelId: string, parentPanelId?: string, parentPosition?: { x: number, y: number }, sourceNoteId?: string, isPreview?: boolean, coordinateSpace?: 'screen' | 'world') => {
    const targetNoteId = sourceNoteId || noteId
    if (!targetNoteId) {
      console.warn('[AnnotationCanvas] Cannot create panel without target note id', panelId)
      return
    }

    console.log('[AnnotationCanvas] Creating panel:', panelId, 'for note:', targetNoteId, 'with parent:', parentPanelId, 'at position:', parentPosition)

    if (isDebugEnabled()) {
      debugLog({
        component: 'AnnotationCanvas',
        action: 'handle_create_panel',
        metadata: {
          panelId,
          parentPanelId,
          parentPosition,
          isPlainMode: isPlainModeActive(),
          noteId: targetNoteId
        },
        content_preview: `Creating panel ${panelId} at x=${parentPosition?.x}, y=${parentPosition?.y}`,
        note_id: targetNoteId
      }).catch(console.error)
    }

    const isPlainMode = isPlainModeActive()

    setCanvasItems(prev => {
      const newPanelStoreKey = ensurePanelKey(targetNoteId, panelId)

      if (isDebugEnabled()) {
        debugLog({
          component: 'AnnotationCanvas',
          action: 'create_panel_check_existing',
          metadata: {
            panelId,
            targetNoteId,
            newPanelStoreKey,
            currentCanvasItemsCount: prev.length,
            panelIdsInItems: prev.filter(isPanel).map(p => ({ panelId: p.panelId, noteId: getItemNoteId(p) }))
          },
          content_preview: `Checking if panel ${panelId} already exists in ${prev.length} items`
        })
      }

      const existingPanelCheck = prev.some(item => isPanel(item) && item.panelId === panelId && getItemNoteId(item) === targetNoteId)

      if (existingPanelCheck) {
        debugLog({
          component: 'AnnotationCanvas',
          action: 'create_panel_early_return',
          metadata: {
            panelId,
            targetNoteId,
            reason: 'Panel already exists in canvasItems'
          },
          content_preview: `EARLY RETURN: Panel ${panelId} already exists, not creating`
        })
        return prev
      }

      debugLog({
        component: 'AnnotationCanvas',
        action: 'create_panel_proceeding',
        metadata: {
          panelId,
          targetNoteId,
          isPlainMode: isPlainModeActive()
        },
        content_preview: `Proceeding to create panel ${panelId}`
      })

      if (isPlainMode) {
        if (parentPosition && (window as any).canvasDataStore) {
          const dataStore = (window as any).canvasDataStore
          const existingPanelData = dataStore.get(newPanelStoreKey)

          if (!existingPanelData?.worldPosition) {
            // Only convert screen->world if position is in screen space
            // If coordinateSpace is 'world', parentPosition is already in world coordinates
            const worldPosition = coordinateSpace === 'world'
              ? parentPosition
              : screenToWorld(parentPosition, { x: canvasState.translateX, y: canvasState.translateY }, canvasState.zoom)

            dataStore.update(newPanelStoreKey, {
              id: panelId,
              position: worldPosition,
              worldPosition
            })
          }
        }
      } else {
        const provider = UnifiedProvider.getInstance()
        provider.setCurrentNote(targetNoteId)

        const yjsBranches = provider.getBranchesMap()
        const panelData = yjsBranches.get(newPanelStoreKey)

        if (!panelData) {
          console.warn(`No data found for panel ${panelId} (note ${targetNoteId})`)
          return prev
        }

        if (parentPosition) {
          // Only convert screen->world if position is in screen space
          // If coordinateSpace is 'world', parentPosition is already in world coordinates
          const worldPosition = coordinateSpace === 'world'
            ? parentPosition
            : screenToWorld(parentPosition, { x: canvasState.translateX, y: canvasState.translateY }, canvasState.zoom)

          panelData.position = worldPosition
          yjsBranches.set(newPanelStoreKey, panelData)
        }
      }

      const hydratedStoreKey = newPanelStoreKey
      let branchData = dataStore?.get(hydratedStoreKey)
      if (!branchData && branchesMap) {
        branchData = branchesMap.get(hydratedStoreKey)
      }

      let panelType: PanelType
      if (panelId === 'main') {
        panelType = 'main'
      } else if (branchData?.type) {
        panelType = branchData.type as PanelType
      } else {
        panelType = panelId.includes('explore') ? 'explore' : panelId.includes('promote') ? 'promote' : 'note'
      }

      const dbPanelType: 'editor' | 'branch' | 'context' | 'toolbar' | 'annotation' =
        panelId === 'main' ? 'editor' :
        panelType === 'explore' ? 'context' :
        panelType === 'promote' ? 'annotation' : 'branch'

      // For preview panels from dropdown, the parentPosition is already in screen coordinates
      // We DON'T need to convert since the dropdown is fixed and preview should appear adjacent to it
      // Panels are rendered with position:absolute inside the canvas, so we use screen coords directly
      const position = isPreview && parentPosition
        ? (() => {
            console.log('[AnnotationCanvas] Using preview screen position directly:', {
              isPreview,
              position: parentPosition,
              note: 'Screen coordinates from fixed dropdown'
            })
            return parentPosition  // Already screen coordinates, no conversion needed
          })()
        : (branchData?.position || branchData?.worldPosition)
          ? (branchData.position || branchData.worldPosition)
          : parentPosition
            ? (coordinateSpace === 'world'
                ? parentPosition  // Already in world coordinates, no conversion needed
                : screenToWorld(parentPosition, { x: canvasState.translateX, y: canvasState.translateY }, canvasState.zoom))
            : { x: 2000, y: 1500 }

      let panelTitle: string | undefined
      if (panelType !== 'main') {
        if (branchData?.preview) {
          panelTitle = branchData.preview
        } else if (branchData?.title) {
          panelTitle = branchData.title
        }
      } else {
        const mainStoreKey = ensurePanelKey(targetNoteId, 'main')
        const mainBranch = dataStore.get(mainStoreKey)
        panelTitle =
          (mainBranch && typeof mainBranch.title === 'string' && mainBranch.title.trim().length > 0
            ? mainBranch.title
            : undefined) ?? 'Main'
      }

      // Use the provided coordinateSpace, or determine it based on position source
      const effectiveCoordinateSpace = coordinateSpace ?? ((isPreview && parentPosition) ? 'screen' : 'world')

      const persistencePosition = effectiveCoordinateSpace === 'screen' && parentPosition
        ? parentPosition
        : position

      persistPanelCreate({
        panelId,
        storeKey: hydratedStoreKey,
        type: dbPanelType,
        position: persistencePosition,
        size: { width: 500, height: 400 },
        zIndex: 1,
        title: panelTitle,
        metadata: { annotationType: panelType },
        coordinateSpace: effectiveCoordinateSpace
      }).catch(err => {
        debugLog({
          component: 'AnnotationCanvas',
          action: 'panel_create_persist_failed',
          metadata: {
            panelId,
            noteId: targetNoteId,
            error: err instanceof Error ? err.message : 'Unknown error'
          }
        })
      })

      persistPanelUpdate({
        panelId,
        storeKey: hydratedStoreKey,
        position: persistencePosition,
        coordinateSpace: effectiveCoordinateSpace,
        state: 'active'
      }).catch(err => {
        debugLog({
          component: 'AnnotationCanvas',
          action: 'panel_state_active_persist_failed',
          metadata: {
            panelId,
            noteId: targetNoteId,
            error: err instanceof Error ? err.message : 'Unknown error'
          }
        })
      })

      const existingPanel = prev.find(item => item.itemType === 'panel' && item.panelId === panelId && getItemNoteId(item) === targetNoteId)
      if (existingPanel) {
        debugLog({
          component: 'AnnotationCanvas',
          action: 'panel_already_exists',
          metadata: {
            panelId,
            noteId: targetNoteId,
            existingPosition: existingPanel.position,
            requestedPosition: position
          }
        })
        return prev
      }

      return [
        ...prev,
        createPanelItem(
          panelId,
          position,
          panelType,
          targetNoteId,
          hydratedStoreKey,
        ),
      ]
    })
  }
  
  // Handle adding components
  const handleAddComponent = (type: string, position?: { x: number; y: number }) => {
    console.log('[Canvas] handleAddComponent called with type:', type, 'position:', position)

    // Calculate position - center of viewport in world coordinates
    // The canvas translate is the offset, so we need to negate it to get world position
    const viewportCenterX = window.innerWidth / 2
    const viewportCenterY = window.innerHeight / 2

    // Convert from screen space to world space
    // World position = (Screen position - Canvas translate) / zoom
    const worldX = (-canvasState.translateX + viewportCenterX) / canvasState.zoom
    const worldY = (-canvasState.translateY + viewportCenterY) / canvasState.zoom

    // Center the component (component is ~350px wide, ~300px tall)
    const finalPosition = position || {
      x: worldX - 175,
      y: worldY - 150
    }

    const stickyScreenPosition = position || {
      x: viewportCenterX - 175,
      y: viewportCenterY - 150
    }

    console.log('[Canvas] Creating component at position:', type === 'sticky-note' ? stickyScreenPosition : finalPosition)

    const newComponent = createComponentItem(
      type as 'calculator' | 'timer' | 'sticky-note' | 'dragtest' | 'perftest',
      type === 'sticky-note' ? stickyScreenPosition : finalPosition
    )

    console.log('[Canvas] Created component:', newComponent)
    console.log('[Canvas] Adding to canvasItems')
    setCanvasItems(prev => [...prev, newComponent])
  }
  
  const handleComponentClose = (id: string) => {
    setCanvasItems(prev => prev.filter(item => item.id !== id))
  }
  
  const handleComponentPositionChange = (id: string, position: { x: number; y: number }) => {
    setCanvasItems(prev => prev.map(item => 
      item.id === id ? { ...item, position } : item
    ))
  }

  const componentItems = useMemo(() => canvasItems.filter(isComponent), [canvasItems])
  const stickyNoteItems = useMemo(
    () => componentItems.filter(item => item.componentType === 'sticky-note'),
    [componentItems]
  )
  const floatingComponents = useMemo(
    () => componentItems.filter(item => item.componentType !== 'sticky-note'),
    [componentItems]
  )

  const uniqueNoteIds = useMemo(
    () => Array.from(new Set(noteIds.filter((id): id is string => typeof id === 'string' && id.length > 0))),
    [noteIds]
  )

  const secondaryNoteIds = useMemo(
    () => uniqueNoteIds.filter(id => id !== noteId),
    [uniqueNoteIds, noteId]
  )

  // Subscribe to panel creation events
  useEffect(() => {
    const handlePanelEvent = (event: CustomEvent) => {
      if (event.detail?.panelId) {
        handleCreatePanel(
          event.detail.panelId,
          event.detail.parentPanelId,
          event.detail.parentPosition,
          event.detail.noteId,
          false, // isPreview
          event.detail.coordinateSpace // Pass coordinate space flag
        )
      }
    }
    
    const handlePreviewPanelEvent = (event: CustomEvent) => {
      console.log('[AnnotationCanvas] Received preview-panel event:', event.detail)

      if (event.detail?.panelId) {
        // Create a temporary preview panel
        // Use previewPosition if provided (viewport-relative), otherwise use parentPosition
        const position = event.detail.previewPosition || event.detail.parentPosition

        console.log('[AnnotationCanvas] Creating preview panel:', {
          panelId: event.detail.panelId,
          position,
          isPreview: true
        })

        handleCreatePanel(
          event.detail.panelId,
          event.detail.parentPanelId,
          position,
          event.detail.noteId,
          true  // isPreview = true, forces use of provided position
        )
      }
    }
    
    const handleRemovePreviewPanelEvent = (event: CustomEvent) => {
      if (event.detail?.panelId) {
        // Remove the preview panel
        handlePanelClose(event.detail.panelId)
      }
    }

    window.addEventListener('create-panel' as any, handlePanelEvent)
    window.addEventListener('preview-panel' as any, handlePreviewPanelEvent)
    window.addEventListener('remove-preview-panel' as any, handleRemovePreviewPanelEvent)
    
    return () => {
      window.removeEventListener('create-panel' as any, handlePanelEvent)
      window.removeEventListener('preview-panel' as any, handlePreviewPanelEvent)
      window.removeEventListener('remove-preview-panel' as any, handleRemovePreviewPanelEvent)
    }
  }, [noteId]) // Add noteId dependency to ensure we're using the correct note

  // Create viewport snapshot for auto-save
  const viewportSnapshot = useMemo(
    () => ({
      zoom: canvasState.zoom,
      translateX: canvasState.translateX,
      translateY: canvasState.translateY,
      showConnections: canvasState.showConnections,
    }),
    [canvasState.zoom, canvasState.translateX, canvasState.translateY, canvasState.showConnections]
  )

  useCanvasAutosave({
    noteId,
    canvasItems,
    getItemNoteId,
    viewportSnapshot,
    isStateLoaded,
    activeWorkspaceVersion,
    updateDedupeWarnings,
    autoSaveTimerRef,
  })

  const centerOnPanel = useCallback(
    (storeKeyOrPanelId: string) => {
      const normalizePosition = (value: any): { x: number; y: number } | null => {
        if (!value || typeof value !== 'object') return null
        const { x, y } = value as { x?: number; y?: number }
        if (typeof x !== 'number' || typeof y !== 'number') return null
        return { x, y }
      }

      const getPanelPosition = (key: string): { x: number; y: number } | null => {
        const items = canvasItemsRef.current
        const parsedKey = key.includes('::') ? parsePanelKey(key) : null
        const targetNoteId = parsedKey?.noteId ?? noteId
        const targetPanelId = parsedKey?.panelId ?? key
        const storeKey = ensurePanelKey(targetNoteId, targetPanelId)

        const panel = items.find(item => {
          if (item.itemType !== 'panel') return false
          if (key.includes('::')) {
            return item.storeKey === key
          }
          if (item.storeKey === storeKey) {
            return true
          }
          return item.panelId === targetPanelId
        })

        if (panel?.position) {
          return { ...panel.position }
        }

        if (dataStore) {
          const record = dataStore.get(storeKey)
          if (record && typeof record === 'object') {
            const candidates = [
              normalizePosition((record as any)?.position),
              normalizePosition((record as any)?.worldPosition),
              normalizePosition((record as any)?.mainPosition),
            ]

            for (const candidate of candidates) {
              if (candidate) {
                return { ...candidate }
              }
            }
          }
        }

        if (!isPlainModeActive()) {
          const provider = UnifiedProvider.getInstance()
          const branchesMap = provider.getBranchesMap()
          const branch = branchesMap?.get(storeKey) ?? branchesMap?.get(key)
          if (branch?.position) {
            return { ...branch.position }
          }
        }

        if (targetPanelId === 'main') {
          const workspacePosition = resolveWorkspacePosition(targetNoteId)
          if (workspacePosition && !isDefaultOffscreenPosition(workspacePosition)) {
            return { ...workspacePosition }
          }
        }

        const state = canvasStateRef.current
        const el = document.querySelector(`[data-store-key="${storeKey}"]`) as HTMLElement | null
        if (el) {
          const rect = el.getBoundingClientRect()
          const container = document.getElementById('canvas-container')
          const containerRect = container?.getBoundingClientRect()

          const screenX = (rect.left + rect.width / 2) - (containerRect?.left ?? 0)
          const screenY = (rect.top + rect.height / 2) - (containerRect?.top ?? 0)

          const worldX = (screenX - state.translateX) / state.zoom
          const worldY = (screenY - state.translateY) / state.zoom

          return { x: worldX, y: worldY }
        }

        return null
      }

      let retryCount = 0
      const maxRetries = 10
      const retryDelay = 100

      const attemptCenter = () => {
        const position = getPanelPosition(storeKeyOrPanelId)

        if (position) {
          const state = canvasStateRef.current

          const selector = storeKeyOrPanelId.includes('::')
            ? `[data-store-key="${storeKeyOrPanelId}"]`
            : `[data-panel-id="${storeKeyOrPanelId}"]`
          const panelElement = document.querySelector(selector) as HTMLElement
          const panelDimensions = panelElement
            ? { width: panelElement.offsetWidth, height: panelElement.offsetHeight }
            : { width: 500, height: 400 }

          const viewportDimensions = { width: window.innerWidth, height: window.innerHeight }
          const centerOffset = {
            x: (viewportDimensions.width / 2 - panelDimensions.width / 2) / state.zoom,
            y: (viewportDimensions.height / 2 - panelDimensions.height / 2) / state.zoom
          }

          const targetX = -position.x + centerOffset.x
          const targetY = -position.y + centerOffset.y

          const canvasEl = document.getElementById('infinite-canvas')

          if (canvasEl) {
            canvasEl.style.transition = 'transform 2s ease-in-out'
            void canvasEl.offsetHeight
          }

          flushSync(() => {
            setCanvasState(prev => {
              const next = { ...prev, translateX: targetX, translateY: targetY }
              canvasStateRef.current = next
              return next
            })
          })

          dispatch({
            type: 'SET_CANVAS_STATE',
            payload: {
              translateX: targetX,
              translateY: targetY
            }
          })

          if (canvasEl) {
            setTimeout(() => {
              canvasEl.style.transition = ''
            }, 2100)
          }
        } else if (retryCount < maxRetries) {
          retryCount++
          setTimeout(attemptCenter, retryDelay)
        } else {
          console.warn(`[Canvas] Panel '${storeKeyOrPanelId}' not found after ${maxRetries} retries`)
        }
      }

      attemptCenter()
    },
    [dataStore, noteId, resolveWorkspacePosition, setCanvasState, dispatch],
  )

  const handleRestoreMainPosition = useCallback(
    (targetNoteId: string, persistedPosition: { x: number; y: number }) => {
      const storeKey = ensurePanelKey(targetNoteId, 'main')
      const normalizedPosition = { x: persistedPosition.x, y: persistedPosition.y }

      setCanvasItems(prev =>
        prev.map(item => {
          if (item.itemType === 'panel' && item.panelId === 'main') {
            const itemNoteId = getItemNoteId(item)
            if (itemNoteId === targetNoteId) {
              return { ...item, position: normalizedPosition }
            }
          }
          return item
        }),
      )

      if (dataStore) {
        try {
          dataStore.update(storeKey, { position: normalizedPosition })
        } catch (error) {
          console.warn('[AnnotationCanvas] Failed to update dataStore for restore', error)
        }
      }

      persistPanelUpdate({
        panelId: 'main',
        storeKey,
        position: normalizedPosition,
        coordinateSpace: 'world',
      }).catch(error => {
        console.warn('[AnnotationCanvas] Failed to persist panel during restore', error)
      })

      void updateMainPosition(targetNoteId, normalizedPosition).catch(error => {
        console.error('[AnnotationCanvas] Failed to update workspace main position during restore', error)
      })

      debugLog({
        component: 'AnnotationCanvas',
        action: 'restore_main_position',
        metadata: { noteId: targetNoteId, position: normalizedPosition },
      })

      onMainOnlyLayoutHandled?.(targetNoteId)
      centerOnPanel(storeKey)
    },
    [centerOnPanel, dataStore, getItemNoteId, onMainOnlyLayoutHandled, persistPanelUpdate, setCanvasItems, updateMainPosition],
  )

  // Expose methods via ref
  useImperativeHandle(ref, () => ({
    zoomIn: () => {
      updateCanvasTransform(prev => {
        const newZoom = Math.min(prev.zoom * 1.1, 2)
        return { ...prev, zoom: newZoom }
      })
    },
    zoomOut: () => {
      updateCanvasTransform(prev => {
        const newZoom = Math.max(prev.zoom * 0.9, 0.3)
        return { ...prev, zoom: newZoom }
      })
    },
    resetView: () => {
      updateCanvasTransform(prev => {
        return { ...prev, zoom: 1, translateX: 0, translateY: 0 }
      })
    },
    getCameraState: () => {
      // Use ref to get current value, not stale closure value
      return {
        translateX: canvasStateRef.current.translateX,
        translateY: canvasStateRef.current.translateY,
        zoom: canvasStateRef.current.zoom
      }
    },
    panBy,
    toggleConnections: () => {
      setCanvasState(prev => {
        return { ...prev, showConnections: !prev.showConnections }
      })
    },
    centerOnPanel,
    addComponent: (type: string, position?: { x: number; y: number }) => {
      handleAddComponent(type, position)
    }
  }), [onCanvasStateChange, canvasState, updateCanvasTransform, panBy, handleAddComponent, resolveWorkspacePosition, dataStore, noteId])

  useEffect(() => {
    debugLog({
      component: 'AnnotationApp',
      action: 'canvas_outline_applied',
      metadata: {
        outline: 'rgba(99, 102, 241, 0.85) solid 4px',
        outlineOffset: '6px'
      }
    })
  }, [])

  return (
    <>
      {secondaryNoteIds.map(id => (
        <NoteHydrator
          key={`hydrator-${id}`}
          noteId={id}
          userId={cameraUserId ?? undefined}
          dataStore={dataStore}
          branchesMap={branchesMap}
          layerManager={layerManagerApi.manager}
          enabled={true}
          workspaceVersion={workspaceNoteMap.get(id)?.version ?? null}
          onHydration={handleNoteHydration}
        />
      ))}
      <div
        className="w-screen h-screen overflow-hidden bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500"
        style={{
          opacity: canvasOpacity,
          transition: 'opacity 0.3s ease',
        }}
      >
        {dedupeWarnings.length > 0 && (
          <div className="fixed top-4 right-4 z-[1100] max-w-sm rounded-md border border-amber-500/80 bg-white/95 p-4 shadow-lg text-sm text-amber-900">
            <div className="flex items-start justify-between gap-3">
              <div>
                <p className="font-semibold">Canvas state warnings</p>
                <p className="text-xs text-amber-700">
                  Some panels are missing metadata and were normalised. Please review before continuing.
                </p>
              </div>
              <button
                type="button"
                onClick={() => updateDedupeWarnings([], { append: false })}
                className="text-xs font-medium text-amber-700 hover:text-amber-800"
              >
                Dismiss
              </button>
            </div>
            <ul className="mt-2 space-y-1">
              {dedupeWarnings.slice(0, 5).map((warning, index) => (
                <li key={`${warning.code}-${warning.storeKey ?? warning.panelId ?? index}`} className="leading-snug">
                  {warning.message}
                </li>
              ))}
            </ul>
            {dedupeWarnings.length > 5 && (
              <p className="mt-2 text-xs text-amber-700">
                +{dedupeWarnings.length - 5} more warning{dedupeWarnings.length - 5 === 1 ? '' : 's'} logged to console.
              </p>
            )}
          </div>
        )}
        {/* Demo Header - Disabled per user request */}
        {/* <div className="fixed top-0 left-0 right-0 bg-black/90 text-white p-3 text-xs font-medium z-[1000] border-b border-white/10 flex items-center justify-between">
          <span>ðŸš€ Yjs-Ready Unified Knowledge Canvas â€¢ Collaborative-Ready Architecture with Tiptap Editor</span>
          <span className="text-gray-300 flex items-center gap-2">
            <span className="text-yellow-400">ðŸ’¡</span>
            Hold <kbd className="px-2 py-0.5 bg-gray-700 rounded text-xs font-bold">Shift</kbd> + Scroll to zoom
          </span>
        </div> */}

        {/* Canvas Controls - Removed per user request */}
        {/* {!isNotesExplorerOpen && (
          <CanvasControls 
            zoom={canvasState.zoom}
            onZoomIn={() => setCanvasState(prev => ({ ...prev, zoom: Math.min(prev.zoom * 1.1, 2) }))}
            onZoomOut={() => setCanvasState(prev => ({ ...prev, zoom: Math.max(prev.zoom * 0.9, 0.3) }))}
            onResetView={() => setCanvasState(prev => ({ ...prev, zoom: 1, translateX: -1000, translateY: -1200 }))}
            onToggleConnections={() => setCanvasState(prev => ({ ...prev, showConnections: !prev.showConnections }))}
            showConnections={canvasState.showConnections}
          />
        )} */}
        
        {/* Control Panel Toggle Button - Always visible */}
        <button
          onClick={() => setShowControlPanel(!showControlPanel)}
          className="fixed top-16 right-4 p-3 bg-gray-900 hover:bg-gray-800 text-white rounded-lg shadow-lg transition-all duration-200 hover:scale-110"
          style={{ zIndex: Z_INDEX.CANVAS_MINIMAP }}
          title="Toggle Control Panel"
        >
          <Settings size={20} />
        </button>
        
        {/* Add Components Button - Moved to sidebar */}

        {/* Enhanced Control Panel V2 - Wider with always-visible metrics */}
        <EnhancedControlPanelV2 
          visible={showControlPanel}
          onClose={() => setShowControlPanel(false)}
          canvasItems={canvasItems}
          onAddComponent={handleAddComponent}
        />
        
        {/* Isolation Debug Panel - Only in development */}
        {/* Isolation Debug now integrated into Control Panel */}

        {/* Enhanced Minimap */}
        <EnhancedMinimap
          canvasItems={canvasItems}
          canvasState={canvasState}
          onNavigate={handleMinimapNavigate}
        />
        
        {/* Add Components Menu */}
        <AddComponentMenu 
          visible={showAddComponentMenu}
          onClose={() => {
            if (onToggleAddComponentMenu && externalShowAddComponentMenu) {
              onToggleAddComponentMenu()
            } else {
              setInternalShowAddComponentMenu(false)
            }
          }}
          onAddComponent={handleAddComponent}
        />

        {/* Canvas Container */}
        <div
          id="canvas-container"
          className={`relative w-full h-full cursor-grab overflow-hidden ${canvasState.isDragging ? 'cursor-grabbing' : ''}`}
          style={{
            // Isolate canvas painting to avoid cross-layer re-rasterization while dragging
            contain: 'layout paint',
            isolation: 'isolate',
            // Stabilize font rendering during transforms
            WebkitFontSmoothing: 'antialiased',
            textRendering: 'optimizeLegibility',
            // Canvas boundary - thick border around viewport
            outline: 'rgba(99, 102, 241, 0.85) solid 4px',
            outlineOffset: '6px',
          }}
          onMouseDown={handleCanvasMouseDown}
          onWheel={handleWheel}
          onMouseMoveCapture={handleCanvasMouseMoveCapture}
          onWheelCapture={handleCanvasWheelCapture}
          onContextMenu={(e) => e.preventDefault()}
        >
          {/* Infinite Canvas */}
          <div
            id="infinite-canvas"
            style={{
              position: 'absolute',
              // Use translate3d without rounding for smooth motion (infinite-canvas approach)
              transform: `translate3d(${canvasState.translateX}px, ${canvasState.translateY}px, 0) scale(${canvasState.zoom})`,
              transformOrigin: '0 0',
              // Critical: NO transition during drag to prevent text blinking
              transition: canvasState.isDragging ? 'none' : 'transform 0.3s ease',
              // Optimize GPU layers only during active drag
              willChange: canvasState.isDragging ? 'transform' : 'auto',
              // Force stable GPU layer composition
              backfaceVisibility: 'hidden' as const,
              transformStyle: 'preserve-3d' as const,
            }}
          >
            {/* Grid Background - Moves with canvas */}
            <div
              style={{
                position: 'absolute',
                left: '-5000px',
                top: '-5000px',
                width: '20000px',
                height: '16000px',
                backgroundImage: `
                  linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px)
                `,
                backgroundSize: '100px 100px',
                pointerEvents: 'none',
                zIndex: 0,
              }}
            />

            {/* Grid Coordinate Labels - Shows world coordinates */}
            {/* X-axis labels across multiple Y positions */}
            {Array.from({ length: 20 }, (_, xi) => xi * 1000).flatMap(x =>
              Array.from({ length: 10 }, (_, yi) => yi * 1000).map(y => (
                <div
                  key={`label-x${x}-y${y}`}
                  style={{
                    position: 'absolute',
                    left: `${x}px`,
                    top: `${y}px`,
                    color: 'rgba(255, 255, 255, 0.6)',
                    fontSize: '14px',
                    fontWeight: 'bold',
                    fontFamily: 'monospace',
                    pointerEvents: 'none',
                    padding: '4px 8px',
                    backgroundColor: 'rgba(0, 0, 0, 0.5)',
                    borderRadius: '4px',
                    whiteSpace: 'nowrap',
                    zIndex: 1,
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                  }}
                >
                  ({x}, {y})
                </div>
              ))
            )}

            {/* Connection Lines - Widget Studio Style */}
            {canvasState.showConnections && (!isPlainModeActive() || primaryHydrationStatus.success) && (
              <WidgetStudioConnections
                key={canvasContextState.lastUpdate ?? 0}
                canvasItems={canvasItems}
                branchVersion={canvasContextState.lastUpdate ?? 0}
              />
            )}

            {/* Panels */}
        <PanelsRenderer
          defaultNoteId={noteId}
          canvasItems={canvasItems}
          dataStore={dataStore}
          resolveWorkspacePosition={resolveWorkspacePosition}
          onRestorePanelPosition={handleRestoreMainPosition}
          onClose={handlePanelClose}
        />
            
            {/* Component Panels */}
            {floatingComponents.map(component => (
              <ComponentPanel
                key={component.id}
                id={component.id}
                type={component.componentType!}
                position={component.position}
                onClose={handleComponentClose}
                onPositionChange={handleComponentPositionChange}
              />
            ))}
          </div>
        </div>

        {stickyOverlayEl && stickyNoteItems.length > 0 && createPortal(
          stickyNoteItems.map(component => (
            <StickyNoteOverlayPanel
              key={component.id}
              id={component.id}
              position={component.position}
              onClose={handleComponentClose}
              onPositionChange={handleComponentPositionChange}
            />
          )),
          stickyOverlayEl
        )}

        {/* Annotation Toolbar - controlled by Actions button */}
        <AnnotationToolbar />

      </div>
    </>
  )
})

const ModernAnnotationCanvas = forwardRef<CanvasImperativeHandle, ModernAnnotationCanvasProps>((props, ref) => {
  const { getWorkspace } = useCanvasWorkspace()
  const workspace = useMemo(() => getWorkspace(SHARED_WORKSPACE_ID), [getWorkspace])
  const activeNoteId = props.primaryNoteId ?? props.noteIds[0] ?? ""

  useEffect(() => {
    scheduleCanvasSnapshotDedupeMigration()
  }, [])

  return (
    <IsolationProvider config={{ enabled: false }}>
      <LayerManagerProvider manager={workspace.layerManager}>
        <CanvasProvider
          noteId={activeNoteId}
          onRegisterActiveEditor={props.onRegisterActiveEditor}
          externalDataStore={workspace.dataStore}
          externalEvents={workspace.events}
        >
          <ModernAnnotationCanvasInner {...props} ref={ref} />
          {props.children}
        </CanvasProvider>
      </LayerManagerProvider>
    </IsolationProvider>
  )
})

ModernAnnotationCanvas.displayName = 'ModernAnnotationCanvas'

// Renders panels using plain dataStore in plain mode, Yjs map otherwise
function PanelsRenderer({
  defaultNoteId,
  canvasItems,
  dataStore,
  onClose,
  resolveWorkspacePosition,
  onRestorePanelPosition,
}: {
  defaultNoteId: string
  canvasItems: CanvasItem[]
  dataStore: DataStore
  onClose: (id: string, noteId?: string) => void
  resolveWorkspacePosition?: (noteId: string) => { x: number; y: number } | null
  onRestorePanelPosition?: (noteId: string, position: { x: number; y: number }) => void
}) {
  const isPlainMode = isPlainModeActive()
  const seenStoreKeys = new Set<string>()
  
  // Yjs access only when not in plain mode
  const provider = UnifiedProvider.getInstance()
  if (!isPlainMode) {
    provider.setCurrentNote(defaultNoteId)
  }
  const branchesMap = !isPlainMode ? provider.getBranchesMap() : null
  
  const panels = canvasItems.filter(isPanel)
  
  return (
    <>
      {panels.map((panel) => {
        const panelId = panel.panelId!
        const panelNoteId = panel.noteId ?? defaultNoteId
        const storeKey = panel.storeKey ?? ensurePanelKey(panelNoteId, panelId)
        const branch = isPlainMode ? dataStore.get(storeKey) : branchesMap?.get(storeKey)
        if (!branch) {
          console.warn(
            `[PanelsRenderer] Branch ${panelId} (note=${panelNoteId}, storeKey=${storeKey}) not found in ${isPlainMode ? 'plain' : 'yjs'} store`,
          )
          return null
        }

        if (seenStoreKeys.has(storeKey)) {
          console.warn(
            `[PanelsRenderer] Duplicate store key detected; skipping render`,
            { panelId, panelNoteId, storeKey },
          )
          return null
        }
        seenStoreKeys.add(storeKey)

        if (isDebugEnabled()) {
          // Debug: Log branch type being passed to CanvasPanel
          debugLog({
            component: 'AnnotationCanvas',
            action: 'rendering_panel',
            metadata: {
              panelId,
              branchType: branch.type,
              branchDbType: branch.dbType,
              branchMetadata: branch.metadata,
              isPlainMode,
            },
          })

          console.log(`[PanelsRenderer] Rendering panel ${panelId}:`, {
            hasContent: !!branch.content,
            contentLength: typeof branch.content === 'string' ? branch.content.length : 'N/A',
            isNew: branch.isNew,
            isEditable: branch.isEditable,
          })
        }

        // CRITICAL FIX: Only use workspacePosition for MAIN panel
        // Branch panels should use their own branch.position, NOT the main panel's workspace position
        const workspacePosition = (panelId === 'main') ? (resolveWorkspacePosition?.(panelNoteId) ?? null) : null
        const position = workspacePosition ?? branch.position ?? getDefaultMainPosition()

        debugLog({
          component: 'AnnotationCanvas',
          action: 'panel_position_resolution',
          metadata: {
            panelId,
            panelNoteId,
            branchPosition: branch.position,
            workspacePosition,
            finalPosition: position
          }
        })
        const shouldOfferRestore =
          panelId === 'main' &&
          workspacePosition &&
          (Math.round(workspacePosition.x) !== Math.round(position.x) ||
            Math.round(workspacePosition.y) !== Math.round(position.y))

        return (
          <CanvasPanel
            key={storeKey}
            panelId={panelId}
            branch={branch}
            position={position}
            noteId={panelNoteId}
            onClose={() => onClose(panelId, panelNoteId)}
            canRestorePosition={Boolean(shouldOfferRestore)}
            onRestorePosition={
              shouldOfferRestore && workspacePosition && onRestorePanelPosition
                ? () => onRestorePanelPosition(panelNoteId, workspacePosition)
                : undefined
            }
          />
        )
      })}
    </>
  )
}

export default ModernAnnotationCanvas 
