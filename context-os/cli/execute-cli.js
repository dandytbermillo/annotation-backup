#!/usr/bin/env node

/**
 * JSON CLI Wrapper for /execute command
 * Handles feature creation and scaffolding
 */

const fs = require('fs');
const path = require('path');
const FeatureOrchestrator = require('../create-feature');

/**
 * Input Schema:
 * {
 *   "feature": "Feature name/description",
 *   "plan": "Path to plan or description",
 *   "slug": "Optional pre-selected slug",
 *   "autoConfirm": true/false
 * }
 * 
 * Output Schema:
 * {
 *   "ok": true/false,
 *   "result": { ... },
 *   "error": "Error message if failed"
 * }
 */

async function execute(input) {
  // Parse clear action flags
  const createInitial = input.createInitial || input['create-initial'] || input.interactive;
  const createPrp = input.createPrp || input['create-prp'];
  const createImpl = input.createImpl || input['create-impl'];
  
  // Show deprecation warning for old flag
  if (input.interactive) {
    console.log('⚠️  Note: --interactive is deprecated. Use --create-initial instead.\n');
  }
  
  // Check for --create-initial flag (or legacy --interactive)
  if (createInitial || input.initOnly) {
    console.log('📝 Creating INITIAL.md for new feature...');
    
    const { spawn } = require('child_process');
    const featureSlug = input.slug || input.feature?.toLowerCase().replace(/\s+/g, '_') || 'new_feature';
    
    // Build arguments for init-interactive
    const initArgs = ['node', path.join(__dirname, 'init-interactive.js'), featureSlug];
    
    if (input.resume) initArgs.push('--resume');
    if (input.dryRun) initArgs.push('--dry-run');
    if (input.apply || input.autoConfirm) initArgs.push('--apply');
    if (input.batchMode) initArgs.push('--batch-mode');
    
    // Execute init-interactive
    return new Promise((resolve, reject) => {
      const init = spawn(initArgs[0], initArgs.slice(1), {
        stdio: 'inherit',
        cwd: path.resolve(__dirname, '..', '..')
      });
      
      init.on('close', (code) => {
        if (code === 0) {
          resolve({
            feature: input.feature || featureSlug,
            created: [`docs/proposal/${featureSlug}/INITIAL.md`],
            validation: { passed: true, errors: 0, warnings: 0 },
            status: 'PLANNED',
            slug: featureSlug,
            path: `docs/proposal/${featureSlug}`,
            interactive: true
          });
        } else {
          reject(new Error('Interactive INITIAL.md creation failed'));
        }
      });
      
      init.on('error', (err) => {
        reject(new Error(`Failed to start init-interactive: ${err.message}`));
      });
    });
  }
  
  // Check for --create-prp flag
  if (createPrp) {
    console.log('📋 Creating PRP from existing INITIAL.md...');
    
    const featureSlug = input.slug || input.feature?.toLowerCase().replace(/\s+/g, '_') || input.feature;
    const initialPath = path.join('docs', 'proposal', featureSlug, 'INITIAL.md');
    
    // Check if INITIAL.md exists
    if (!fs.existsSync(initialPath)) {
      return {
        ok: false,
        command: 'execute',
        error: `INITIAL.md not found at ${initialPath}. Run --create-initial first.`
      };
    }
    
    // Read INITIAL.md
    const initialContent = fs.readFileSync(initialPath, 'utf8');
    
    // Generate PRP content
    const prpContent = `# Pull Request Plan: ${input.feature || featureSlug}

## Source
Generated from: ${initialPath}
Date: ${new Date().toISOString()}

## Overview
${initialContent.match(/## Problem\n\n(.*?)(\n##|$)/s)?.[1] || 'See INITIAL.md for problem statement'}

## Goals
${initialContent.match(/## Goals\n\n(.*?)(\n##|$)/s)?.[1] || 'See INITIAL.md for goals'}

## Implementation Tasks
- [ ] Review INITIAL.md requirements
- [ ] Set up feature structure
- [ ] Write unit tests
- [ ] Implement core functionality
- [ ] Add integration tests
- [ ] Update documentation
- [ ] Performance testing
- [ ] Security review

## Acceptance Criteria
${initialContent.match(/## Acceptance Criteria\n\n(.*?)(\n##|$)/s)?.[1] || 'See INITIAL.md for acceptance criteria'}

## Dependencies
${initialContent.match(/## Dependencies\n\n(.*?)(\n##|$)/s)?.[1] || 'None specified'}

## Testing Strategy
- Unit tests for all new functions
- Integration tests for workflows
- E2E tests for user scenarios
- Performance benchmarks

## Rollback Plan
- Feature flag to disable
- Revert commits if needed
- Database migration rollback scripts

---
Generated by: context-execute --create-prp
Feature: ${featureSlug}
`;
    
    // Create PRPs directory if needed
    const prpDir = path.join('PRPs');
    if (!fs.existsSync(prpDir)) {
      fs.mkdirSync(prpDir, { recursive: true });
    }
    
    // Write PRP
    const prpPath = path.join(prpDir, `${featureSlug}.md`);
    fs.writeFileSync(prpPath, prpContent, 'utf8');
    
    console.log(`✅ PRP created: ${prpPath}`);
    
    return {
      ok: true,
      command: 'execute',
      action: 'create-prp',
      result: {
        feature: featureSlug,
        created: [prpPath],
        source: initialPath
      }
    };
  }
  
  // Check for --create-impl flag
  if (createImpl) {
    console.log('🔨 Creating implementation plan...');
    console.log('Note: This feature is coming soon. For now, use --create-prp.');
    
    return {
      ok: false,
      command: 'execute',
      error: 'Implementation plan generation coming soon. Use --create-prp for now.'
    };
  }
  
  // If no clear action flag, show helpful message but continue with legacy behavior
  if (!createInitial && !createPrp && !createImpl && !input.feature) {
    console.log(`
❓ No action specified. Please use one of:

📝 For NEW features (create INITIAL.md):
   /context-execute "Your Feature Name" --create-initial
   
📋 For PRP generation (from existing INITIAL.md):
   /context-execute feature_slug --create-prp

💡 Tip: --interactive still works but prefer --create-initial
`);
    return {
      ok: false,
      command: 'execute',
      error: 'No action specified. Use --create-initial or --create-prp'
    };
  }
  
  const orchestrator = new FeatureOrchestrator();
  
  // For JSON mode, make it non-interactive by default
  if (input.autoConfirm !== false) {
    // Close the real readline immediately
    if (orchestrator.rl) {
      orchestrator.rl.close();
    }
    
    // Create mock readline interface
    orchestrator.rl = {
      question: (question, callback) => {
        // Log questions to stderr for debugging only if DEBUG is set
        if (process.env.DEBUG) {
          console.error(`[AUTO] ${question}`);
        }
        
        let answer = '';
        
        if (question.includes('Your choice')) {
          // Use provided slug or default to first option
          answer = input.slug ? '4' : '1'; // 4 = custom, 1 = first suggestion
        } else if (question.includes('Enter custom slug')) {
          answer = input.slug || 'feature';
        } else if (question.includes('Proceed with scaffolding')) {
          answer = 'yes';
        } else if (question.toLowerCase().includes('would you like to fix')) {
          answer = 'no'; // Skip interactive fixing in JSON mode
        } else {
          answer = 'no'; // Default to 'no' for any other prompts
        }
        
        // Call callback with answer
        callback(answer);
      },
      close: () => {},
      closed: false
    };
  }
  
  const result = {
    feature: input.feature || 'New Feature',
    planPath: input.plan || null,
    created: [],
    validation: null,
    status: 'PLANNED'
  };
  
  try {
    // Capture console output
    const originalLog = console.log;
    const logs = [];
    console.log = (...args) => {
      logs.push(args.join(' '));
      originalLog.apply(console, args);
    };
    
    // Create the feature
    const featureResult = await orchestrator.createFeature(
      input.feature || 'New Feature',
      input.plan
    );
    
    // Restore console.log
    console.log = originalLog;
    
    // Parse logs for created files
    result.created = logs
      .filter(log => log.includes('Created:'))
      .map(log => log.replace(/.*Created:\s*/, '').trim());
    
    // Check for validation results
    const validationLog = logs.find(log => log.includes('validation'));
    if (validationLog) {
      if (validationLog.includes('passed')) {
        result.validation = { passed: true, errors: 0, warnings: 0 };
      } else {
        const errors = validationLog.match(/(\d+)\s+errors?/);
        result.validation = {
          passed: false,
          errors: errors ? parseInt(errors[1]) : 0,
          warnings: 0
        };
      }
    }
    
    // Extract the slug that was selected
    const slugLog = logs.find(log => log.includes('Selected feature slug:'));
    if (slugLog) {
      result.slug = slugLog.split(':')[1].trim();
      result.path = `../docs/proposal/${result.slug}`;
    }
    
    return result;
    
  } catch (error) {
    throw new Error(`Feature creation failed: ${error.message}`);
  } finally {
    // Ensure readline is closed
    if (orchestrator.rl && !orchestrator.rl.closed) {
      orchestrator.rl.close();
    }
  }
}

// Main CLI execution
(async () => {
  try {
    // Read input from stdin or file
    const arg = process.argv[2];
    let input = {};
    
    if (arg && arg !== '-') {
      // Read from file
      input = JSON.parse(fs.readFileSync(arg, 'utf8'));
    } else if (!process.stdin.isTTY) {
      // Read from stdin
      const chunks = [];
      for await (const chunk of process.stdin) {
        chunks.push(chunk);
      }
      const raw = Buffer.concat(chunks).toString('utf8').trim();
      if (raw) {
        input = JSON.parse(raw);
      }
    }
    
    // Execute the command
    const result = await execute(input);
    
    // Check if feature was actually created
    const success = result.created && result.created.length > 0;
    
    // Output JSON to stdout
    console.log(JSON.stringify({
      ok: success,
      command: 'execute',
      result: result,
      error: success ? undefined : 'Feature creation failed - no files created'
    }));
    
    process.exit(success ? 0 : 1);
    
  } catch (error) {
    // Error to stderr
    console.error(`[execute-cli] Error: ${error.message}`);
    
    // Error JSON to stdout
    console.log(JSON.stringify({
      ok: false,
      command: 'execute',
      error: error.message,
      stack: process.env.DEBUG ? error.stack : undefined
    }));
    
    process.exit(1);
  }
})();